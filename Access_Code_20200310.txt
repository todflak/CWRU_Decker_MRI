Component: modBasicProcessing; Standard module
Option Compare Database
Option Explicit



Public Function Do_InitialRawProcessing(SessionID As Long, _
               Optional DoDicomToNifti As Boolean = True, _
               Optional ShowLogWindows As Boolean = False, _
               Optional LogFilename As String) As eProcessingStatus

   Dim return_value As eProcessingStatus
   Dim strmLogFile  As Scripting.TextStream
   Dim psi As New clsProcessingStepInfo
   Dim fso As New Scripting.FileSystemObject
   
   return_value = Unknown
   
   On Error GoTo Do_InitialRawProcessing_Err
   
   If LogFilename <> "" Then
      Set strmLogFile = fso.OpenTextFile(LogFilename, ForAppending, True)
   End If
      
   Dim DidSomeProcessing As Boolean
   
   Dim oSession As New clsSession
   oSession.SessionID = SessionID
   


   Dim fil As Scripting.File
   Dim Success As Boolean
   
   If Not fso.FolderExists(oSession.SessionPath) Then
      Err.Raise vbObjectError + 512, "ProcessRawFiles", "For SessionID '" & SessionID & "' the referenced data folder does not exist: " & oSession.SessionPath
   Else
      
      If Not psi.LoadSessionProcessingStep(SessionID, "Initial raw data processing", "Create subfolders") Then
         psi.StartProcessing_Now
         DidSomeProcessing = True
         'ensure that the default data folders exist
         Dim strDefaultFolders() As String
         strDefaultFolders = Split(GetSettingValue(SettingName:="Default data folders", SessionID:=oSession.SessionID), ";")
         Dim i As Integer
         For i = 0 To UBound(strDefaultFolders)
            If Not fso.FolderExists(oSession.SessionPath & "\" & strDefaultFolders(i)) Then
               fso.CreateFolder oSession.SessionPath & "\" & strDefaultFolders(i)
            End If
         Next
         psi.Save_CompleteNow
      End If
      
      If Not psi.LoadSessionProcessingStep(SessionID, "Initial raw data processing", "Move raw files into subfolder") Then
        'now move any raw files into the 'raw' subfolder
         DidSomeProcessing = True
         psi.StartProcessing_Now
         MoveRawFilesToSubfolder oSession, psi
         psi.Save_CompleteNow
      End If
      
      If DoDicomToNifti And (Not psi.LoadSessionProcessingStep(SessionID, "Initial raw data processing", "Convert Dicom to Nifti")) Then
        'convert Dicom into Nii's
         DidSomeProcessing = True
         psi.StartProcessing_Now
         Success = ConvertDicomToNifti(oSession, ShowLogWindows)
         If Success Then
            psi.Save_CompleteNow
         Else
            psi.ResultValue = "ConvertDicomToNifti process failed"
            psi.Save_NotCompleteNow
            return_value = ProcessingError
         End If
      End If
      
      If (Not psi.LoadSessionProcessingStep(SessionID, "Initial raw data processing", "Designate Anatomical Nii")) Then
         If psi.DependenciesMet Then  'if NII files have been produced
         'designate the single key anatomical MPRAGE file
          DidSomeProcessing = True
          Do_DesignateAnatomicalNii oSession, psi, strmLogFile, ShowLogWindows
          If Not psi.ProcessingComplete Then
             return_value = ProcessingError
          End If
         End If
      End If


   End If
   
   If return_value = Unknown Then
      return_value = IIf(DidSomeProcessing, eProcessingStatus.Completed, eProcessingStatus.NothingToDo)
   End If



Do_InitialRawProcessing_Exit:
   If Not (strmLogFile Is Nothing) Then
      strmLogFile.Close
   End If
   Do_InitialRawProcessing = return_value
Exit Function

Do_InitialRawProcessing_Err:
   If Not (strmLogFile Is Nothing) Then
      strmLogFile.Close
   End If
   Dim strErrorMessage As String
   strErrorMessage = "Processing error: " & Err.Description
   If Not (psi Is Nothing) Then
      If Not (psi.ToString_GroupAndStep <> "-") Then
         strErrorMessage = "Error while processing for ProcessingStep '" & psi.ToString_GroupAndStep & _
               "'." & vbCrLf & _
               strErrorMessage
      End If
   End If
   
   Err.Raise vbObjectError + 512, "Do_InitialRawProcessing", strErrorMessage
     
End Function


Private Sub MoveRawFilesToSubfolder(oSession As clsSession, psi As clsProcessingStepInfo)
   Dim fso As New Scripting.FileSystemObject
   
   Dim DoRecursiveSearch As Boolean, CopyFiles As Boolean
   DoRecursiveSearch = CBool(GetSettingValue("Recursive search for raw files", ValueIfNotFound:="True"))
   
   Dim strMoveOrCopyOrLink As String
   strMoveOrCopyOrLink = GetSettingValue("MoveOrCopyFiles", psi.ProcessingStepID, ErrorIfNotFound:=True)

   Dim fldSource As Scripting.Folder
   
   If oSession.OriginalImportFolder <> "" Then
      'if this is set, use this as the source or raw data files
      Set fldSource = fso.GetFolder(oSession.OriginalImportFolder)
   Else
      'if that is not set, just look in the session folder itself
      Set fldSource = fso.GetFolder(oSession.SessionPath)
   End If
   
   MoveRawFiles oSession, fldSource, DoRecursiveSearch, strMoveOrCopyOrLink
End Sub

Private Sub MoveRawFiles(oSession As clsSession, fldSource As Scripting.Folder, CheckSubfolders As Boolean, _
         MoveCopyLinkFiles As String)
   'now move any raw files into the 'raw' subfolder
   'Should we just move all???  If there are more than 50 files, move them all
   Dim fso As New Scripting.FileSystemObject
   Dim fil As Scripting.File
   Dim ThisFileIsRawType As Boolean
   Dim CountRawTypeFiles As Integer
   Dim MoveAllFiles As Boolean
   Dim i As Integer
   Dim CopyFiles As Boolean
   Dim msg As String
   
   Dim OperationIsComplete As Boolean
   
   Select Case MoveCopyLinkFiles
      Case "Link" 'a new special case, leave the files where there are, but create a symbolic link
         Dim retval As Long
         Dim strCommandLine As String
         
         If (UCase(Left(oSession.SessionPath_Raw, 2)) <> "C:") And (UCase(Left(oSession.SessionPath_Raw, 2)) <> "D:") Then
            msg = "The 'Create Symbolic Link' option does not work correctly when your 'MRI Processing folder' specifies a mapped or network drive.  Please change to using a local drive; or choose one of the other 'Import Mechanism' options."
            modUtility.Clipboard_SetText msg
            Err.Raise vbObjectError + 512, "modBasicProcessing.MoveRawFiles", msg & vbCrLf & "(NOTE: This information has been copied to the clipboard, so you can paste into a text document or email if you wish.)"
         End If
         
         fso.DeleteFolder oSession.SessionPath_Raw  'if the raw folder exists, we need to get rid of it in order to make a symbolic link
         
         strCommandLine = "cmd /c 'mklink /j  '{LinkFolder}' '{SourceFolder}''"
         strCommandLine = Replace(strCommandLine, "{LinkFolder}", oSession.SessionPath_Raw)
         strCommandLine = Replace(strCommandLine, "{SourceFolder}", fldSource.Path)
         strCommandLine = Replace(strCommandLine, "'", """")
         
         retval = modUtility.RunCommandLine_Synchronous(strCommandLine, WindowStyle:=Minimize)
         If retval <> 0 Then
            msg = "Failed to create symbolic link to raw data folder.  Commandline that failed was: " & vbCrLf & _
               strCommandLine
            modUtility.Clipboard_SetText msg
               
            Err.Raise vbObjectError + 512, "modBasicProcessing.MoveRawFiles", msg & vbCrLf & "(NOTE: This information has been copied to the clipboard, so you can paste into a text document or email if you wish.)"
            
         End If
         OperationIsComplete = True
         
      Case "Copy"
         CopyFiles = True
      Case "Move"
         CopyFiles = False
      Case Else
         Err.Raise vbObjectError + 512, "MoveRawFiles", "Unrecognized option for setting 'MoveCopyLinkFiles'=" & MoveCopyLinkFiles
   End Select
   
   
   If Not OperationIsComplete Then
   
      Dim strRawDataExtensions() As String
      strRawDataExtensions = Split(GetSettingValue(SettingName:="Raw data file extensions", SessionID:=oSession.SessionID), ";")
      
      For Each fil In fldSource.Files
         ThisFileIsRawType = False
         For i = 0 To UBound(strRawDataExtensions)
            If fil.Name Like ("*." & strRawDataExtensions(i)) Then
               ThisFileIsRawType = True
               Exit For
            End If
         Next
         If ThisFileIsRawType Then
            CountRawTypeFiles = CountRawTypeFiles + 1
            If (CountRawTypeFiles >= 50) Then
               MoveAllFiles = True
               Exit For
            End If
         End If
      Next
      
      If MoveAllFiles Then
         Sleep 500  'not sure why this is necessary... without it, sometimes get permission denied, maybe because of recursive issues.
         'Hopefully just waiting for a moment will resolve
         If CopyFiles Then
            fso.CopyFile fldSource.Path & "\*.*", oSession.SessionPath_Raw & "\"
         Else
            fso.MoveFile fldSource.Path & "\*.*", oSession.SessionPath_Raw & "\"
         End If
         
      Else
         'move only things that match the strRawDataExtensions
         For i = 0 To UBound(strRawDataExtensions)
            On Error Resume Next
            If CopyFiles Then
               fso.CopyFile fldSource.Path & "\*." & strRawDataExtensions(i), oSession.SessionPath_Raw & "\"
            Else
               fso.MoveFile fldSource.Path & "\*." & strRawDataExtensions(i), oSession.SessionPath_Raw & "\"
            End If
            On Error GoTo 0
         Next
      End If
      
      If CheckSubfolders Then
         Dim fldSubfolder As Scripting.Folder
         For Each fldSubfolder In fldSource.SubFolders
            MoveRawFiles oSession, fldSubfolder, CheckSubfolders, MoveCopyLinkFiles
         Next
      End If
   End If
   
End Sub

Private Function ConvertDicomToNifti(oSession As clsSession, Optional ShowLogWindow As Boolean = False) As Boolean
   Dim strDicomConverterPath As String
   Dim strNiiPrefixOption As String
   Dim strFilenamePattern As String
   Dim strCommandLine As String
   Dim blnConversionOK As Boolean
   
   strDicomConverterPath = GetSettingValue(SettingName:="Dicom converter path", SessionID:=oSession.SessionID)
   strNiiPrefixOption = GetSettingValue(SettingName:="Nii prefix", SessionID:=oSession.SessionID)
   
   Select Case strNiiPrefixOption
      Case ""
         strFilenamePattern = "%p_%s"
      Case "SessionID"
         strFilenamePattern = CStr(oSession.SessionID) & "_%p_%s"
      Case Else
         Err.Raise vbObjectError + 512, "ConvertDicomToNifti", "The Setting for 'Nii prefix' is not recognized: " & strNiiPrefixOption
   End Select
   
   strCommandLine = "cmd /c ''%dcm2niix_path%' -o '%studypath_Nii%' -i {IgnoreDerived} -f %filename_pattern%  -t y -v y -ba y '%studypath_raw%' >> '%studypath_Nii%\dcm2niix_log.txt''"
   strCommandLine = Replace(strCommandLine, "%dcm2niix_path%", strDicomConverterPath)
   strCommandLine = Replace(strCommandLine, "%studypath%", oSession.SessionPath)
   strCommandLine = Replace(strCommandLine, "%studypath_Nii%", oSession.SessionPath_Nii)
   strCommandLine = Replace(strCommandLine, "%studypath_raw%", oSession.SessionPath_Raw)
   strCommandLine = Replace(strCommandLine, "%filename_pattern%", strFilenamePattern)
   strCommandLine = Replace(strCommandLine, "{IgnoreDerived}", IIf(CBool(GetSettingValue("Ignore Derived Images", SessionID:=oSession.SessionID, ValueIfNotFound:="true")), "y", "n"))
  
   strCommandLine = Replace(strCommandLine, "'", """")
   
   Dim fso As New Scripting.FileSystemObject
   Dim strLogFilepath As String
   strLogFilepath = oSession.SessionPath_Nii & "\dcm2niix_log.txt"
   Dim txt As Scripting.TextStream
   Set txt = fso.CreateTextFile(strLogFilepath)
   txt.WriteLine "Running dcm2niix, with commandline: "
   txt.WriteLine strCommandLine
   txt.Close
   
'   Dim objExec As IWshRuntimeLibrary.WshExec
'   If ShowLogWindow Then
''      Set objExec = modMRI_Common.TailLogFile(strLogFilepath)
'      modMRI_Common.TailLogFile (strLogFilepath)
'   End If
   
   Dim retval As Integer
   retval = RunCommandLine(strCommandLine, "Dicom->Nifti conversion", , strLogFilepath, False, , False, 360, True)
   Debug.Print "commandline retval=" & retval
   
   If retval = 1 Then
      'check the output folder to see if there are some Nii files
      Dim fil As Scripting.File
      Dim CountNii As Integer
      
      For Each fil In fso.GetFolder(oSession.SessionPath_Nii).Files
         If (fil.Name Like "*.nii") Or (fil.Name Like "*.nii.gz") Then
            CountNii = CountNii + 1
         End If
      Next
      If CountNii >= 1 Then
         blnConversionOK = True
      End If
   End If
      
'   If Not objExec Is Nothing Then
'      objExec.Terminate
'   End If
   ConvertDicomToNifti = blnConversionOK
End Function

Private Sub Do_DesignateAnatomicalNii(oSession As clsSession, psi As clsProcessingStepInfo, strmLogFile As Scripting.TextStream, ShowLogWindows As Boolean)
   'The goal is to designate one MPRAGE NII file as the key anatomical Nii.  If there is only one MPRAGE, it is easy!  If more than one, allow user to choose.
   ' If none, warn user that processing that relies on anatomical image cannot proceed.  TF 12 Feb 2019
   psi.StartProcessing_Now


   Dim strAnatomicalImagePattern As String, strAnatomicalImageRenamePattern As String
   strAnatomicalImagePattern = GetSettingValue(SettingName:="Anatomical Scan Filename pattern", SessionID:=oSession.SessionID)
   strAnatomicalImageRenamePattern = GetSettingValue(SettingName:="Brainsuite rename anatomical image pattern", SessionID:=oSession.SessionID)
   Dim regex As New VBScript_RegExp_55.RegExp
   regex.Pattern = strAnatomicalImagePattern
   
   Dim fil As Scripting.File
   Dim fso As New Scripting.FileSystemObject
   Dim AnatomicalImages_Count As Integer
   Dim filAnatomicalImage As Scripting.File
   Dim colfilAnatomicalImage As New Collection
   'first confirm there is only one anatomical image
   AnatomicalImages_Count = 0
   For Each fil In fso.GetFolder(oSession.SessionPath_Nii).Files
      If regex.test(fil.Name) Then
         AnatomicalImages_Count = AnatomicalImages_Count + 1
         Set filAnatomicalImage = fil
         colfilAnatomicalImage.Add fil
      End If
   Next
   
   If AnatomicalImages_Count = 0 Then
      'Err.Raise vbObjectError + 512, "CopyAnatomicalImage", "In folder " & fso.GetFolder(oSession.SessionPath_Nii) & " expected to find one anatomical Nii image, but found " & AnatomicalImages_Count & " image files."
      MsgBox "In DesignateAnatomicalNii, in folder " & fso.GetFolder(oSession.SessionPath_Nii) & " expected to find at least one anatomical Nii image, but found " & AnatomicalImages_Count & " MPRAGE image files." & vbCrLf & _
         "Any processing that relies upon an anatomical MPRAGE file cannot proceed.", vbCritical Or vbOKOnly, "Found no MPRAGE"
      Set filAnatomicalImage = Nothing
      psi.ResultComment = "No MPRAGE found"
      psi.Save_NotCompleteNow
   ElseIf AnatomicalImages_Count = 1 Then  'in this case, the filAnatomicalImage is already set above
      psi.ResultComment = "One MPRAGE found: " & filAnatomicalImage.Name
   Else  'when more than one, allow user to select
      Dim strFileList As String
      For Each fil In colfilAnatomicalImage
         strFileList = strFileList & IIf(strFileList = "", "", ";") & fil.Name
      Next
      Dim idxSelectedFile As Long
      idxSelectedFile = modAccessUtilities.UserChoiceList("There are multiple MPRAGE files for session '" & oSession.SessionDescription & "'." & vbCrLf & _
                                    "Please select the one that will be the single standard anatomical MPRAGE image for all subsequent processing.", _
                                    strFileList)
      If idxSelectedFile = 0 Then  'user Canceled
         Set filAnatomicalImage = Nothing
         psi.ResultComment = "Multiple MPRAGE images found; user Canceled selection"
         psi.Save_NotCompleteNow
      Else
         Set filAnatomicalImage = colfilAnatomicalImage(idxSelectedFile)
         psi.ResultComment = "Multiple MPRAGE images found; user selected: " & filAnatomicalImage.Name
      End If
   End If

   If Not (filAnatomicalImage Is Nothing) Then
      psi.StepOutput_Add "Structural Image", filAnatomicalImage.Path
      psi.Save_CompleteNow
   End If
   If Not (strmLogFile Is Nothing) Then strmLogFile.WriteLine psi.ResultComment
   
End Sub

Public Function DesignatedAnatomicalImageFilepath(SessionID As Long) As String
   Dim strAnatomicalImageFilepath As String
   Dim psi As New clsProcessingStepInfo
   
   If (psi.LoadSessionProcessingStep(SessionID, "Initial raw data processing", "Designate Anatomical Nii")) Then
      strAnatomicalImageFilepath = psi.StepOutout_GetSpecific("Structural Image").OutputFilename
   End If
   
   DesignatedAnatomicalImageFilepath = strAnatomicalImageFilepath
End Function
----------- end of component
Component: clsProcessingStepInfo; Class module
Option Compare Database
Option Explicit

Private mSessionID As Long
Private mProcessingStepGroupID As Long
Private mProcessingStepID As Long
Private mSession_ProcessingStepID As Long
Private mRequiresUserInteraction As Boolean

Public ProcessingStartTime As Date
Public ProcessingEndTime As Date
Public ProcessingComplete As Boolean
Private mResultValue As String
Public ResultComment As String

Private colProcessingStepOutput As Collection

Public Property Get SessionID() As Long
   SessionID = mSessionID
End Property
Public Property Let SessionID(value As Long)
   mSessionID = value
End Property

Public Property Get ProcessingStepGroupID() As Long
   ProcessingStepGroupID = mProcessingStepGroupID
End Property

Public Property Let ProcessingStepGroupID(value As Long)
   mProcessingStepGroupID = value
End Property

Public Property Let ProcessingStepGroupName(value As String)
   mProcessingStepGroupID = Nz(DLookup("ProcessingStepGroupID", "ProcessingStepGroup", "ProcessingStepGroup='" & value & "'"), -1)
End Property

Public Property Get ProcessingStepGroupName() As String
   ProcessingStepGroupName = Nz(DLookup("ProcessingStepGroup", "ProcessingStepGroup", "ProcessingStepGroupID=" & mProcessingStepGroupID), "not set")
End Property

Public Property Get ProcessingStepID() As Long
   ProcessingStepID = mProcessingStepID
End Property

Public Property Let ProcessingStepID(value As Long)
   mProcessingStepID = value
End Property

Public Property Get Session_ProcessingStepID() As Long
   Session_ProcessingStepID = mSession_ProcessingStepID
End Property

Public Property Get RequiresUserInteraction() As Boolean
   RequiresUserInteraction = mRequiresUserInteraction
End Property
Public Property Let RequiresUserInteraction(value As Boolean)
   mRequiresUserInteraction = value
End Property

Public Property Get DependenciesMet() As Boolean
   Dim met As Boolean
   Dim ProcessingStepID_Dependency As Long
   ProcessingStepID_Dependency = Nz(DLookup("ProcessingStepID_Dependency", "ProcessingStep", "ProcessingStepID=" & Me.ProcessingStepID), 0)
   If ProcessingStepID_Dependency = 0 Then
      met = True
   Else  'check if this dependency step is complete
      met = CBool(Nz(DLookup("Complete", "Session_ProcessingStep", "SessionID=" & Me.SessionID & " AND ProcessingStepID=" & ProcessingStepID_Dependency), False))
   End If
   DependenciesMet = met
End Property

Public Property Get ProcessingStep_Dependency() As clsProcessingStepInfo
   Dim ProcessingStepID_Dependency As Long
   Dim psiReturn As clsProcessingStepInfo
   
   ProcessingStepID_Dependency = Nz(DLookup("ProcessingStepID_Dependency", "ProcessingStep", "ProcessingStepID=" & Me.ProcessingStepID), 0)
   If ProcessingStepID_Dependency > 0 Then
      Set psiReturn = New clsProcessingStepInfo
      psiReturn.LoadSessionProcessingStep_ByID Me.SessionID, ProcessingStepID_Dependency
   End If
   
   Set ProcessingStep_Dependency = psiReturn
End Property

Public Property Get ProcessingStepName_Dependency() As String
   Dim returnvalue As String
   Dim ProcessingStepID_Dependency As Long
   ProcessingStepID_Dependency = Nz(DLookup("ProcessingStepID_Dependency", "ProcessingStep", "ProcessingStepID=" & Me.ProcessingStepID), 0)
   If ProcessingStepID_Dependency > 0 Then
      returnvalue = DLookup("ProcessingStep_DescriptionShort", "lookup_ProcessingStep", "ProcessingStepID=" & ProcessingStepID_Dependency)
   End If
   ProcessingStepName_Dependency = returnvalue
End Property

Public Property Let ResultValue(value As String)
   If Len(value) > 255 Then
      Err.Raise vbObjectError + 512, "clsProcessingStepInfo.ResultValue", "ResultValue may not be more than 255 characters"
   End If
   mResultValue = value
End Property

Public Property Get ResultValue() As String
   ResultValue = Left(mResultValue, 255)
End Property

Public Function ResultValue_Indexed(idx As Integer)
   ResultValue_Indexed = Split(mResultValue, "|")(idx)
End Function


Public Property Let ProcessingStepName(value As String)
   Dim count_steprecords As Integer
   Dim mProcessingStepID_Prev As Integer
   Dim strCondition As String
   
   mProcessingStepID_Prev = mProcessingStepID
   mProcessingStepID = 0
   
   strCondition = "ProcessingStep='" & value & "'"
   If mProcessingStepGroupID > 0 Then
      strCondition = strCondition & " AND ProcessingStepGroupID=" & mProcessingStepGroupID
   End If
   count_steprecords = DCount("ProcessingStepID", "ProcessingStep", strCondition)
   If count_steprecords <> 1 Then
      mProcessingStepID = -1
      Err.Raise vbObjectError + 512, "clsProcessingStepInfo.ProcessingStepName", "Found " & count_steprecords & " records on ProcessingStep that match condition: " & strCondition & _
         IIf(count_steprecords > 1 And mProcessingStepGroupID <= 0, vbCrLf & "First specify the ProcessingStepGroupName to resolve ambiguous ProcessingStepName.", "")
   Else
      mProcessingStepID = Nz(DLookup("ProcessingStepID", "ProcessingStep", strCondition), -1)
   End If
      
   If mProcessingStepID <> mProcessingStepID_Prev Then
      Me.StepOutput_Clear
   End If
End Property

Public Property Get ProcessingStepName() As String
   ProcessingStepName = Nz(DLookup("ProcessingStep", "ProcessingStep", "ProcessingStepID=" & mProcessingStepID), "not set")
End Property

Public Property Get StepOutputs() As Collection
   Set StepOutputs = colProcessingStepOutput
End Property

Public Function StepOutout_GetSpecific(StepOutputTypeName As String, Optional Iteration As Integer = -1) As clsProcessingStepOuptut
   Dim pso As clsProcessingStepOuptut, psoReturn As clsProcessingStepOuptut
   Set psoReturn = Nothing
   
   For Each pso In Me.StepOutputs
      If (pso.OutputType = StepOutputTypeName) Or (StepOutputTypeName = "") Then
         If Iteration < 0 Or (Iteration = pso.Iteration) Then
            Set psoReturn = pso
            Exit For
         End If
      End If
   Next
   
   Set StepOutout_GetSpecific = psoReturn
End Function


Public Sub StepOutput_Add(OutputType As String, OutputFilename As String, Optional Iteration As Integer = -1, _
         Optional OutputInformation As String = "", Optional Comment As String = "")
   Dim pso As clsProcessingStepOuptut, psoToUpdate As clsProcessingStepOuptut
   'look for existing object with same OutputType and Iteration

   For Each pso In colProcessingStepOutput
      If (pso.OutputType = OutputType) And (pso.Iteration = Iteration) Then
         Set psoToUpdate = pso
         Exit For
      End If
   Next
   
   If psoToUpdate Is Nothing Then
      Set psoToUpdate = New clsProcessingStepOuptut
      psoToUpdate.OutputType = OutputType
      psoToUpdate.Iteration = Iteration
      psoToUpdate.OutputFilename = OutputFilename
      psoToUpdate.OutputInformation = OutputInformation
      psoToUpdate.Comment = Comment
      colProcessingStepOutput.Add psoToUpdate
   Else
     'this is the only field that we will allow updates of for an existing record.
      psoToUpdate.OutputFilename = OutputFilename
   End If
   
   
End Sub

Private Function Get_Session_ProcessingStep_Rec(LockType As ADODB.LockTypeEnum) As ADODB.Recordset
   Dim rs As New ADODB.Recordset
   Dim strSQL As String
   strSQL = "SELECT * FROM Session_ProcessingStep WHERE SessionID=" & mSessionID & " AND ProcessingStepID=" & mProcessingStepID
   rs.Open strSQL, CurrentProject.Connection, adOpenStatic, LockType
   Set Get_Session_ProcessingStep_Rec = rs
End Function

Public Function LoadSessionProcessingStep_ByID(SessionID As Long, ProcessingStepID As Long) As Boolean
   Me.SessionID = SessionID
   mProcessingStepID = ProcessingStepID
   mProcessingStepGroupID = Nz(DLookup("ProcessingStepGroupID", "ProcessingStep", "ProcessingStepID=" & mProcessingStepID), -1)
   LoadSessionProcessingStep_ByID = GetStatus
End Function

Public Function LoadSessionProcessingStep(SessionID As Long, ProcessingStepGroupName As String, ProcessingStepName As String) As Boolean
   Me.SessionID = SessionID
   Me.ProcessingStepGroupName = ProcessingStepGroupName
   Me.ProcessingStepName = ProcessingStepName
   LoadSessionProcessingStep = GetStatus
End Function

Public Function GetStatus() As Boolean
   'looks for existing record on Session_ProcessingStep, reads info
   'Returns True if the step has been completed; returns false if record does not exist, or if Complete flag is false
   If mSessionID <= 0 Or mProcessingStepID <= 0 Then
      Err.Raise vbObjectError + 512, "clsProcessingStepInfo.StepHasBeenCompleted", "You must first specify the SessionID and ProcessingStepName (or ProcessingStepID)"
   End If
   
   ProcessingComplete = False
   Me.StepOutput_Clear
   
   Dim rs As ADODB.Recordset
   Set rs = Get_Session_ProcessingStep_Rec(adLockReadOnly)
   
   If Not rs.EOF Then
      mSession_ProcessingStepID = rs![Session_ProcessingStepID]
      Me.ProcessingComplete = CBool(rs![Complete])
      Me.ProcessingStartTime = CDate(Nz(rs![ProcessingStartTime], ProcessingStartTime))
      Me.ProcessingEndTime = CDate(Nz(rs![ProcessingEndTime], ProcessingEndTime))
      Me.ResultValue = Nz(rs![ResultValue], "")
      Me.ResultComment = Nz(rs![ResultComment], "")
      Me.RequiresUserInteraction = CBool(Nz(rs![RequiresUserInteraction], False))
      Get_StepOutputRecords
   Else
      mSession_ProcessingStepID = 0
      Me.ProcessingComplete = False
      Me.ProcessingStartTime = 0
      Me.ProcessingEndTime = 0
      Me.ResultValue = ""
      Me.ResultComment = ""
      Me.RequiresUserInteraction = False
   End If
   'clsProcessingStepInfo
   'SessionID  ProcessingStepID  Complete ProcessingStartTime  ProcessingEndTime
   rs.Close
   
   GetStatus = ProcessingComplete
End Function

Private Sub Get_StepOutputRecords()
   
   Dim strSQL As String
   strSQL = "SELECT * FROM Session_ProcessingStepOutput WHERE Session_ProcessingStepID=" & Me.Session_ProcessingStepID
   
   Dim rs As New ADODB.Recordset
   rs.Open strSQL, CurrentProject.Connection, adOpenStatic, adLockReadOnly
   
   Me.StepOutput_Clear
   Dim pso As clsProcessingStepOuptut
      
   Do Until rs.EOF
      Set pso = New clsProcessingStepOuptut
      pso.OutputFilename = rs![OutputFilename]
      pso.OutputType = rs![OutputType]
      pso.Iteration = Nz(rs![Iteration], -1)
      pso.OutputInformation = Nz(rs![OutputInformation], "")
      pso.Comment = Nz(rs![Comment], "")
      
      colProcessingStepOutput.Add pso
      rs.MoveNext
   Loop
   rs.Close
End Sub


Public Sub Save()
   Dim rs As ADODB.Recordset
   Set rs = Get_Session_ProcessingStep_Rec(adLockOptimistic)
   Dim CreateNew As Boolean
   CreateNew = rs.EOF
   If CreateNew Then
      rs.AddNew
   End If
   
   With rs
      'SessionID  ProcessingStepID  Complete ProcessingStartTime  ProcessingEndTime
      If CreateNew Then
         ![SessionID] = Me.SessionID
         ![ProcessingStepID] = Me.ProcessingStepID
      End If
      ![Complete] = Me.ProcessingComplete
      ![ProcessingStartTime] = Me.ProcessingStartTime
      ![ProcessingEndTime] = Me.ProcessingEndTime
      ![ResultValue] = Me.ResultValue
      ![ResultComment] = Me.ResultComment
      ![RequiresUserInteraction] = Me.RequiresUserInteraction
   End With
   
   rs.Update
   If CreateNew Then
      mSession_ProcessingStepID = rs![Session_ProcessingStepID]
   End If
   rs.Close
   
   Dim pso As clsProcessingStepOuptut
   For Each pso In colProcessingStepOutput
      StepOutput_SaveRecord pso
   Next
End Sub

Private Sub StepOutput_SaveRecord(pso As clsProcessingStepOuptut)
   Dim strSQL As String
   strSQL = "SELECT * FROM Session_ProcessingStepOutput WHERE Session_ProcessingStepID = " & Me.Session_ProcessingStepID & _
            " AND OutputType='" & pso.OutputType & "' AND Iteration" & IIf(pso.Iteration < 0, " IS NULL", "=" & CStr(pso.Iteration))
            
   Dim rs As New ADODB.Recordset
   rs.Open strSQL, CurrentProject.Connection, adOpenStatic, adLockOptimistic
   If rs.EOF Then
      rs.AddNew
      rs![Session_ProcessingStepID] = Me.Session_ProcessingStepID
      rs![OutputType] = pso.OutputType
      If pso.Iteration > 0 Then rs![Iteration] = pso.Iteration
      rs![OutputInformation] = pso.OutputInformation
      rs![Comment] = pso.Comment
   End If
   'this is the only field that we will allow updates of for an existing record.
   rs![OutputFilename] = pso.OutputFilename
   
   rs.Update
   rs.Close
   
End Sub
Public Sub Save_CompleteNow()
   Me.ProcessingEndTime = Now
   Me.ProcessingComplete = True
   Me.Save
End Sub

Public Sub Save_NotCompleteNow()
   Me.ProcessingEndTime = Now
   Me.ProcessingComplete = False
   Me.Save
End Sub

Public Sub StartProcessing_Now()
   Me.ProcessingStartTime = Now
End Sub

Public Function ToString() As String
   Dim str As String
   str = Me.ToString_GroupAndStep & ": Completed=" & Me.ProcessingComplete
   ToString = str
End Function

Public Function ToString_GroupAndStep() As String
   Dim str As String
   str = Me.ProcessingStepGroupName & "-" & Me.ProcessingStepName
   ToString_GroupAndStep = str
End Function

Public Sub StepOutput_Clear()
   Dim i As Integer
   For i = 1 To colProcessingStepOutput.Count
      colProcessingStepOutput.Remove 1
   Next
End Sub

Private Sub Class_Initialize()
   Set colProcessingStepOutput = New Collection
End Sub

Private Sub Class_Terminate()
   Me.StepOutput_Clear
   Set colProcessingStepOutput = Nothing
End Sub
----------- end of component
Component: modMRI_Common; Standard module
Option Compare Database
Option Explicit


#If Office_64bit Then
Public Declare PtrSafe Sub Sleep Lib "kernel32" (ByVal dwMilliseconds As Long)
#Else
Public Declare Sub Sleep Lib "kernel32" (ByVal dwMilliseconds As Long)
#End If


Public Const DisplayOutputToDebugWindow As Boolean = True

Public Enum eProcessingStatus
   Unknown
   Completed
   ProcessingError
   RequiresUserInteraction
   RequiresAdditionalProcessing
   UnmetDependency
   NothingToDo
   UserReviewNotComplete
End Enum


Public Function eProcessingStatus_ToString(val As eProcessingStatus) As String
   Dim retval As String
   
   Select Case val
      Case eProcessingStatus.Unknown
         retval = "Unknown"
      Case eProcessingStatus.Completed
         retval = "Completed"
      Case eProcessingStatus.ProcessingError
         retval = "Processing Error"
      Case eProcessingStatus.RequiresUserInteraction
         retval = "Requires User Interaction"
      Case eProcessingStatus.RequiresAdditionalProcessing
         retval = "Requires Additional Processing"
      Case eProcessingStatus.UnmetDependency
         retval = "Unmet Dependency"
      Case eProcessingStatus.NothingToDo
         retval = "Nothing To Do"
      Case eProcessingStatus.UserReviewNotComplete
         retval = "User Review Not Complete"
      Case Else
         retval = "unsupported value"
   End Select
   eProcessingStatus_ToString = retval
End Function

'If SessionID is specified, looks in view "Setting_per_Session" which allows overrides of general setting
' based on records in table  "Setting_Specific"
'If StudyID is specified, looks in view "Setting_per_Study" which allows overrides of general setting
' based on records in table  "Setting_Specific"
'If ProcessingStepID is specified, further constrains the setting to be specific for a ProcessingStepID (this
'  allows the possiblility of multiple settings of the same name being specified for different processing
' steps.

'If the setting value found contains a string in the form "{setting_name}", will look for that setting name
' by another call to this function, and if found will replace that section.
Public Function GetSettingValue(SettingName As String, Optional ProcessingStepID As Long = -1, _
               Optional SessionID As Long = -1, Optional StudyID As Long = -1, _
               Optional ValueIfNotFound As String = "", Optional ErrorIfNotFound As Boolean = False, _
               Optional ReturnSettingID As Boolean = False) As String
   
   Dim strValue As String
   Dim rs As New ADODB.Recordset
   Dim strSQL As String
   
   If StudyID > 0 Then
      strSQL = "SELECT DISTINCT SettingID, Nz([SettingValue_Long],[SettingValue]) AS SettingVal FROM Setting_per_Study WHERE StudyID=" & StudyID & " AND SettingName='" & SettingName & "'"
   ElseIf SessionID > 0 Then
      strSQL = "SELECT DISTINCT SettingID, Nz([SettingValue_Long],[SettingValue]) AS SettingVal FROM Setting_per_Session WHERE SessionID=" & SessionID & " AND SettingName='" & SettingName & "'"
   Else
      strSQL = "SELECT DISTINCT SettingID, Nz([SettingValue_Long],[SettingValue]) AS SettingVal FROM Setting WHERE SettingName='" & SettingName & "'"
   End If
   
   If ProcessingStepID > 0 Then
      strSQL = strSQL & " AND ProcessingStepID=" & ProcessingStepID
   End If
   
   rs.Open strSQL, CurrentProject.Connection, adOpenStatic, adLockReadOnly
   
   
   
   If rs.EOF Then
      If Not ErrorIfNotFound Then
         strValue = ValueIfNotFound
      Else
         Err.Raise vbObjectError + 512, "GetSettingValue", "Failed to find Setting row with SettingName='" & SettingName & "'"
      End If
   Else
      If rs.RecordCount > 1 Then
         Err.Raise vbObjectError + 512, "GetSettingValue", "Found " & rs.RecordCount & " rows with SettingName='" & SettingName & "'"
      Else
         If ReturnSettingID Then
            strValue = Nz(rs![SettingID], "-1")
         Else
            strValue = Nz(rs![SettingVal], "")
         End If
      End If
   End If

   
   If Not rs.EOF Then
      Dim blnExpandEmbeddedSettigns As Boolean
      blnExpandEmbeddedSettigns = CBool(DLookup("ExpandEmbeddedSettings", "Setting", "SettingID=" & rs![SettingID]))
      If blnExpandEmbeddedSettigns Then
         'Check for any text in the form of "{setting_name}", and try to replace those by another call to GetSettingValue
         'I am not convinced that this code will work prefectly with multiple replaceable params... not really tested.
         Dim replaceable_sections() As String
         replaceable_sections = modUtility.RegEx_ExtractSubstrings(strValue, "\{([^\}]+)\}", True, True, False)
         If Join(replaceable_sections) <> "" Then
            Dim i As Integer
            For i = 0 To UBound(replaceable_sections)
               Dim strReplacementValue As String
               Dim strReplaceableParamName As String, strSpecialReplacementType As String
               strReplaceableParamName = replaceable_sections(i)
               
               'look fot special param separated by colon, such as "Environ:Username"
               If InStr(strReplaceableParamName, ":") > 0 Then
                  Dim strSections() As String
                  strSections = Split(strReplaceableParamName, ":")
                  strSpecialReplacementType = strSections(0)
                  strReplaceableParamName = strSections(1)
               Else
                  strSpecialReplacementType = ""
               End If
               
               Select Case LCase(strSpecialReplacementType)
                  Case "environ"
                     strReplacementValue = Environ(strReplaceableParamName)
                  Case "specialfolder"
                     Dim SpecialFolderType As eSpecialFolders
                     Select Case LCase(strReplaceableParamName)
                        Case "desktop"
                           SpecialFolderType = eSpecialFolders.Desktop
                        Case "programs"
                           SpecialFolderType = eSpecialFolders.Programs
                        Case "mydocuments"
                           SpecialFolderType = eSpecialFolders.MyDocuments
                        Case Else
                           Err.Raise vbObjectError + 512, "For SpecialReplacementType '" & strSpecialReplacementType & "' in Setting named '" & SettingName & "', the special folder option '" & strReplaceableParamName & "' is not recognized... it could be added in the method 'GetSettingValue'."
                     End Select
                     
                     strReplacementValue = modUtility.Environ_SpecialFolder(SpecialFolderType)
                     
                  Case ""  'no special replacement type, so just so a lookup on the Settings table
                     Select Case strReplaceableParamName
                        'process some special cases
                        Case "Project_DataFolderRoot"
                           If SessionID > 0 Then
                              Dim oSession As New clsSession
                              oSession.SessionID = SessionID
                              strReplacementValue = oSession.DataRootPath
                           Else
                              strReplacementValue = "<SessionID must be specified>"
                           End If
                        Case Else
                           strReplacementValue = GetSettingValue(strReplaceableParamName, ValueIfNotFound:="<not found>")
                     End Select
                  Case Else '
                     Err.Raise vbObjectError + 512, "Unrecognized SpecialReplacementType '" & strSpecialReplacementType & "' in Setting named '" & SettingName & "'"
               End Select
               
               If strReplacementValue <> "<not found>" Then
                  strValue = Replace(strValue, "{" & replaceable_sections(i) & "}", strReplacementValue, , , vbBinaryCompare)
               End If
            Next
         End If
      End If
   End If
   rs.Close
      
   GetSettingValue = strValue
End Function


Public Sub UpdateSettingValue(SettingName As String, SettingValue As String, SaveAsLocalSetting As Boolean, _
      Optional ProcessingStepID As Long = -1, _
      Optional SessionID As Long = -1, Optional StudyID As Long = -1)
      
   If SaveAsLocalSetting And (SessionID > 0 Or StudyID > 0) Then
      Err.Raise vbObjectError + 512, "UpdateSettingValue", "It is not permitted to specify SaveAsLocalSetting=true when also specifying the SessionID or StudyID.  Session/Study specific settings are only allowed in the shared (backend) Settings_Specific table. "
   End If
      
   Dim SettingID_ToUpdate As Long
   Dim strSQL As String
   
   SettingID_ToUpdate = CLng(GetSettingValue(SettingName, ProcessingStepID, SessionID, StudyID, "-1", False, True))
   If SettingID_ToUpdate <= 0 Then
      Err.Raise vbObjectError + 512, "UpdateSettingValue", "Failed to find setting with SettingName='" & SettingName & "'"
   Else
      'confirm that the setting is in the correct table
      Dim strSettingName_Check As String
      If SaveAsLocalSetting Then
         strSQL = "UPDATE Setting_Local SET SettingValue=""" & SettingValue & """ WHERE SettingID=" & CStr(SettingID_ToUpdate)
      ElseIf (SessionID > 0 Or StudyID > 0) Then
         strSettingName_Check = Nz(DLookup("SettingName", "Setting_Specific", "SettingID=" & CStr(SettingID_ToUpdate)), "")
         If strSettingName_Check = SettingName Then
            strSQL = "UPDATE Setting_Specific SET SettingValue=""" & SettingValue & """ WHERE SettingID=" & CStr(SettingID_ToUpdate)
         End If
      Else
         strSettingName_Check = Nz(DLookup("SettingName", "Setting_Shared", "SettingID=" & CStr(SettingID_ToUpdate)), "")
         If strSettingName_Check = SettingName Then
            strSQL = "UPDATE Setting_Shared SET SettingValue=""" & SettingValue & """ WHERE SettingID=" & CStr(SettingID_ToUpdate)
         End If
      End If
            
      If strSQL <> "" Then
         Dim db As DAO.Database
         Set db = CurrentDb
         db.Execute strSQL
         If db.RecordsAffected = 0 Then
            Err.Raise vbObjectError + 512, "UpdateSettingValue", "Failed to update a setting record; the SQL was:" & vbCrLf & strSQL
         End If
      End If
      
   End If
      
End Sub

'Return value: if timed-out, returns -1; otherwise returns the return code from
'  IWshRuntimeLibrary.WshExec.Status, which is one of the WshExecStatus enumeration.
Public Function RunCommandLine(strCommandLine As String, Optional CommandDescription As String = "", _
            Optional WorkingDirectory As String = "", _
            Optional LogFilenameToMonitor As String = "", Optional ShowLogWindow As Boolean = False, _
            Optional strmEchoToTextStream As Scripting.TextStream = Nothing, _
            Optional EchoToDebugWindow As Boolean = False, Optional Timeout_seconds As Double = 0, _
            Optional TerminateProgressWhenCommandCompletes As Boolean = False, _
            Optional DeleteExistingLogFile As Boolean = True, Optional SaveCommandLineIntoLogFile As Boolean = True, _
            Optional CloseWindowWhenComplete As Boolean = True) As Integer
            
   Dim fso As Scripting.FileSystemObject
   Dim strmLogFile As Scripting.TextStream
   Dim ProvideFeedback As Boolean
   Dim SleepIfNoFeedback_ms As Long
   Dim datNextFeedback_Simple As Date, datStartTime As Date
   Dim PrintFeedback As Boolean
   Dim strLines() As String, strAll As String, strLineLast As String, strLine As String
   Dim i As Integer
   Dim lngPID_Command As Long
   Dim wsh As New IWshRuntimeLibrary.WshShell
   Dim objExec As IWshRuntimeLibrary.WshExec
   Dim TailIsOpen As Boolean
   
   ProvideFeedback = (Not (strmEchoToTextStream Is Nothing)) Or EchoToDebugWindow
   SleepIfNoFeedback_ms = 300
   
   If LogFilenameToMonitor <> "" Then
      Set fso = New Scripting.FileSystemObject
      
      If DeleteExistingLogFile And fso.FileExists(LogFilenameToMonitor) Then
         fso.DeleteFile LogFilenameToMonitor
      End If
      
      If Not fso.FileExists(LogFilenameToMonitor) Then  'if it doesn't exist yet, create it
         Sleep 200
         Set strmLogFile = fso.CreateTextFile(LogFilenameToMonitor, True)
         strmLogFile.Close
      End If
      If SaveCommandLineIntoLogFile Then
         Set strmLogFile = fso.OpenTextFile(LogFilenameToMonitor, ForAppending, False)
         strmLogFile.WriteLine "Start time: " & FormatDateTime(Now, vbGeneralDate)
         If WorkingDirectory <> "" Then strmLogFile.WriteLine "Set working directory to: " & WorkingDirectory
         strmLogFile.WriteLine "Command line being executed:"
         strmLogFile.WriteLine strCommandLine
         strmLogFile.WriteLine "------------------"
         strmLogFile.Close
      End If
      
      Set strmLogFile = fso.OpenTextFile(LogFilenameToMonitor, ForReading)
      
      If ShowLogWindow Then
           TailIsOpen = modMRI_Common.TailLogFile(LogFilenameToMonitor)
      End If
   End If
   
   If ProvideFeedback And (strmLogFile Is Nothing) Then
      'if doing simple progress feedback, set up a fixed array of lines
      ReDim strLines(2)
   End If
   
   Dim blnTerminateLoop As Boolean
   Dim blnTimedOut As Boolean
   
   datStartTime = Now
   If WorkingDirectory <> "" Then wsh.CurrentDirectory = WorkingDirectory
   Set objExec = wsh.Exec(strCommandLine)
   
   Do
      If Timeout_seconds > 0 Then blnTimedOut = (DateDiff("s", datStartTime, Now) > Timeout_seconds)
      blnTerminateLoop = (objExec.Status <> WshRunning) Or blnTimedOut
      DoEvents
      
      If ProvideFeedback Then
         PrintFeedback = False
         'assemble an array if strings to output... either from log file, or simple progress
         If Not strmLogFile Is Nothing Then
            If Not strmLogFile.AtEndOfStream Then
               PrintFeedback = True
               strAll = strmLogFile.ReadAll
               strLines = Split(strAll, vbCrLf)
               strLineLast = strLines(UBound(strLines))  'assume the last line in our ReadAll was not complete...
                                 'if it ended with CRLF, then we will have output it, and strLineLast will be empty string
            End If
         Else
            If (Now > datNextFeedback_Simple) Then
               PrintFeedback = True
               strLines(0) = "  " & CommandDescription & " Progress: elapsed time = " & DateDiff("s", datStartTime, Now) & " seconds"
               strLines(1) = ""

               datNextFeedback_Simple = DateAdd("s", 5, Now)
            End If
         End If
         
         If PrintFeedback Then
            For i = 0 To UBound(strLines) - IIf(blnTerminateLoop, 0, 1) 'do not output the final line... it is not a completed line yet
               If i = 0 Then
                  strLine = strLineLast & strLines(i)
               Else
                  strLine = strLines(i)
               End If
               
               If Not (strmEchoToTextStream Is Nothing) Then
                  strmEchoToTextStream.WriteLine strLine
               End If
               
               If EchoToDebugWindow Then
                  Debug.Print strLine
               End If
               
               If TerminateProgressWhenCommandCompletes And (objExec.Status <> WshRunning) Then
                  blnTerminateLoop = (objExec.Status <> WshRunning) Or blnTimedOut
                  If blnTerminateLoop Then Exit For
               End If
            Next
         Else
            Sleep SleepIfNoFeedback_ms
         End If
      End If
   Loop Until blnTerminateLoop

   If Not strmLogFile Is Nothing Then
      strmLogFile.Close
   End If
   
   If blnTimedOut Then
      RunCommandLine = -1
   Else
      RunCommandLine = objExec.Status
   End If
   
   
   If CloseWindowWhenComplete Then
      If Not (objExec Is Nothing) Then
         If objExec.ProcessID <> 0 Then
            Shell "cmd /c taskkill /pid " & CStr(objExec.ProcessID) & "  /t"
         End If
      End If
      If TailIsOpen Then
         Dim ai As New AutoItX3Lib.AutoItX3
         ai.AutoItSetOption "WinTitleMatchMode", 2 'match substring
         ai.WinClose "-Path '" & LogFilenameToMonitor & "'"
         Set ai = Nothing
      End If
   End If
   
End Function
            
            
Public Function TailLogFile(Filename As String) As Boolean
   On Error GoTo TailLogFile_Err
   Dim TailCommandTemplate As String
   TailCommandTemplate = Environ("comspec") & " /k powershell -Command ""& {Get-Content -Path '{Filename}' -Wait}"""
   Dim strTailCommand As String
   strTailCommand = Replace(TailCommandTemplate, "{Filename}", Filename)
   
   Dim wsh As New IWshRuntimeLibrary.WshShell
   Dim objExec As IWshRuntimeLibrary.WshExec
   'Set objExec = wsh.Exec(strTailCommand)
  ' Set objExec = wsh.Exec("cmd /k")
  ' objExec.StdIn.WriteLine strTailCommand
   wsh.Run strTailCommand, , False

   TailLogFile = True
Exit Function
   
TailLogFile_Err:
   TailLogFile = False
End Function



----------- end of component
Component: modCorticalSurfaceExtraction; Standard module
Option Compare Database
Option Explicit

Const ModuleName As String = "modCorticalSurfaceExtraction"

Private mobjMatlab As clsMatLab
Private m_BSC As clsBrainSuiteCommander

Public Function CreateStudy(oSession As clsSession)
   'If it doesn't exist, create a Study record
   If oSession.StudyID_GetSpecific("Cortical Segmentation") <= 0 Then
      Dim intStudyTypeID_CorticalSegmentation As Integer
      intStudyTypeID_CorticalSegmentation = CInt(DLookup("StudyTypeID", "StudyType", "StudyType='Cortical Segmentation'"))
      Dim rs As New ADODB.Recordset
      rs.Open "SELECT * FROM Study WHERE SessionID=" & oSession.SessionID & " AND StudyTypeID=" & intStudyTypeID_CorticalSegmentation, CurrentProject.Connection, adOpenStatic, adLockOptimistic
      If rs.EOF Then 'if failed to find a matching record, add one
         rs.AddNew
         rs![StudyTypeID] = intStudyTypeID_CorticalSegmentation
         rs![SessionID] = oSession.SessionID
         rs![Iteration] = Null
         rs![filepath] = oSession.SessionPath_Brainsuite
         rs.Update
      End If
      rs.Close
   End If

End Function
'return value indicates if processing completed.  Return value is False if there was some error in processing, or if we hit a Pause Processing step
Public Function DoCorticalSurfaceExtraction(SessionID As Long, Optional ShowLogWindows As Boolean = False, _
                           Optional LogFilename As String = "") As eProcessingStatus
   Dim return_value As eProcessingStatus
   Dim strBrainsuiteProgramFolder As String
   Dim DidSomeProcessing As Boolean
   Dim oSession As New clsSession
   Dim psi As New clsProcessingStepInfo
   Dim rsProcessingSteps As New ADODB.Recordset
   Dim strSQL As String
   Dim strmLogFile As Scripting.TextStream
   
   return_value = Unknown
   
   
   On Error GoTo DoCorticalSurfaceExtraction_Err
   
   If LogFilename <> "" Then
      Dim fso As New FileSystemObject
      Set strmLogFile = fso.OpenTextFile(LogFilename, ForAppending, True)
   End If
   
   oSession.SessionID = SessionID
   
   strBrainsuiteProgramFolder = GetSettingValue(SettingName:="Brainsuite program folder", SessionID:=SessionID)
   
   psi.SessionID = oSession.SessionID
   psi.ProcessingStepGroupName = "Cortical surface extraction"
   
   strSQL = "SELECT * FROM ProcessingStep WHERE EnableStep=True AND ProcessingStepGroupID=" & psi.ProcessingStepGroupID & " ORDER BY ProcessingOrder ASC"
   rsProcessingSteps.Open strSQL, CurrentProject.Connection, adOpenStatic, adLockReadOnly
   
   CreateStudy oSession

   If m_BSC Is Nothing Then
      Set m_BSC = New clsBrainSuiteCommander
   End If
   
   Dim strMessage As String
   
   Do Until rsProcessingSteps.EOF
      psi.ProcessingStepName = rsProcessingSteps![ProcessingStep]
      If Not psi.GetStatus Then
         If Not psi.DependenciesMet Then
            return_value = UnmetDependency
            If Not (strmLogFile Is Nothing) Then
               strmLogFile.WriteLine "Interrupting processing of SessionID=" & SessionID & ", ProcessingStep='" & rsProcessingSteps![ProcessingStep] & "'; this step requires previous completion of step '" & psi.ProcessingStepName_Dependency & "'."
            End If
            Exit Do  'assume that if we have an unmet dependency, we cannot proceed to the next step
         Else
            If Not (strmLogFile Is Nothing) Then
               strmLogFile.WriteLine "Beginning processing for SessionID=" & SessionID & "; ProcessingStep='" & rsProcessingSteps![ProcessingStep] & "'"
            End If
            
            DidSomeProcessing = True
            
            Select Case rsProcessingSteps![ProcessingStep]
               Case "Copy anatomical Nii"
                  Do_CopyAnatomicalNii oSession, psi, strmLogFile, ShowLogWindows
                  
               Case "Skull Stripping Mask (BSE)"
                  Do_SkullStripping oSession, psi, strmLogFile, ShowLogWindows
               
               Case "TPM for Brainsuite"
                  Do_TPM_for_Brainsuite oSession, psi, strmLogFile, ShowLogWindows
                  
               Case "Create Brain mask"
                  Do_CreateBrainMask oSession, psi, strmLogFile, ShowLogWindows
               
               Case "Review brain mask"
                  'if we hit this step, which has not been marked Complete, stop processing
                  strMessage = "User must review skull stripping mask for image in '" & oSession.SessionPath_Brainsuite & "'"
                  psi.ResultComment = strMessage
                  psi.RequiresUserInteraction = True
                  psi.Save_NotCompleteNow
                  Debug.Print strMessage
                  If Not (strmLogFile Is Nothing) Then strmLogFile.WriteLine strMessage
                  return_value = RequiresUserInteraction
                  Exit Do
                  
               Case "Skull and Scalp"
                  Do_SkullAndScalp oSession, psi, strmLogFile, ShowLogWindows
                  
               Case "Non-uniformity correction"
                  Do_NonUniformityCorrection oSession, psi, strmLogFile, ShowLogWindows
                  
               Case "Tissue classification"
                  Do_TissueClassification oSession, psi, strmLogFile, ShowLogWindows
               
               Case "Cerebrum labeling"
                  Do_CerebrumLabeling oSession, psi, strmLogFile, ShowLogWindows
               
               Case "Initial inner cortex mask"
                  Do_InitialInnerCortexMask oSession, psi, strmLogFile, ShowLogWindows
                  
               Case "Mask scrubbing"
                  Do_MaskScrubbing oSession, psi, strmLogFile, ShowLogWindows
                  
               Case "Topology correction"
                  Do_TopologyCorrection oSession, psi, strmLogFile, ShowLogWindows
                  
               Case "Wisp filter"
                  Do_WispFilter oSession, psi, strmLogFile, ShowLogWindows
               
               Case "Inner cortical surface"
                  Do_InnerCorticalSurface oSession, psi, strmLogFile, ShowLogWindows
               
               Case "Pial surface generation"
                  Do_PialSurfaceGeneration oSession, psi, strmLogFile, ShowLogWindows
               
               Case "Hemisphere labeling"
                  Do_HemisphereLabeling oSession, psi, strmLogFile, ShowLogWindows
               
               Case "Zip files for SVReg"
                  Do_ZipFilesForSVReg oSession, psi, strmLogFile, ShowLogWindows
                  
               Case "Register and label brain"
                  Do_RegisterAndLabelBrain oSession, psi, strmLogFile, ShowLogWindows
               
               Case "Extract SVREG ROI Data"
                  Do_ExtractSVREG_ROI_Data oSession, psi, strmLogFile, ShowLogWindows
            
               Case Else
                  return_value = False
                  Err.Raise vbObjectError + 512, "DoCorticalSurfaceExtraction", _
                  "Unrecognized value for ProcessingStep: '" & rsProcessingSteps![ProcessingStep] & _
                  "' (ProcessingStepID=" & rsProcessingSteps![ProcessingStepID] & ")"
            End Select
            
            If Not (strmLogFile Is Nothing) Then
               strmLogFile.WriteLine "Completed processing for SessionID=" & SessionID & "; Processing Group=" & psi.ProcessingStepGroupName & "; ProcessingStep='" & rsProcessingSteps![ProcessingStep] & "'"
            End If
            If Not psi.ProcessingComplete Then  'if the step we just tried to execute did not complete, exit the loop
               return_value = ProcessingError
               Exit Do
            End If
         End If
      End If
      rsProcessingSteps.MoveNext
   Loop
   
   If return_value = Unknown Then
      return_value = IIf(DidSomeProcessing, eProcessingStatus.Completed, eProcessingStatus.NothingToDo)
   End If
   
   rsProcessingSteps.Close

DoCorticalSurfaceExtraction_Exit:
   If Not (strmLogFile Is Nothing) Then
      strmLogFile.Close
   End If
   DoCorticalSurfaceExtraction = return_value
Exit Function

DoCorticalSurfaceExtraction_Err:
   If Not (strmLogFile Is Nothing) Then
      strmLogFile.Close
   End If
   Dim strErrorMessage As String
   strErrorMessage = "Processing error: " & Err.Description
   If Not (rsProcessingSteps Is Nothing) Then
      If rsProcessingSteps.State = 1 Then
         If Not (rsProcessingSteps.EOF Or rsProcessingSteps.BOF) Then
            strErrorMessage = "Error while processing for ProcessingStep '" & rsProcessingSteps![ProcessingStep] & _
                  "' (ProcessingStepID=" & rsProcessingSteps![ProcessingStepID] & ")" & vbCrLf & _
                  strErrorMessage
         End If
         rsProcessingSteps.Close
      End If
   End If
   
   Err.Raise vbObjectError + 512, "DoCorticalSurfaceExtraction", strErrorMessage
   
End Function

Private Sub Do_CopyAnatomicalNii(oSession As clsSession, psi As clsProcessingStepInfo, strmLogFile As Scripting.TextStream, ShowLogWindows As Boolean)
   psi.StartProcessing_Now

'
   Dim strAnatomicalImageRenamePattern As String, strAnatomicalImagePattern As String
   strAnatomicalImagePattern = GetSettingValue(SettingName:="Anatomical Scan Filename pattern", SessionID:=oSession.SessionID)
   strAnatomicalImageRenamePattern = GetSettingValue(SettingName:="Brainsuite rename anatomical image pattern", SessionID:=oSession.SessionID)
   Dim regex As New VBScript_RegExp_55.RegExp
   regex.Pattern = strAnatomicalImagePattern
'
'   Dim fil As Scripting.File
'   Dim fso As New Scripting.FileSystemObject
'   Dim AnatomicalImages_Count As Integer
'   Dim filAnatomicalImage As Scripting.File
'   'first confirm there is only one anatomical image
'   AnatomicalImages_Count = 0
'   For Each fil In fso.GetFolder(oSession.SessionPath_Nii).Files
'      If regex.test(fil.Name) Then
'         AnatomicalImages_Count = AnatomicalImages_Count + 1
'         Set filAnatomicalImage = fil
'      End If
'   Next
'
   Dim strAnatomicalImage As String
   Dim filAnatomicalImage As Scripting.File
   Dim fso As New Scripting.FileSystemObject

   strAnatomicalImage = modBasicProcessing.DesignatedAnatomicalImageFilepath(oSession.SessionID)

   If strAnatomicalImage = "" Then
      Err.Raise vbObjectError + 512, "CopyAnatomicalImage", "Failed to find one designated MPRAGE anatomical image."
   Else
      Set filAnatomicalImage = fso.GetFile(strAnatomicalImage)
      Dim strImageFilename_Rename As String
      strImageFilename_Rename = regex.Replace(filAnatomicalImage.Name, strAnatomicalImageRenamePattern)
      fso.CopyFile filAnatomicalImage.Path, oSession.SessionPath_Brainsuite & "\" & strImageFilename_Rename
   End If


   psi.ResultValue = strImageFilename_Rename
   psi.StepOutput_Add "Structural Image", strImageFilename_Rename
   
   psi.ResultComment = "Copied """ & filAnatomicalImage.Path & """ to """ & oSession.SessionPath_Brainsuite & "\" & strImageFilename_Rename & """"
   psi.Save_CompleteNow
   If Not (strmLogFile Is Nothing) Then strmLogFile.WriteLine psi.ResultComment
   
End Sub


Private Sub Do_TPM_for_Brainsuite(oSession As clsSession, psi As clsProcessingStepInfo, strmLogFile As Scripting.TextStream, ShowLogWindows As Boolean)
   'When using the new Do_CreateBrainMask, it is necessary to have TPM computed.  If doing ASL processing, the TPMs are already available as a result of
   ' ASL processing.  But if not doing ASL, the TPM can be computed explicitly using this code.  This produces a subfolder in the Brainsuite folder for
   ' the TPM files.   TF 15 Aug 2018
   
      
   Const MethodName As String = "Do_TPM_for_Brainsuite"
   Debug.Print ModuleName & "." & MethodName & " for SessionID=" & oSession.SessionID
   
   psi.StartProcessing_Now

   Const Commandline_base As String = "Compute_TPMs('{AnatomicalImageFilename}', '{LogFilename}');"
   Dim strCommandLine As String
   Dim strLogFilename As String
   Dim strMatlabResponse As String
   Dim fn As New clsFilename
   Dim strRegExPattern_Success As String
   strRegExPattern_Success = "For file '.*', completed segmentation, produced the class images for tissues 1-6:"
   
   
   If Not psi.DependenciesMet Then
      Err.Raise vbObjectError + 512, ModuleName & "." & MethodName, "Failed to find a completed pre-requisite processing step '" & psi.ProcessingStepName_Dependency & "'"
   Else
      
      'create a subfolder, and copy the MPRAGE image there
      modUtility.CreatePath oSession.SessionPath_Brainsuite & "\TPM"
      Dim psiAnatomical As clsProcessingStepInfo
      Set psiAnatomical = Get_Anatomical_PSI(oSession, psi)
      
      Dim fso As New Scripting.FileSystemObject
      Dim strAnatomicalImageFilename As String
      Dim strAnatomicalImageFilePath_Original As String
      Dim strAnatomicalImageFilePath_TPM As String
      
      strAnatomicalImageFilename = psiAnatomical.StepOutout_GetSpecific("Structural Image").OutputFilename
      strAnatomicalImageFilePath_Original = oSession.SessionPath_Brainsuite & "\" & strAnatomicalImageFilename
      strAnatomicalImageFilePath_TPM = oSession.SessionPath_Brainsuite & "\TPM\" & strAnatomicalImageFilename
      fso.CopyFile strAnatomicalImageFilePath_Original, strAnatomicalImageFilePath_TPM, True
      
      'start up Matlab, set working directory
      If mobjMatlab Is Nothing Then
         Set mobjMatlab = New clsMatLab
      End If
      psi.ResultValue = ""
      
      Dim strWorkingDirectory As String
      strWorkingDirectory = GetSettingValue("MRI Matlab Tools Folder", ErrorIfNotFound:=True)
      strCommandLine = "cd '" & strWorkingDirectory & "'"
      strMatlabResponse = mobjMatlab.Execute(strCommandLine)
      
      If strMatlabResponse <> "" Then
         Err.Raise vbObjectError + 512, ModuleName & "." & MethodName, "Failed to set MatLab current directory, using command: " & strCommandLine
      End If
      
      
      strLogFilename = oSession.SessionPath_Brainsuite & "\TPM\TPM_" & Format(Now, "yyyymmdd_HHMMSS") & "_Log.txt"
      
      strCommandLine = Commandline_base
      strCommandLine = Replace(strCommandLine, "{AnatomicalImageFilename}", strAnatomicalImageFilePath_TPM)
      strCommandLine = Replace(strCommandLine, "{LogFilename}", strLogFilename)
      
      Dim strm As Scripting.TextStream
      Set strm = fso.OpenTextFile(strLogFilename, ForWriting, True)
      strm.WriteLine "Start time: " & FormatDateTime(Now, vbGeneralDate)
      If strWorkingDirectory <> "" Then strm.WriteLine "Set working directory to: " & strWorkingDirectory
      strm.WriteLine "Matlab command line being executed:"
      strm.WriteLine strCommandLine
      strm.WriteLine "------------------"
      strm.Close
      If ShowLogWindows Then modMRI_Common.TailLogFile strLogFilename
      
      
      strMatlabResponse = mobjMatlab.Execute(strCommandLine)

      Dim strLogText As String
      strLogText = fso.OpenTextFile(strLogFilename).ReadAll
      Dim AllIsOK  As Boolean
      AllIsOK = (modUtility.RegEx_Test(strLogText, strRegExPattern_Success)) And (Not modUtility.RegEx_Test(strLogText, "\berror\b"))

      If AllIsOK Then
         psi.ResultValue = "processed file: " & strAnatomicalImageFilePath_TPM
         
         psi.StepOutput_Clear
         
         psi.StepOutput_Add "Source Image", strAnatomicalImageFilePath_TPM
      
         Dim outputs() As String, parts() As String
         outputs = modUtility.RegEx_ExtractSubstrings(strLogText, "^  (Tissue index \d, '.*', file: .*)$", IgnoreCase:=False, MatchAll:=True, Multiline:=True)
         Dim match_index As Integer
         For match_index = 0 To UBound(outputs)
            parts = modUtility.RegEx_ExtractSubstrings(outputs(match_index), "^Tissue index (\d), '(.*)', file: (.*)$", IgnoreCase:=False, MatchAll:=True, Multiline:=False)
            psi.StepOutput_Add "TPM", parts(2), CInt(parts(0)), parts(1)
         Next
         psi.Save_CompleteNow
      Else
         psi.ResultValue = Left(strMatlabResponse, 255)
         psi.Save_NotCompleteNow
      End If
      
   End If

   psi.Save
         
End Sub

Private Sub Do_CreateBrainMask(oSession As clsSession, psi As clsProcessingStepInfo, strmLogFile As Scripting.TextStream, ShowLogWindows As Boolean)
   'this was designed to replace the BSE step usually used in BrainSuite.  That algorithm does not work well in many cases.
   'Instead, rely upon the tissue probability maps that are created as part of ASL processing.  Combine the C1 (grey matter) and
   ' C2 (white matter) TPMs to produce a mask.
   'TF 12 Apr 2018
      
      
   'Modified to allow usage of the TPMs created by ASL processing if TPM was not explicitly created by Do_TPM_for_Brainsuite
   ' TF 19 Nov 2019
   
   Const MethodName As String = "Do_CreateBrainMask"
   Debug.Print ModuleName & "." & MethodName & " for SessionID=" & oSession.SessionID
   
   psi.StartProcessing_Now

   Const Commandline_base As String = "BrainMask_FromTPMs('{TPM_BaseFilename}', '{OutputMaskFileName}');"
   Dim strCommandLine As String
   Dim strMatlabResponse As String
   Dim fn As New clsFilename

   Dim psi_TPM As New clsProcessingStepInfo, psiBSInputStep As clsProcessingStepInfo
   
   If Not psi_TPM.LoadSessionProcessingStep(oSession.SessionID, "Cortical surface extraction", "TPM for Brainsuite") Then   'the main dependency set is for "Cort - 2.4. TPM for Brainsuite" -- if that was performed, use that output
      If Not psi_TPM.LoadSessionProcessingStep(oSession.SessionID, "ASL quantitation", "TPM computation") Then
         Err.Raise vbObjectError + 512, ModuleName & "." & MethodName, "Failed to find a completed pre-requisite processing step.  Must complete either 'Cortical surface extraction - TPM for Brainsuite' or 'ASL quantitation - TPM computation'."
      End If
   End If
   
   If Not psi_TPM Is Nothing Then
      If mobjMatlab Is Nothing Then
         Set mobjMatlab = New clsMatLab
      End If
      psi.ResultValue = ""
      
      strCommandLine = "cd '" & GetSettingValue("MRI Matlab Tools Folder", ErrorIfNotFound:=True) & "'"
      strMatlabResponse = mobjMatlab.Execute(strCommandLine)
      
      If strMatlabResponse <> "" Then
         Err.Raise vbObjectError + 512, ModuleName & "." & MethodName, "Failed to set MatLab current directory, using command: " & strCommandLine
      End If
      
      Dim niif As clsNiiFilename
      
      Set psiBSInputStep = New clsProcessingStepInfo
   
      If Not psiBSInputStep.LoadSessionProcessingStep(oSession.SessionID, psi.ProcessingStepGroupName, "Copy anatomical Nii") Then
         Err.Raise vbObjectError + 512, ModuleName & "." & MethodName, "Failed to find a completed processing step: " & psiBSInputStep.ToString_GroupAndStep()
      End If
      
      Set niif = New clsNiiFilename
      niif.Filename_Original = psiBSInputStep.StepOutout_GetSpecific("Structural Image").OutputFilename
      niif.IncludeOriginalSuffix = False
      niif.NewFilename_IsCompressed = True
      niif.FileTitle_SuffixNew = ".mask"
      
      strCommandLine = Commandline_base
      strCommandLine = Replace(strCommandLine, "{TPM_BaseFilename}", psi_TPM.StepOutout_GetSpecific("Source Image").OutputFilename)
      strCommandLine = Replace(strCommandLine, "{OutputMaskFileName}", oSession.SessionPath_Brainsuite & "\" & niif.Filename_New)
      
      strMatlabResponse = mobjMatlab.Execute(strCommandLine)


      If (strMatlabResponse = "") Then
         psi.ResultValue = niif.Filename_New
         psi.StepOutput_Add "mask", niif.Filename_New
         psi.Save_CompleteNow
      Else
         psi.ResultValue = Left(strMatlabResponse, 255)
         psi.Save_NotCompleteNow
      End If
      
   End If

   psi.Save
      
End Sub
Private Sub Do_SkullStripping(oSession As clsSession, psi As clsProcessingStepInfo, strmLogFile As Scripting.TextStream, ShowLogWindows As Boolean)
   '  Command-Line Usage
   '  bse: automatically skull-strips a T1-weighted image.
   '  usage: bse -i input [optional settings]
   '  example: bse -i input_mri.nii.gz -o skull_stripped_mri.nii.gz
   '  Required Settings:
   '  Flags Description
   '  -i <input filename>  input MRI volume
   '  Optional Settings:
   '  Flags Description
   '  -o <output filename> output brain-masked MRI volume
   '  -d <float>  diffusion constant [default: 25]
   '  -n <iterations>   diffusion iterations [default: 3]
   '  -s <edge sigma>   edge detection constant [default: 0.64]
   '  -r <size>   radius of erosion/dilation filter [default: 1]
   '  -p dilate final mask
   '  --trim   trim brainstem
   '  --mask <filename> save smooth brain mask
   '  --adf <filename>  diffusion filter output
   '  --edge <filename> edge map output
   '  --hires <filename>   save detailed brain mask
   '  --cortex <filename>  cortex file
   '  -v <number> verbosity level (0=silent) [default: 1]
   '  --norotate  retain original orientation (default behavior will auto-rotate input NII files to LPI orientation
   '  --timer  show timing
   
   Dim MethodName As String
   Dim CommandDescription As String
   Dim ExecutableName As String, CommandOptions As String
   Dim TakeInputFromStepName As String, OutputFilename_Suffix As String, TakeInputFromStep_OutputType As String
   Dim OutputFile_ExtractFromLog_RegEx As String
   Dim dicReplaceableParams As New Scripting.Dictionary
   Dim OutputFile_Extracted_Expected As String
   
   MethodName = "Do_SkullStripping"
   CommandDescription = "Skull Stripping"
   ExecutableName = "bse"
   CommandOptions = "-i '{input_filename}' -d {diffusion_constant} -n {diffusion_iterations} -s {edge_sigma} -r {erosion_size} -p --trim --mask '{output_filename}'"
   TakeInputFromStepName = "Copy anatomical Nii"
   TakeInputFromStep_OutputType = ""
   OutputFilename_Suffix = ".mask"
   OutputFile_ExtractFromLog_RegEx = "^Wrote mask file (.+?)$"
    
   dicReplaceableParams.Add "{diffusion_constant}", GetSettingValue(SettingName:="BSE Diffusion Constant", SessionID:=oSession.SessionID, ValueIfNotFound:="25")
   dicReplaceableParams.Add "{diffusion_iterations}", GetSettingValue(SettingName:="BSE Diffusion Iterations", SessionID:=oSession.SessionID, ValueIfNotFound:="3")
   dicReplaceableParams.Add "{edge_sigma}", GetSettingValue(SettingName:="BSE Edge Constant", SessionID:=oSession.SessionID, ValueIfNotFound:="0.64")
   dicReplaceableParams.Add "{erosion_size}", GetSettingValue(SettingName:="BSE Erosion Size", SessionID:=oSession.SessionID, ValueIfNotFound:="1")
   
    
   Call m_BSC.Do_BrainsuiteCommandlineProcess(oSession, psi, strmLogFile, ShowLogWindows, _
                                    MethodName, CommandDescription, ExecutableName, CommandOptions, _
                                    TakeInputFromStepName, TakeInputFromStep_OutputType, OutputFilename_Suffix, OutputFile_ExtractFromLog_RegEx, _
                                    dicReplaceableParams, OutputType:="mask")
                                    
End Sub

Private Sub Do_ReviewSkullStrippingMask(oSession As clsSession, psi As clsProcessingStepInfo, strmLogFile As Scripting.TextStream, ShowLogWindows As Boolean)
   'nothing to do here
End Sub
Private Sub Do_SkullAndScalp(oSession As clsSession, psi As clsProcessingStepInfo, strmLogFile As Scripting.TextStream, ShowLogWindows As Boolean)
   '  Command-Line Usage
   '  skullfinder: generates a label file to segment brain, scalp, inner and outer skull
   '  usage: skullfinder -i input -o output -m mask [optional settings]
   '  example: skullfinder -i subj.nii.gz -o subj.skull.label.nii.gz -m subj.mask.nii.gz scalplabel subj.scalp.label.nii.gz
   '  Required Settings:
   '  Flags Description
   '  -i <input filename>  input MRI volume
   '  -o <output filename> output multi-colored label volume segmenting brain, scalp, inner skull & outer skull
   '  -m <mask filename>   input whole brain mask volume
   '  Optional Settings:
   '  Flags Description
   '  -g debug
   '  -v <level>  verbosity [default: 0]
   '  -l <lower threshold> lower threshold for segmentation [default: 0]
   '  -u <upper threshold> upper threshold for segmentation [default: 0]
   '  -s surface_prefix if specified, generate surface files
   '  --bglabel <background_label>  background label value (0-225) [default: 0]
   '  --scalplabel <scalp_label> scalp label value (0-255) [default: 16]
   '  --skulllabel <skull_label> skull label value (0-255) [default: 17]
   '  --spacelabel <space_label> space label value (0-255) [default: 18]
   '  --brainlabel <brain_label> brain label value (0-255) [default: 19]
   '  --finalOpening perform a final opening operation on the scalp mask
   
   Dim MethodName As String
   Dim CommandDescription As String
   Dim ExecutableName As String, CommandOptions As String
   Dim TakeInputFromStepName As String, OutputFilename_Suffix As String, TakeInputFromStep_OutputType As String
   Dim OutputFile_ExtractFromLog_RegEx As String
   Dim dicReplaceableParams As New Scripting.Dictionary
   Dim OutputFile_Extracted_Expected As String
   Dim OutputType As String
   
   MethodName = "Do_SkullAndScalp"
   CommandDescription = "Skull and Scalp Surfaces"
   ExecutableName = "skullfinder"
   CommandOptions = "-i '{input_filename}' -o '{output_filename}' -m '{mask_filename}' -s '{surface_prefix}' -v 1"
   TakeInputFromStepName = "Copy anatomical Nii"
   TakeInputFromStep_OutputType = ""
   OutputFilename_Suffix = ".skull.label"
   OutputFile_ExtractFromLog_RegEx = "^cmd .* -o ""(.+?)"".*$" & vbCrLf & _
                                     "^-*$" & vbCrLf & _
                                     "^Wrote (.+?\.dfs)$" & vbCrLf & _
                                     "^Wrote (.+?\.dfs)$" & vbCrLf & _
                                     "^Wrote (.+?\.dfs)$" & vbCrLf & _
                                     "^Wrote (.+?\.dfs)$"
   
   'Note that unfortunately the 'skullfinder' program does not list the Label file it produces; but it does list the four surfaces that it produces!
   ' Therefore when extracting the filenames, just pull the label filename out of the command line... assume it was produced if the others were.
   OutputFile_Extracted_Expected = "{output_filename}|{surface_prefix}.brain.dfs|{surface_prefix}.inner_skull.dfs|{surface_prefix}.outer_skull.dfs|{surface_prefix}.scalp.dfs"
   OutputType = "label|brain surface|inner skull surface|outer skull surface|scalp surface"
   
   Dim psiBrainMask As New clsProcessingStepInfo
   Set psiBrainMask = Get_BrainMask_Completed_PSI(oSession, psi)
   dicReplaceableParams.Add "{mask_filename}", psiBrainMask.ResultValue
   
   Dim niif As New clsNiiFilename
   niif.Filename_Original = psiBrainMask.ResultValue
   dicReplaceableParams.Add "{surface_prefix}", niif.FileTitle_Base
   
    
   Call m_BSC.Do_BrainsuiteCommandlineProcess(oSession, psi, strmLogFile, ShowLogWindows, _
                                    MethodName, CommandDescription, ExecutableName, CommandOptions, _
                                    TakeInputFromStepName, TakeInputFromStep_OutputType, OutputFilename_Suffix, OutputFile_ExtractFromLog_RegEx, _
                                    dicReplaceableParams, OutputFile_Extracted_Expected:=OutputFile_Extracted_Expected, _
                                    OutputType:=OutputType)
      
End Sub
Private Sub Do_NonUniformityCorrection(oSession As clsSession, psi As clsProcessingStepInfo, strmLogFile As Scripting.TextStream, ShowLogWindows As Boolean)
'  Command-Line Usage
'  bfc: corrects gain variation in T1-weighted MRI.
'  usage: bfc -i input -o output [optional settings]
'  example: bfc -i input_mri.nii.gz -o output_mri.bfc.nii.gz -L 0.5 -U 1.5
'  Required Settings:
'  Flags Description
'  -i <input filename>  input skull-stripped MRI volume
'  -o <output filename> output bias-corrected MRI volume
'  Optional Settings:
'  Flags Description
'  -m <mask filename>   mask file
'  --bias <output filename>   save bias field estimate
'  --maskedbias <output filename>   save bias field estimate (masked)
'  -r <radius> histogram radius (voxels) [default: 12]
'  -s <spacing>   bias sample spacing (voxels) [default: 16]
'  -c <spacing>   control point spacing (voxels) [default: 64]
'  -w <strength>  spline stiffness weighting parameter [default: 0.0001]
'  --ellipse   use ellipsoid for ROI histogram
'  --block  use block for ROI histogram
'  --iterate   iterative mode (overrides -r, -s, -c, -w settings)
'  --schedule <schedule_file> list of parameters in a text file
'  --biasprefix <prefix>   save iterative bias field estimates as <prefix>.n.field.nii.gz
'  --prefix <prefix> save iterative corrected images as <prefix>.n.bfc.nii.gz
'  --extrapolate  apply correction field to entire volume
'  -L <lower>  minimum allowed bias value [default: 0.5]
'  -U <upper>  maximum allowed bias value [default: 1.5]
'  --low small bias model [0.95,1.05]
'  --medium medium bias model [0.90,1.10]
'  --high   high bias model [0.80,1.20]
'  --analyze   generate intermediate files in Analyze format
'  --nifti  generate intermediate files in Nifti format
'  --analyzegz generate intermediate files in gzipped Analyze format
'  --niftigz   generate intermediate files in gzipped Nifti format
'  --eps <epsilon>   convergence threshold [default: 1e-06]
'  --beps <bias_epsilon>   bias estimate convergence threshold (values > 0.1 disable) [default: 0]
'  -v <number> verbosity level (0=silent) [default: 1]
'  --timer  display timing information

   Dim MethodName As String
   Dim CommandDescription As String
   Dim ExecutableName As String, CommandOptions As String
   Dim TakeInputFromStepName As String, OutputFilename_Suffix As String, TakeInputFromStep_OutputType As String
   Dim OutputFile_ExtractFromLog_RegEx As String
   Dim dicReplaceableParams As New Scripting.Dictionary
   Dim OutputFile_Extracted_Expected As String
   
   MethodName = "Do_NonUniformityCorrection"
   CommandDescription = "Non Uniformity Correction"
   ExecutableName = "bfc"
   CommandOptions = "-i '{input_filename}' -o '{output_filename}' -m '{mask_filename}' -v 1"
   TakeInputFromStepName = "Copy anatomical Nii"
   TakeInputFromStep_OutputType = ""
   OutputFilename_Suffix = ".bfc"
   OutputFile_ExtractFromLog_RegEx = "^Wrote corrected image (.+?)$"
    
   Dim psiBrainMask As clsProcessingStepInfo
   Set psiBrainMask = Get_BrainMask_Completed_PSI(oSession, psi)
   
   dicReplaceableParams.Add "{mask_filename}", psiBrainMask.ResultValue
    
   Call m_BSC.Do_BrainsuiteCommandlineProcess(oSession, psi, strmLogFile, ShowLogWindows, _
                                    MethodName, CommandDescription, ExecutableName, CommandOptions, _
                                    TakeInputFromStepName, TakeInputFromStep_OutputType, OutputFilename_Suffix, OutputFile_ExtractFromLog_RegEx, _
                                    dicReplaceableParams, OutputType:="bfc")

End Sub
Private Sub Do_TissueClassification(oSession As clsSession, psi As clsProcessingStepInfo, strmLogFile As Scripting.TextStream, ShowLogWindows As Boolean)
'  Command-Line Usage
'  pvc: performs voxel-wise tissue classification on T1-weighted MRI. Image should be skull-stripped and bias-corrected before tissue classification.
'  usage: pvc -i input [optional settings]
'  example: pvc -i mri.nii.gz -o mri.pvc.label.nii.gz -f mri.frac.nii.gz
'  Required Settings:
'  Flags Description
'  -i <input MRI> MRI file
'  Optional Settings:
'  Flags Description
'  -m <mask file> brain mask file
'  -o <label file>   output label file
'  -f <fraction file>   output tissue fraction file
'  -l <lambda> spatial prior strength [default: 0.1]
'  -v <level>  verbosity level (0 = silent) [default: 1]
'  --init <initfile> initialization file
'  -3 use a three-class (CSF=0,GM=1,WM=2) labeling
'  --timer  time processing
'  Notes:
'  Input MRI should be skull-stripped or a mask should be specified.
'  Output tissue label volume is an 8-bit label file using the values:
'  0 (CSF), 1 (GM), 2 (WM), 3 (GM/CSF), 4 (GM/WM), 5 (CSF/Other), 8 (Background)
'  Tissue fractions are saved as a 32-bit floating point volume:
'  0 (BKG) 1 (CSF) <-> 2 (GM) <-> 3 (WM)
   
   
   Dim MethodName As String
   Dim CommandDescription As String
   Dim ExecutableName As String, CommandOptions As String
   Dim TakeInputFromStepName As String, OutputFilename_Suffix As String, TakeInputFromStep_OutputType As String
   Dim OutputFile_ExtractFromLog_RegEx As String
   Dim dicReplaceableParams As New Scripting.Dictionary
   Dim OutputFile_Extracted_Expected As String
   Dim OutputType As String
   
   MethodName = "Do_TissueClassification"
   CommandDescription = "Tissue Classification"
   ExecutableName = "pvc"
   CommandOptions = "-i '{input_filename}' -o '{output_filename}' -f '{output_filename2}' -v 1"
   TakeInputFromStepName = "Non-uniformity correction"
   TakeInputFromStep_OutputType = ""
   OutputFilename_Suffix = ".pvc.label|.pvc.frac"  'specify two output filenames (first for label, second for fractional)
   OutputFile_ExtractFromLog_RegEx = "^Wrote tissue label file (.+?)$" & vbCrLf & "^Wrote tissue fraction file (.+?)$"
   OutputFile_Extracted_Expected = "{output_filename}|{output_filename2}"
   OutputType = "label|fraction"
   
   Call m_BSC.Do_BrainsuiteCommandlineProcess(oSession, psi, strmLogFile, ShowLogWindows, _
                                    MethodName, CommandDescription, ExecutableName, CommandOptions, _
                                    TakeInputFromStepName, TakeInputFromStep_OutputType, OutputFilename_Suffix, OutputFile_ExtractFromLog_RegEx, _
                                    dicReplaceableParams, OutputFile_Extracted_Expected, _
                                    OutputType:=OutputType)

End Sub
Private Sub Do_CerebrumLabeling(oSession As clsSession, psi As clsProcessingStepInfo, strmLogFile As Scripting.TextStream, ShowLogWindows As Boolean)
'  Command-Line Usage
'  cerebro: performs automated labeling of cerebellum and cerebrum in T1 MRI. Input MRI should be skull-stripped or a brain-only mask should be provided.
'  usage: cerebro -i input atlas atlas atlaslabels label [optional settings]
'  example: cerebro -i input_mri.nii.gz atlas brain_atlas.img atlaslabels brain_atlas.label.img
'  Required Settings:
'  Flags Description
'  -i <input MRI> input 3D MRI volume
'  --atlas <atlas MRI file>   atlas MRI volume (ANALYZE format)
'  --atlaslabels <label file> atlas labeling volume (ANALYZE format)
'  Optional Settings:
'  Flags Description
'  -m <mask file> brain mask file*
'  -o <output mask>  output cerebrum mask volume*
'  -l <label file>   output labeled hemisphere/cerebrum volume
'  -c <cost function>   0,1,2 [default: 1]
'  --centroids use centroids of data to initialize position
'  --air <output air file> save affine transform to file
'  --warp <output warp file>  save warp transform to file
'  -v <level>  verbosity level (0=silent) [default: 1]
'  --linconv <value> linear convergence [default: 0.1]
'  --warplevel <order>  warp order (2,3,4,5,6,7,8) [default: 5]
'  --warpconv <warpconv>   warp convergence [default: 100]
'  --keep   don't remove temporary files
'  --tempdir <directory>   specify directory to use for temporary files
'  --tempdirbase <directory>  create a temporary directory within this directory
   
   Dim MethodName As String
   Dim CommandDescription As String
   Dim ExecutableName As String, CommandOptions As String
   Dim TakeInputFromStepName As String, OutputFilename_Suffix As String, TakeInputFromStep_OutputType As String
   Dim OutputFile_ExtractFromLog_RegEx As String
   Dim dicReplaceableParams As New Scripting.Dictionary
   Dim OutputFile_Extracted_Expected As String
   Dim OutputType As String
   
   MethodName = "Do_CerebrumLabeling"
   CommandDescription = "Cerebrum Labeling"
   ExecutableName = "cerebro"
   CommandOptions = "-i '{input_filename}' --atlas '{BrainsuiteFolder}\{atlas}' --atlaslabels '{BrainsuiteFolder}\{atlaslabels}' -v 2 -c 2 -o '{output_filename}' -l '{output_filename2}' -m '{mask_filename}'   --air '{air filename}' --warp '{output warp file}'"
   TakeInputFromStepName = "Non-uniformity correction"
   TakeInputFromStep_OutputType = ""
   OutputFilename_Suffix = ".cerebrum.mask|.hemi.label"  'specify two output filenames (first for mask, second for labels)
   OutputFile_ExtractFromLog_RegEx = "^Wrote cerebrum mask (.+?)$" & vbCrLf & "^Wrote hemisphere label file (.+?)$"
   OutputFile_Extracted_Expected = "{output_filename}|{output_filename2}"
   OutputType = "mask|label"
   
   Dim psiAnatomical As clsProcessingStepInfo
   Set psiAnatomical = Get_Anatomical_PSI(oSession, psi)
   Dim niif As New clsNiiFilename
   niif.Filename_Original = psiAnatomical.ResultValue
   
   Dim psiBrainMask As clsProcessingStepInfo
   Set psiBrainMask = Get_BrainMask_Completed_PSI(oSession, psi)
   
   dicReplaceableParams.Add "{mask_filename}", psiBrainMask.ResultValue
   dicReplaceableParams.Add "{atlas}", GetSettingValue(SettingName:="Cerebrum atlas file", SessionID:=oSession.SessionID, ValueIfNotFound:="atlas\brainsuite.icbm452.lpi.v08a.img")
   dicReplaceableParams.Add "{atlaslabels}", GetSettingValue(SettingName:="Cerebrum labels file", SessionID:=oSession.SessionID, ValueIfNotFound:="atlas\brainsuite.icbm452.v15a.label.img")
   dicReplaceableParams.Add "{air filename}", niif.FileTitle_Base & ".air"
   dicReplaceableParams.Add "{output warp file}", niif.FileTitle_Base & ".warp"
   
   Call m_BSC.Do_BrainsuiteCommandlineProcess(oSession, psi, strmLogFile, ShowLogWindows, _
                                    MethodName, CommandDescription, ExecutableName, CommandOptions, _
                                    TakeInputFromStepName, TakeInputFromStep_OutputType, OutputFilename_Suffix, OutputFile_ExtractFromLog_RegEx, _
                                    dicReplaceableParams, OutputFile_Extracted_Expected, OutputType:=OutputType)


End Sub
Private Sub Do_InitialInnerCortexMask(oSession As clsSession, psi As clsProcessingStepInfo, strmLogFile As Scripting.TextStream, ShowLogWindows As Boolean)
'  Command-Line Usage
'  cortex: produces a cortical mask using tissue fraction estimates and a co-registered cerebellum/hemisphere mask.
'  usage: cortex -h hemi_label -o mask -f frac [optional settings]
'  example: cortex -h hemi.label.nii.gz -o mask.nii.gz -f frac.nii.gz -a
'  Required Settings:
'  Flags Description
'  -h <label file>   hemisphere / lobe label volume
'  -o <mask file> output structure mask
'  -f <fraction file>   tissue fraction file (32-bit float)
'  optional settings:
'  Flags Description
'  -p <percentage>   tissue fraction threshold (percentage) [default: 50]
'  -w compute WM/GM boundary
'  -g compute GM/CSF boundary
'  -a include all subcortical areas in WM mask
'  -v <verbosity> verbosity level [default: 1]
'  --timer  timing function

   Dim MethodName As String
   Dim CommandDescription As String
   Dim ExecutableName As String, CommandOptions As String
   Dim TakeInputFromStepName As String, OutputFilename_Suffix As String, TakeInputFromStep_OutputType As String
   Dim OutputFile_ExtractFromLog_RegEx As String
   Dim dicReplaceableParams As New Scripting.Dictionary
   Dim OutputFile_Extracted_Expected As String
   
   MethodName = "Do_InitialInnerCortexMask"
   CommandDescription = "Inner Cortex Mask"
   ExecutableName = "cortex"
   CommandOptions = "-v 2 -f '{pvc_frac}' -h '{input_filename}' -o '{output_filename}' -a -w -p 50"
 '  s = "-f %basename%.pvc.frac.%EXT% -h %basename%.hemi.label.%EXT% -o %basename%.init.cortex.mask.%EXT% -a -w -p 50"
   
   TakeInputFromStepName = "Cerebrum labeling"
   TakeInputFromStep_OutputType = "label"
   OutputFilename_Suffix = ".init.cortex.mask"
   OutputFile_ExtractFromLog_RegEx = "^Wrote cortex mask file (.+?)$"
   OutputFile_Extracted_Expected = "{output_filename}"
   
   Dim psiTissueClassification As New clsProcessingStepInfo
   With psiTissueClassification
      If Not .LoadSessionProcessingStep(oSession.SessionID, psi.ProcessingStepGroupName, "Tissue classification") Then
         Err.Raise vbObjectError + 512, ModuleName & "." & MethodName, "Failed to find a completed processing step: " & .ToString_GroupAndStep()
      End If
   End With
   dicReplaceableParams.Add "{pvc_frac}", Split(psiTissueClassification.ResultValue, "|")(1)
  
   Call m_BSC.Do_BrainsuiteCommandlineProcess(oSession, psi, strmLogFile, ShowLogWindows, _
                                    MethodName, CommandDescription, ExecutableName, CommandOptions, _
                                    TakeInputFromStepName, TakeInputFromStep_OutputType, OutputFilename_Suffix, OutputFile_ExtractFromLog_RegEx, _
                                    dicReplaceableParams, OutputFile_Extracted_Expected, OutputType:="mask")

End Sub
Private Sub Do_MaskScrubbing(oSession As clsSession, psi As clsProcessingStepInfo, strmLogFile As Scripting.TextStream, ShowLogWindows As Boolean)
'  Command-Line Usage
'  scrubmask: filters binary masks to trim loosely connected voxels that may result from segmentation errors and produce bumps on tessellated surfaces.
'  usage: scrubmask -i input -o output [optional settings]
'  example: scrubmask -i input_mask.nii.gz -o output_mask.nii.gz -b 1
'  Required Settings:
'  Flags Description
'  -i <mask file> input structure mask file
'  -o <mask file> output structure mask file
'  Optional Settings:
'  Flags Description
'  -b <threshold> background fill threshold [default: 1]
'  -f <threshold> foreground trim threshold [default: 1]
'  -n <iterations>   number of iterations [default: 10]
'  -v <level>  verbosity (0=silent) [default: 1]
'  --timer  timing function
   Dim MethodName As String
   Dim CommandDescription As String
   Dim ExecutableName As String, CommandOptions As String
   Dim TakeInputFromStepName As String, OutputFilename_Suffix As String, TakeInputFromStep_OutputType As String
   Dim OutputFile_ExtractFromLog_RegEx As String
   Dim dicReplaceableParams As New Scripting.Dictionary
   Dim OutputFile_Extracted_Expected As String
   
   MethodName = "Do_MaskScrubbing"
   CommandDescription = "Mask Scrubbing"
   ExecutableName = "scrubmask"
   CommandOptions = "-v 2 -i '{input_filename}' -o '{output_filename}' -f 0 -b 2"
'%BrainSuiteBinDir%scrubmask %VERBOSE% -i %basename%.init.cortex.mask.%EXT% -o %basename%.cortex.scrubbed.mask.%EXT% -f 0 -b 2

   TakeInputFromStepName = "Initial inner cortex mask"
   TakeInputFromStep_OutputType = ""
   OutputFilename_Suffix = ".cortex.scrubbed.mask"
   OutputFile_ExtractFromLog_RegEx = "^Wrote output mask (.+?)$"
   OutputFile_Extracted_Expected = "{output_filename}"
   
   Call m_BSC.Do_BrainsuiteCommandlineProcess(oSession, psi, strmLogFile, ShowLogWindows, _
                                    MethodName, CommandDescription, ExecutableName, CommandOptions, _
                                    TakeInputFromStepName, TakeInputFromStep_OutputType, OutputFilename_Suffix, OutputFile_ExtractFromLog_RegEx, _
                                    dicReplaceableParams, OutputFile_Extracted_Expected, OutputType:="mask")


End Sub
Private Sub Do_TopologyCorrection(oSession As clsSession, psi As clsProcessingStepInfo, strmLogFile As Scripting.TextStream, ShowLogWindows As Boolean)
'  Command-Line Usage
'  tca: topological correction algorithm that removes topological handles from a binary object. Algorithm created by David W Shattuck and Richard M Leahy
'  usage: tca -i input -o output [optional settings]
'  example: tca -i input_mask.nii.gz -o output_mask.nii.gz -m 200 -n 1
'  Required Settings:
'  Flags Description
'  -i <input filename>  input mask volume
'  -o <output filename> output mask volume
'  Optional Settings:
'  Flags Description
'  -m <n>   maximum correction size [default: 200]
'  -n <n>   minimum correction size [default: 1]
'  --delta <delta>   foreground delta [default: 0]
'  -v <level>  verbosity (0 = quiet) [default: 1]
'  --timer  timing function

   Dim MethodName As String
   Dim CommandDescription As String
   Dim ExecutableName As String, CommandOptions As String
   Dim TakeInputFromStepName As String, OutputFilename_Suffix As String, TakeInputFromStep_OutputType As String
   Dim OutputFile_ExtractFromLog_RegEx As String
   Dim dicReplaceableParams As New Scripting.Dictionary
   Dim OutputFile_Extracted_Expected As String
   
   MethodName = "Do_TopologyCorrection"
   CommandDescription = "Topology Correction"
   ExecutableName = "tca"
   CommandOptions = "-v 2 -i '{input_filename}' -o '{output_filename}' -m 2500 --delta 20"
'%BrainSuiteBinDir%tca %VERBOSE% -i %basename%.cortex.scrubbed.mask.%EXT% -o %basename%.cortex.tca.mask.%EXT% -m 2500  --delta 20 %TCASETTINGS%

   TakeInputFromStepName = "Mask scrubbing"
   TakeInputFromStep_OutputType = ""
   OutputFilename_Suffix = ".cortex.tca.mask"
   OutputFile_ExtractFromLog_RegEx = "^Wrote topologically corrected mask (.+?)$"
   OutputFile_Extracted_Expected = "{output_filename}"
   
   Call m_BSC.Do_BrainsuiteCommandlineProcess(oSession, psi, strmLogFile, ShowLogWindows, _
                                    MethodName, CommandDescription, ExecutableName, CommandOptions, _
                                    TakeInputFromStepName, TakeInputFromStep_OutputType, OutputFilename_Suffix, OutputFile_ExtractFromLog_RegEx, _
                                    dicReplaceableParams, OutputFile_Extracted_Expected, OutputType:="mask")


End Sub
Private Sub Do_WispFilter(oSession As clsSession, psi As clsProcessingStepInfo, strmLogFile As Scripting.TextStream, ShowLogWindows As Boolean)
'  Command-Line Usage
'  dewisp: removes wispy tendril structures from cortex model binary masks.
'  usage: dewisp -i input -o output [optional settings]
'  example: dewisp -i input_mask.nii.gz -o output_mask.nii.gz -t 15
'  Required Settings:
'  Flags Description
'  -i <file>   input file
'  -o <file>   output file
'  Optional Settings:
'  Flags Description
'  -g debug
'  -v <level>  verbosity [default: 0]
'  -t <threshold> size threshold [default: 15]
'  -n <iterations>   maximum number of iterations [default: 10]
'  --timer  time processing
   Dim MethodName As String
   Dim CommandDescription As String
   Dim ExecutableName As String, CommandOptions As String
   Dim TakeInputFromStepName As String, OutputFilename_Suffix As String, TakeInputFromStep_OutputType As String
   Dim OutputFile_ExtractFromLog_RegEx As String
   Dim dicReplaceableParams As New Scripting.Dictionary
   Dim OutputFile_Extracted_Expected As String
   
   MethodName = "Do_WispFilter"
   CommandDescription = "Wisp Filter"
   ExecutableName = "dewisp"
   CommandOptions = "-v 2 -i '{input_filename}' -o '{output_filename}'"
'%BrainSuiteBinDir%dewisp %VERBOSE% -i %basename%.cortex.tca.mask.%EXT% -o %basename%.cortex.dewisp.mask.%EXT% %DEWISPSETTINGS%

   TakeInputFromStepName = "Topology correction"
   TakeInputFromStep_OutputType = ""
   OutputFilename_Suffix = ".cortex.dewisp.mask"
   OutputFile_ExtractFromLog_RegEx = "^wrote (.+?)$"
   OutputFile_Extracted_Expected = "{output_filename}"
   
   Call m_BSC.Do_BrainsuiteCommandlineProcess(oSession, psi, strmLogFile, ShowLogWindows, _
                                    MethodName, CommandDescription, ExecutableName, CommandOptions, _
                                    TakeInputFromStepName, TakeInputFromStep_OutputType, OutputFilename_Suffix, OutputFile_ExtractFromLog_RegEx, _
                                    dicReplaceableParams, OutputFile_Extracted_Expected, OutputType:="mask")

End Sub
Private Sub Do_InnerCorticalSurface(oSession As clsSession, psi As clsProcessingStepInfo, strmLogFile As Scripting.TextStream, ShowLogWindows As Boolean)
'  Command-Line Usage
'  dfs: generates mesh surfaces using an isosurface algorithm.
'  usage: dfs -i input -o output [optional settings]
'  example: dfs -i input_mri.nii.gz -o surface.dfs
'  Required Settings:
'  Flags Description
'  -i <input volume> input 3D volume
'  -o <output surface>  output surface mesh file
'  Optional Settings:
'  Flags Description
'  -c <image volume> shade surface model with data from image volume; a set of vertex colors is generated within the file
'  -n <value>  number of smoothing iterations [default: 10]
'  -a <value>  smoothing constant [default: 0.5]
'  -w <value>  curvature weighting [default: 0]
'  -f <value>  scaling percentile [default: 0.999]
'  -nz   tessellate non-zero voxels
'  -gt <threshold>   tessellate voxels greater than <threshold>
'  -lt <threshold>   tessellate voxels less than <threshold>
'  -eq <value> tessellate voxels equal to <value>
'  -z zero-pad volume (avoids clipping at edges)
'  --nonormals do not compute vertex normals
'  --postsmooth   smooth vertices after coloring
'  -v <level>  verbosity (0 = quiet) [default: 1]
'  --timer  timing function

   Dim MethodName As String
   Dim CommandDescription As String
   Dim ExecutableName As String, CommandOptions As String
   Dim TakeInputFromStepName As String, OutputFilename_Suffix As String, TakeInputFromStep_OutputType As String
   Dim OutputFile_ExtractFromLog_RegEx As String
   Dim dicReplaceableParams As New Scripting.Dictionary
   Dim OutputFile_Extracted_Expected As String
   Dim OutputFilename_Extension As String
   
   MethodName = "Do_InnerCorticalSurface"
   CommandDescription = "Inner Cortical Surface"
   ExecutableName = "dfs"
   CommandOptions = "-v 2 -i '{input_filename}' -o '{output_filename}' -n 10 -a 0.5 -w 5.0"
'%BrainSuiteBinDir%dfs %VERBOSE% -i %basename%.cortex.dewisp.mask.%EXT% -o %basename%.inner.cortex.dfs -n 10 -a 0.5 -w 5.0

   TakeInputFromStepName = "Wisp filter"
   TakeInputFromStep_OutputType = ""
   OutputFilename_Suffix = ".inner.cortex"
   OutputFilename_Extension = ".dfs"
   OutputFile_ExtractFromLog_RegEx = "^wrote surface file (.+?)$"
   OutputFile_Extracted_Expected = "{output_filename}"
   
   Call m_BSC.Do_BrainsuiteCommandlineProcess(oSession, psi, strmLogFile, ShowLogWindows, _
                                    MethodName, CommandDescription, ExecutableName, CommandOptions, _
                                    TakeInputFromStepName, TakeInputFromStep_OutputType, OutputFilename_Suffix, OutputFile_ExtractFromLog_RegEx, _
                                    dicReplaceableParams, OutputFile_Extracted_Expected, OutputFilename_Extension, OutputType:="surface")


End Sub
Private Sub Do_PialSurfaceGeneration(oSession As clsSession, psi As clsProcessingStepInfo, strmLogFile As Scripting.TextStream, ShowLogWindows As Boolean)
'  Command-Line Usage
'  pialmesh: computes a pial surface model using an inner GM/WM mesh and a tissue fraction map.
'  usage: pialmesh -i input -o output -f fraction_file -m mask [optional settings]
'  example: pialmesh -i input_mesh.dfs -o output_mesh.dfs -f frac_file.nii.gz -m mask_file.nii.gz
'  Required Settings:
'  Flags Description
'  -i <file>   input mesh file
'  -o <file>   output mesh file
'  -f <fraction file>   floating point (32) tissue fraction image
'  -m <mask file> restrict growth to mask file region
'  Optional Settings:
'  Flags Description
'  -g debug
'  -v <level>  verbosity [default: 0]
'  -n <n>   number of iterations [default: 10]
'  -r <radius> search radius [default: 2]
'  -s <step size> step size [default: 0.1]
'  --max <thickness> maximum allowed tissue thickness [default: 10]
'  -t <threshold> tissue threshold [default: 1.1]
'  --interval <n> output interval [default: 0]
'  --prefix <prefix> prefix for exporting surfaces if interval is set
'  --smooth <smoothing constant> apply Laplacian smoothing [default: 0.1]
'  --timer  show timing
'  --norm   recompute normals at each iteration
'  --nc <normal_constant>  strength of normal smoother. [default: 0]
'  --tc <tangential_constant> strength of tangential smoother. [default: 0]
   Dim MethodName As String
   Dim CommandDescription As String
   Dim ExecutableName As String, CommandOptions As String
   Dim TakeInputFromStepName As String, OutputFilename_Suffix As String, TakeInputFromStep_OutputType As String
   Dim OutputFile_ExtractFromLog_RegEx As String
   Dim dicReplaceableParams As New Scripting.Dictionary
   Dim OutputFile_Extracted_Expected As String
   Dim OutputFilename_Extension As String
   
   MethodName = "Do_PialSurfaceGeneration"
   CommandDescription = "Pial Surface Generation"
   ExecutableName = "pialmesh"
   CommandOptions = "-v 2 -f '{input_filename}' -i '{inner_surface}' -m '{mask_filename}' -o '{output_filename}'  -n 100 -r 1 -s 0.40 -t 1.05 --max 20 --smooth 0.025 --interval 10 --nc 0.2 "
'%BrainSuiteBinDir%pialmesh %VERBOSE% -f %basename%.pvc.frac.%EXT% -i %basename%.inner.cortex.dfs -m %basename%.cerebrum.mask.%EXT% -o %basename%.pial.cortex.dfs ^
'   -n 100 -r 1 -s 0.40 -t 1.05 --max 20 --smooth 0.025 --interval 10 --nc 0.2

   TakeInputFromStepName = "Tissue classification"
   TakeInputFromStep_OutputType = "fraction"
   OutputFilename_Suffix = ".pial.cortex"
   OutputFilename_Extension = ".dfs"
   OutputFile_ExtractFromLog_RegEx = "^99 : (iterating)\.$"
   OutputFile_Extracted_Expected = "{output_filename}"
   
   
   Dim psiInnerCortex As New clsProcessingStepInfo
   With psiInnerCortex
      If Not .LoadSessionProcessingStep(oSession.SessionID, psi.ProcessingStepGroupName, "Inner cortical surface") Then
         Err.Raise vbObjectError + 512, ModuleName & "." & MethodName, "Failed to find a completed processing step: " & .ToString_GroupAndStep()
      End If
   End With
   dicReplaceableParams.Add "{inner_surface}", psiInnerCortex.ResultValue
   
   Dim psiBrainMask As New clsProcessingStepInfo
   With psiBrainMask
      If Not .LoadSessionProcessingStep(oSession.SessionID, psi.ProcessingStepGroupName, "Cerebrum labeling") Then
         Err.Raise vbObjectError + 512, ModuleName & "." & MethodName, "Failed to find a completed processing step: " & .ToString_GroupAndStep()
      End If
   End With
   dicReplaceableParams.Add "{mask_filename}", psiBrainMask.ResultValue_Indexed(0)
   
   
   Call m_BSC.Do_BrainsuiteCommandlineProcess(oSession, psi, strmLogFile, ShowLogWindows, _
                                    MethodName, CommandDescription, ExecutableName, CommandOptions, _
                                    TakeInputFromStepName, TakeInputFromStep_OutputType, OutputFilename_Suffix, OutputFile_ExtractFromLog_RegEx, _
                                    dicReplaceableParams, OutputFile_Extracted_Expected, OutputFilename_Extension, _
                                    OutputFilename_AssumeExpected_IfMatch:=True, OutputType:="surface")

End Sub
Private Sub Do_HemisphereLabeling(oSession As clsSession, psi As clsProcessingStepInfo, strmLogFile As Scripting.TextStream, ShowLogWindows As Boolean)
'  Command-Line Usage
'  hemisplit: Splits a surface object into two separate surfaces given an input label volume. Each vertex is labeled left or right based on the labels being odd (left) or even (right). The largest contour on the split surface is then found and used as the separation between left and right.
'  usage: hemisplit -i input -l labelvolume left left_output right right_output [optional settings]
'  example: hemisplit -i input_surf.dfs -l label.nii.gz left left.pial.dfs right.pial.dfs
'  Required Settings:
'  Flags Description
'  -i <surface>   input surface
'  -l <volume> input hemisphere label volume
'  --left <surface>  output surface file, left hemisphere
'  --right <surface> output surface file, right hemisphere
'  Optional Settings:
'  Flags Description
'  -p <input_pial_surface> pial surface filemust have same geometry as input surface
'  -pl <surface>  output pial surface file, left hemisphere
'  -pr <surface>  output pial surface file, right hemisphere
'  -v <level>  verbosity (0 = silent) [default: 1]
'  --timer  timing function

   Dim MethodName As String
   Dim CommandDescription As String
   Dim ExecutableName As String, CommandOptions As String
   Dim TakeInputFromStepName As String, OutputFilename_Suffix As String, TakeInputFromStep_OutputType As String
   Dim OutputFile_ExtractFromLog_RegEx As String
   Dim dicReplaceableParams As New Scripting.Dictionary
   Dim OutputFile_Extracted_Expected As String
   Dim OutputFilename_Extension As String
   Dim OutputType As String
   
   MethodName = "Do_HemisphereLabeling"
   CommandDescription = "Hemisphere Labeling"
   ExecutableName = "hemisplit"
   CommandOptions = "-v 2  -i '{inner_cortex_surface}' -l '{input_filename}' --left '{output_filename1}' --right '{output_filename2}'  -p '{pial_surface}' -pl '{output_filename3}' -pr '{output_filename4}'"
'%BrainSuiteBinDir%hemisplit %VERBOSE% -i %basename%.inner.cortex.dfs -l %basename%.hemi.label.%EXT% ^
'   --left %basename%.left.inner.cortex.dfs --right %basename%.right.inner.cortex.dfs ^
'   -p %basename%.pial.cortex.dfs -pl %basename%.left.pial.cortex.dfs -pr %basename%.right.pial.cortex.dfs

   TakeInputFromStepName = "Cerebrum labeling"
   TakeInputFromStep_OutputType = "label"
   OutputFilename_Suffix = ".left.inner.cortex|.right.inner.cortex|.left.pial.cortex|.right.pial.cortex"
   OutputFilename_Extension = ".dfs"
   OutputFile_ExtractFromLog_RegEx = "^Wrote (.+?)$" & vbCrLf & _
                                     "^Wrote (.+?)$" & vbCrLf & _
                                     "^mapping vertices." & vbCrLf & _
                                     "^Wrote (.+?)$" & vbCrLf & _
                                     "^Wrote (.+?)$"
                                     
   OutputFile_Extracted_Expected = "{output_filename1}|{output_filename2}|{output_filename3}|{output_filename4}"
   OutputType = "left_inner|right_inner|left_pial|right_pial"
   
   Dim psiInnerCortex As New clsProcessingStepInfo
   With psiInnerCortex
      If Not .LoadSessionProcessingStep(oSession.SessionID, psi.ProcessingStepGroupName, "Inner cortical surface") Then
         Err.Raise vbObjectError + 512, ModuleName & "." & MethodName, "Failed to find a completed processing step: " & .ToString_GroupAndStep()
      End If
   End With
   dicReplaceableParams.Add "{inner_cortex_surface}", psiInnerCortex.ResultValue
   
   Dim psiPialSurface As New clsProcessingStepInfo
   With psiPialSurface
      If Not .LoadSessionProcessingStep(oSession.SessionID, psi.ProcessingStepGroupName, "Pial surface generation") Then
         Err.Raise vbObjectError + 512, ModuleName & "." & MethodName, "Failed to find a completed processing step: " & .ToString_GroupAndStep()
      End If
   End With
   dicReplaceableParams.Add "{pial_surface}", psiPialSurface.ResultValue
   
   
   Call m_BSC.Do_BrainsuiteCommandlineProcess(oSession, psi, strmLogFile, ShowLogWindows, _
                                    MethodName, CommandDescription, ExecutableName, CommandOptions, _
                                    TakeInputFromStepName, TakeInputFromStep_OutputType, OutputFilename_Suffix, OutputFile_ExtractFromLog_RegEx, _
                                    dicReplaceableParams, OutputFile_Extracted_Expected, OutputFilename_Extension, _
                                    OutputType:=OutputType)

End Sub


'
Private Sub Do_ZipFilesForSVReg(oSession As clsSession, psi As clsProcessingStepInfo, strmLogFile As Scripting.TextStream, ShowLogWindows As Boolean)
'For SVReg, it seems to be necessary to GZip a few files.

   Dim MethodName As String
   Dim CommandDescription As String
   Dim ExecutableName As String, CommandOptions As String
   Dim TakeInputFromStepName As String, TakeInputFromOutputType As String
   Dim SourceFilename As String, OutputFilename As String, OutputIterationNumber As Integer
   Dim fso As New FileSystemObject
   Dim AllSuccessful As Boolean
   
   MethodName = "Do_ZipFilesForSVReg"
   CommandDescription = "Zip Files For SVReg"
   psi.StartProcessing_Now
   
   Dim i As Integer
   Dim psiInputStep As clsProcessingStepInfo
   AllSuccessful = True
   For i = 1 To 5
      Select Case i
         Case 1
            TakeInputFromStepName = "Non-uniformity correction"
            TakeInputFromOutputType = "bfc"
            OutputIterationNumber = -1
            
         Case 2
            TakeInputFromStepName = "Cerebrum labeling"
            TakeInputFromOutputType = "mask"
            OutputIterationNumber = 1
         
         Case 3
            TakeInputFromStepName = "Wisp filter"
            TakeInputFromOutputType = "mask"
            OutputIterationNumber = 2
         
         Case 4
            TakeInputFromStepName = "Skull Stripping Mask (BSE)"
            TakeInputFromOutputType = "mask"
            OutputIterationNumber = 3
         
         Case 5
            TakeInputFromStepName = "Tissue classification"
            TakeInputFromOutputType = "fraction"
            OutputIterationNumber = -1
            
      End Select
      
      Set psiInputStep = New clsProcessingStepInfo
      If Not psiInputStep.LoadSessionProcessingStep(oSession.SessionID, psi.ProcessingStepGroupName, TakeInputFromStepName) Then
         Err.Raise vbObjectError + 512, ModuleName & "." & MethodName, "Failed to find a completed processing step: " & TakeInputFromStepName
      End If
      
      Dim step_output As clsProcessingStepOuptut
      Set step_output = psiInputStep.StepOutout_GetSpecific(TakeInputFromOutputType)
      Dim fi As New clsFilename
      
      If step_output Is Nothing Then
         Err.Raise vbObjectError + 512, ModuleName & "." & MethodName, "For step of type '" & psiInputStep.ToString_GroupAndStep() & "', failed to find output file of type '" & TakeInputFromOutputType & "'"
      Else
         Dim strCommandLine As String
         SourceFilename = oSession.SessionPath_Brainsuite & "\" & step_output.OutputFilename
         fi.Filename = SourceFilename
         If LCase(fi.Extension) = ".nii" Then 'avoid compressing anyhing that is not an NII file (including avoiding compressing something that is already ".gz" )
             
             OutputFilename = SourceFilename & ".gz"
             strCommandLine = "cmd /c """"{7zip_exe}"" a ""{zipped_filename}"" ""{source_filename}"""""
             strCommandLine = Replace(strCommandLine, "{7zip_exe}", GetSettingValue("7-Zip executable path", ErrorIfNotFound:=True))
             strCommandLine = Replace(strCommandLine, "{zipped_filename}", OutputFilename)
             strCommandLine = Replace(strCommandLine, "{source_filename}", SourceFilename)
             
             modMRI_Common.RunCommandLine strCommandLine, WorkingDirectory:=oSession.SessionPath_Brainsuite
            
             
             If fso.FileExists(OutputFilename) Then
                psi.StepOutput_Add TakeInputFromOutputType, OutputFilename, OutputIterationNumber
             Else
                psi.ResultComment = "Failed to produce zipped file; commandline attempted was: " & strCommandLine
                AllSuccessful = False
                Exit For
             End If
         End If
      End If
   Next
   
   If AllSuccessful Then
      psi.Save_CompleteNow
   Else
      psi.Save_NotCompleteNow
   End If
End Sub

Private Sub Do_RegisterAndLabelBrain(oSession As clsSession, psi As clsProcessingStepInfo, strmLogFile As Scripting.TextStream, ShowLogWindows As Boolean)
' Command line:
' svreg.exe <subject_file_prefix> [<atlas_file_prefix>] [-<flags>]
'  Flags
'  -H ###   Assigns a number of iterations in the intensity registration step. By default, we perform 100 iterations, but you can specify a different number using this flag. If no number is specified and only H flag is used, then 600 iterations are performed. Example: -H 600
'  -s If surface registration and labeling was already performed at an earlier time and the user would not like to redo this step, then this flag may be used to skip ahead to the volumetric registration. Necessary input files will need to be present in the input directory called by the command.
'  -S Perform surface registration and labeling only; skip the volume registration and labeling.
'  -p If the p-harmonic volumetric registration was already performed at an earlier time and the user would not like to redo this step, then this flag may be used to skip ahead to the intensity registration and label transfer step.
'  -cbm  Can call a manually edited cerebrum mask to limit boundaries. Will use file: subbasename.cerebrum.mask.nii.gz Make sure to correctly replace your manually edited mask file in your input folder with the correct subbasename.
'  -cur sulname.dfc #sul1 #sul2 This flag is used in svreg_label_surf_hemi script to give user control over the curve matching process between the atlas and subject. One can specify the name of the .dfc file <sulname.dfc> and the sulcal numbers <#sul> to be used as constraints. Users can manually edit curves by using the BrainSuite gui interface. Ex: -cur subbasename.right.dfc 1 2 20
'  -C The cerebrum mask <subbasename.cerebrum.mask.nii.gz> will be used for masking the final labels instead of the default pial surface mask. Every voxel will be labeled within the cerebrum mask regardless of the boundaries of the pial surface.
'  -D #  Cortical volume labels found in file output subbasename.svreg.label.nii.gz find its boundaries by using the pial surface then dilating by 1 voxel. Use this flag in order to control the number of pial surface mask dilation. (ie. D 0 will assign no voxel dilation)
'  -v0    verbosity level 0: no messages will be reported
'  -v1   verbosity level 1: messages will be reported but not the iteration-wise detailed messages
'  -v2   verbosity level 2: all the messages, including per-iteration, will be displayed
'  -gui  Short messages instead of detailed messages
'  -m Module name will be displayed in the messages
'  -t Timestamps will be displayed in the messages
'  -U Single threaded mode

   Dim MethodName As String
   Dim CommandDescription As String
   Dim strLogFilename As String
   Dim strCommandLine As String
   Dim psiInputStep As clsProcessingStepInfo
   Dim niif As New clsNiiFilename
   Dim Commandline_base As String, CommandOptions As String
   Dim WorkingDirectory As String
   Dim strOutput_Filename_Expected As String
   Dim Logfile_SuccessMark_RegEx As String, strCompletionInfo As String
   Dim OutputLabelFilename_expected As String
   
   MethodName = "Do_RegisterAndLabelBrain"
   CommandDescription = "Register and Label (SVreg)"
   
   psi.StartProcessing_Now
   
   WorkingDirectory = GetSettingValue(SettingName:="SVReg program folder", SessionID:=oSession.SessionID, ErrorIfNotFound:=True) & "\bin"
   
   Set psiInputStep = Get_Anatomical_PSI(oSession, psi)
   niif.Filename_Original = psiInputStep.ResultValue
   
   Commandline_base = "cmd /c 'svreg {CommandOptions} >> '{logfilename}''"
   CommandOptions = "'{subject_file_prefix}' '{atlas_file_prefix}' -v2 -U "
   strLogFilename = Replace(Replace(Replace(CommandDescription, " ", ""), "(", ""), ")", "") & "_log.txt"
   
   strCommandLine = Commandline_base
   strCommandLine = Replace(strCommandLine, "{CommandOptions}", CommandOptions)
   strCommandLine = Replace(strCommandLine, "{subject_file_prefix}", oSession.SessionPath_Brainsuite & "\" & niif.FileTitle_Base)
   strCommandLine = Replace(strCommandLine, "{atlas_file_prefix}", GetSettingValue(SettingName:="SVReg Atlas", SessionID:=oSession.SessionID, ErrorIfNotFound:=True))
   
   strCommandLine = Replace(strCommandLine, "{logfilename}", oSession.SessionPath_Brainsuite & "\" & strLogFilename)
   strCommandLine = Replace(strCommandLine, "'", """")
  
   Logfile_SuccessMark_RegEx = "^(svreg sequence finished)$"
   niif.FileTitle_SuffixNew = ".svreg.label"
   niif.NewFilename_IsCompressed = True
   OutputLabelFilename_expected = niif.Filename_New
   
  
   If RunCommandLine(strCommandLine, MethodName, WorkingDirectory, _
                     oSession.SessionPath_Brainsuite & "\" & strLogFilename, ShowLogWindows, _
                     strmLogFile, DisplayOutputToDebugWindow) = IWshRuntimeLibrary.WshFinished Then
      
      strCompletionInfo = Trim(modUtility.RegEx_Concatenate(modUtility.TextFile_ReadAll(oSession.SessionPath_Brainsuite & "\" & strLogFilename), _
         Logfile_SuccessMark_RegEx, SubMatchDelimiter:="|", Multiline:=True))

      
      psi.ResultComment = ""
      psi.ResultValue = ""
      If (strCompletionInfo <> "") Then
         Dim fso As New Scripting.FileSystemObject
      
         If fso.FileExists(oSession.SessionPath_Brainsuite & "\" & OutputLabelFilename_expected) Then
            psi.ProcessingComplete = True
            psi.ResultValue = OutputLabelFilename_expected
            psi.StepOutput_Add "label", OutputLabelFilename_expected
         Else
            psi.ProcessingComplete = False
            psi.ResultComment = "Did not find expected Label file: " & oSession.SessionPath_Brainsuite & "\" & OutputLabelFilename_expected
         End If
      Else
         psi.ResultValue = ""
         psi.ResultComment = "WARNING: SVReg did not complete normally.  Please check the output log file: " & strLogFilename
         psi.ProcessingComplete = False
      End If
      
      psi.ProcessingEndTime = Now
      psi.Save
   Else
      psi.ResultComment = "Command execution failed!  Please check log file: " & strLogFilename
      psi.Save_NotCompleteNow
   End If
   

End Sub

Public Function Do_ExtractSVREG_ROI_Data(oSession As clsSession, psi As clsProcessingStepInfo, strmLogFile As Scripting.TextStream, ShowLogWindows As Boolean)
   'This extracts the info from the *roiwise.stats.txt file.
   'Note that there is nothing in the SVREG log output which denotes this filename.  It seems to be a safe assumption that if
   ' SVREG completed normally, there should be a file named <basename>.roiwise.stats.txt
   Const MethodName As String = "Do_ExtractSVREG_RegionData"
   
   psi.StartProcessing_Now
   
   Dim psiSVReg As New clsProcessingStepInfo
   With psiSVReg
      If Not .LoadSessionProcessingStep(oSession.SessionID, psi.ProcessingStepGroupName, "Register and label brain") Then
         Err.Raise vbObjectError + 512, ModuleName & "." & MethodName, "Failed to find a completed processing step: " & .ToString_GroupAndStep()
      End If
   End With
   
   Dim nii As New clsNiiFilename
   Dim pso As clsProcessingStepOuptut

   Set pso = psiSVReg.StepOutout_GetSpecific("label")
   If pso Is Nothing Then
      Err.Raise vbObjectError + 512, ModuleName & "." & MethodName, "Failed to find a processing output type 'label' for processing step info: " & psiSVReg.ToString_GroupAndStep()
   Else
      nii.Filename_Original = pso.OutputFilename
      nii.IncludeOriginalSuffix = False
      nii.IncludePath = True
      nii.NewFilename_IsCompressed = False
      nii.FileTitle_SuffixNew = ".roiwise.stats"
      nii.Extension = ".txt"
      
      Dim strROI_StatFilename As String
      strROI_StatFilename = oSession.SessionPath_Brainsuite & "\" & nii.Filename_New
      
      Dim fso As New Scripting.FileSystemObject
      If Not fso.FileExists(strROI_StatFilename) Then
         psi.ResultValue = "FAILED"
         psi.ResultComment = "Failed to find expected stats file: " & strROI_StatFilename
         psi.Save_NotCompleteNow
      Else
      
         Dim lngDataGroupID_SVReg_ROI As Long
         Dim strDataGroupName As String
         strDataGroupName = "SVReg ROI"
         lngDataGroupID_SVReg_ROI = Nz(DLookup("DataGroupID", "DataGroup", "DataGroup='" & strDataGroupName & "'"), -1)
         If lngDataGroupID_SVReg_ROI < 0 Then
            Err.Raise vbObjectError + 512, ModuleName & "." & MethodName, "Failed to find row on table DataGroup with DataGroup='SVReg ROI'"
         End If
      
         'Adding support for different SVReg atlases, and keeping multiple atlas results in the Datum table based on the
         ' ProcessingInformationID value.  TF 18 Oct 2019
         Dim ProcessingInfoID_CurrentProcess As Long
         Dim SVReg_AtlasPrefix As String, SVReg_Atlas As String
         SVReg_AtlasPrefix = GetSettingValue(SettingName:="SVReg Atlas", SessionID:=oSession.SessionID, ErrorIfNotFound:=True)
         Dim rsProcessingInfo As ADODB.Recordset
         Set rsProcessingInfo = CurrentProject.Connection.Execute("SELECT * FROM ProcessingInformation WHERE ProcessingInformationName Like 'Brain Segmentation%'")
         If Not rsProcessingInfo.EOF Then
            Do
               If rsProcessingInfo![ProcessingKey] & "" <> "" Then
                  If InStr(1, SVReg_AtlasPrefix, rsProcessingInfo![ProcessingKey]) > 0 Then
                     ProcessingInfoID_CurrentProcess = rsProcessingInfo![ProcessingInformationID]
                     SVReg_Atlas = rsProcessingInfo![ProcessingKey]
                  End If
               End If
               rsProcessingInfo.MoveNext
            Loop Until rsProcessingInfo.EOF Or ProcessingInfoID_CurrentProcess > 0
         End If
         rsProcessingInfo.Close

         If ProcessingInfoID_CurrentProcess = 0 Then
            Err.Raise vbObjectError + 512, ModuleName & "." & MethodName, "Failed to find row on table ProcessingInformation that has a key that matches the SVReg atlas that was used, which is believed to be '" & _
                    SVReg_AtlasPrefix & "'"
         End If
         
   
         'check if there is already data of this type on the table
         Dim lngStudyID As Long
         Dim OK_ToProceed As Boolean
         OK_ToProceed = True
         
         lngStudyID = oSession.StudyID_GetSpecific("Cortical Segmentation")
         Dim strSQL As String

         Dim rsExistingDataCount As ADODB.Recordset
         
         'Adjusted SQL to only look for rows having the same ProcessingInformationID.  TF 18 Oct 2019
         strSQL = "SELECT Count(Datum.DatumID) AS CountOfDatumID " & _
                  "FROM Study INNER JOIN (DataType INNER JOIN Datum ON DataType.DataTypeID = Datum.DataTypeID) ON Study.StudyID = Datum.StudyID " & _
                  "WHERE (((Study.StudyID)=" & lngStudyID & ") AND (DataType.DataGroupID=" & lngDataGroupID_SVReg_ROI & ") AND " & _
                  "(ProcessingInformationID=" & ProcessingInfoID_CurrentProcess & " ) )"
         Set rsExistingDataCount = CurrentProject.Connection.Execute(strSQL)
         If rsExistingDataCount![CountOfDatumID] > 0 Then
            Dim strMessage As String
            strMessage = "There are already " & rsExistingDataCount![CountOfDatumID] & " existing records on the Datum table for this Study in the DataGroup='" & strDataGroupName & "', using the SVReg atlas '" & SVReg_Atlas & "'. " & vbCrLf & _
               "Would you like to delete those existing records before importing this new data file '" & strROI_StatFilename & "'?" & vbCrLf & vbCrLf & _
               "Answer 'Yes' to delete the existing records." & vbCrLf & _
               "Answer 'No' to keep the existing records, and read in the data file as new records." & vbCrLf & _
               "Answer 'Cancel' to cancel the current import of the new data file."
               
            Dim response As VbMsgBoxResult
            'Decided to not ask this any more. TF 07 June 2018
            'response = MsgBox(strMessage, vbYesNoCancel + vbQuestion, "Delete existing data of same type?")
            response = vbYes
            If response = vbYes Then
               'Adjusted SQL to only delete rows having the same ProcessingInformationID.  TF 18 Oct 2019
               strSQL = "DELETE * FROM Datum " & _
                     "WHERE (((Datum.StudyID)=" & lngStudyID & ") AND (ProcessingInfoID=" & ProcessingInfoID_CurrentProcess & ") AND ((Datum.DataTypeID) In (SELECT DataTypeID from DataType where DataGroupID=" & lngDataGroupID_SVReg_ROI & ")))"
               Dim lngRecordsDeleted As Long
               CurrentProject.Connection.Execute strSQL, lngRecordsDeleted
             '  MsgBox "Deleted " & lngRecordsDeleted & " records from Datum table", vbOKOnly + vbInformation, "Records Deleted"
            ElseIf response = vbCancel Then
               psi.ResultValue = "CANCELED"
               psi.ResultComment = "User canceled import of stats file: " & strROI_StatFilename
               psi.Save_NotCompleteNow
               OK_ToProceed = False
            End If
         End If
         rsExistingDataCount.Close
          
         If OK_ToProceed Then
            Dim ColumnCount As Integer, i As Integer
            Dim column_data() As String
            Dim strm As Scripting.TextStream
            Set strm = fso.GetFile(strROI_StatFilename).OpenAsTextStream(ForReading)
            Dim strStatsLine As String
            Dim RowNumber_Processing As Long
            
            strStatsLine = strm.ReadLine
            RowNumber_Processing = RowNumber_Processing + 1
            column_data = Split(strStatsLine, vbTab)
            ColumnCount = UBound(column_data) + 1
            Dim column_DataTypeID() As Long
            ReDim column_DataTypeID(ColumnCount)
            
            'we expect the first column will be ROI_ID ... if not, do not proceed
            If column_data(0) <> "ROI_ID" Then
               Err.Raise vbObjectError + 512, ModuleName & "." & MethodName, "On RowNumber=" & RowNumber_Processing & ", expected first column of ROI stat file to be 'ROI_ID', instead found '" & column_data(0) & "', in file: " & strROI_StatFilename
            End If
                        
            'get the DataTypeID for each column
            For i = 1 To ColumnCount - 1  'note, skip column 0 -- that is the ROI_ID
               Dim strDataTypeName As String
               Dim posLastParen As Integer
               Dim lngDataTypeID As Long
               strDataTypeName = column_data(i)
               If InStrRev(strDataTypeName, "(") > 0 Then  'in this file, we expect the column names will have units in parenthesis at the end; strip that off before doing lookup of data type name
                  strDataTypeName = Left(strDataTypeName, InStrRev(strDataTypeName, "(") - 1)
               End If
               lngDataTypeID = Nz(DLookup("DataTypeID", "DataType", "DataGroupID=" & lngDataGroupID_SVReg_ROI & " AND DataTypeName='" & strDataTypeName & "'"), -1)
               If lngDataTypeID < 0 Then
                  Err.Raise vbObjectError + 512, ModuleName & "." & MethodName, "On RowNumber=" & RowNumber_Processing & ", the column name '" & column_data(i) & "' is not recognized as a valid DataTypeName; in file: " & strROI_StatFilename
               End If
               column_DataTypeID(i) = lngDataTypeID
            Next
                     
            Dim ROI_ID As Long, lngBrainRegionID As Long
            Dim rsData As DAO.Recordset   'use DAO recordset... faster than ADODB
            Set rsData = CurrentDb.OpenRecordset("Datum", dbOpenDynaset, dbAppendOnly)

            'now read through file, add all data to the table
            Do Until strm.AtEndOfStream
               strStatsLine = strm.ReadLine
               RowNumber_Processing = RowNumber_Processing + 1
               column_data = Split(strStatsLine, vbTab)
               ROI_ID = CLng(column_data(0))
               lngBrainRegionID = Nz(DLookup("BrainRegionID", "BrainRegion", "ROI_ID=" & ROI_ID), -1)
               If lngBrainRegionID < 0 Then
                  Err.Raise vbObjectError + 512, ModuleName & "." & MethodName, "On RowNumber=" & RowNumber_Processing & ", failed to find ROI_ID=" & ROI_ID & " on table 'BrainRegion'; in file: " & strROI_StatFilename
               End If
               
   
               For i = 1 To ColumnCount - 1  'note, skip column 0 -- that is the ROI_ID
                  rsData.AddNew
                  With rsData
                     ![StudyID] = lngStudyID
                     ![DataTypeID] = column_DataTypeID(i)
                     'Here I am assuming all the data is numeric... for this file it is fine.  Would be more correct to check the ValueType on the DataType table
                     On Error Resume Next
                     ![Value_Numeric] = CDbl(column_data(i))
                     If Err.Number <> 0 Then
                        ![Value_Text] = column_data(i)
                     End If
                     On Error GoTo 0
                     ![BrainRegionID] = lngBrainRegionID
                     ![ProcessingInformationID] = ProcessingInfoID_CurrentProcess  'TF 18 Oct 2019
                  End With
                  rsData.Update
               Next
            Loop
            strm.Close
            rsData.Close
            psi.ResultValue = "Imported stat file"
            psi.ResultComment = "Processed " & RowNumber_Processing & " rows from file: " & strROI_StatFilename
            psi.StepOutput_Add "stats", strROI_StatFilename
            psi.Save_CompleteNow
            
         End If
      End If
   End If

End Function

Private Function Get_Anatomical_PSI(oSession As clsSession, psiBase As clsProcessingStepInfo) As clsProcessingStepInfo
   Dim psiAnatomical As New clsProcessingStepInfo
   Const MethodName = "Get_Anatomical_PSI"
   If Not psiAnatomical.LoadSessionProcessingStep(oSession.SessionID, psiBase.ProcessingStepGroupName, "Copy anatomical Nii") Then
      Err.Raise vbObjectError + 512, ModuleName & "." & MethodName, "Failed to find a completed processing step: " & psiAnatomical.ToString_GroupAndStep()
   End If
   Set Get_Anatomical_PSI = psiAnatomical
End Function
Private Function Get_BrainMask_Completed_PSI(oSession As clsSession, psiBase As clsProcessingStepInfo) As clsProcessingStepInfo
   Dim psiBrainMask As New clsProcessingStepInfo
   Const MethodName = "Get_BrainMask_PSI"
   
   'look for the brain mask produced either by "Skull Stripping Mask (BSE)" or "Create Brain mask"
   Dim Status As Boolean
   Status = psiBrainMask.LoadSessionProcessingStep(oSession.SessionID, psiBase.ProcessingStepGroupName, "Create Brain mask")
   If Not Status Then
      Status = psiBrainMask.LoadSessionProcessingStep(oSession.SessionID, psiBase.ProcessingStepGroupName, "Skull Stripping Mask (BSE)")
   End If
   
   If Not Status Then
      Err.Raise vbObjectError + 512, ModuleName & "." & MethodName, "Failed to find a completed brain mask processing step, looking for processing step names 'Create Brain mask' or 'Skull Stripping Mask (BSE)'"
   End If
   Set Get_BrainMask_Completed_PSI = psiBrainMask
End Function

----------- end of component
Component: clsSession; Class module
Option Compare Database
Option Explicit

Private mSessionID As Long
Private mProjectID As Long
Private mSessionGroupID As Long
Private mSubjectID   As Long
Private mDescription As String
Private mRootFolder As String

Private mstrDataRootPath As String
Private mstrSessionPath As String
Private mstrOriginalImportFolder As String


Public Property Let SessionID(value As Long)
   mSessionID = value
   Populate
End Property
Public Property Get SessionID() As Long
   SessionID = mSessionID
End Property

Public Property Get ProjectID() As Long
   ProjectID = mProjectID
End Property

Public Property Get SessionGroupID() As Long
   SessionGroupID = mSessionGroupID
End Property
Public Property Get SubjectID() As Long
   SubjectID = mSubjectID
End Property
Public Property Get Description() As String
   Description = mDescription
End Property
Public Property Get RootFolder() As String
   RootFolder = mRootFolder
End Property

Public Property Get DataRootPath() As String
   DataRootPath = mstrDataRootPath
End Property
Public Property Get SessionPath() As String
   SessionPath = mstrSessionPath
End Property

Public Property Get SessionPath_Nii() As String
   SessionPath_Nii = Me.SessionPath & "\Nii"
End Property
Public Property Get SessionPath_ASL() As String
   SessionPath_ASL = Me.SessionPath & "\ASL"
End Property
Public Property Get SessionPath_Brainsuite() As String
   SessionPath_Brainsuite = Me.SessionPath & "\Brainsuite"
End Property
Public Property Get SessionPath_DTI() As String
   SessionPath_DTI = Me.SessionPath & "\Brainsuite\DTI"
End Property
Public Property Get SessionPath_Raw() As String
   SessionPath_Raw = Me.SessionPath & "\raw"
End Property

Public Property Get OriginalImportFolder() As String
   OriginalImportFolder = mstrOriginalImportFolder
End Property

Public Property Get SessionDescription() As String
   SessionDescription = DLookup("SessionDescription", "lookup_Session", "SessionID=" & Me.SessionID)
End Property

Public Function StudyID_GetSpecific(StudyTypeName As String, Optional Iteration As Integer = -1) As Long
   Dim lngStudyID As Long, lngStudyTypeID As Long
   lngStudyID = -1
   lngStudyTypeID = DLookup("StudyTypeID", "StudyType", "StudyType='" & StudyTypeName & "'")
   lngStudyID = Nz(DLookup("StudyID", "Study", "SessionID=" & Me.SessionID & " AND StudyTypeID=" & lngStudyTypeID & _
                           IIf(Iteration >= 0, " AND Iteration=" & Iteration, "")), -1)
                           
   StudyID_GetSpecific = lngStudyID
End Function

Public Function GetDataRootPath(ProjectID As Long) As String
   Dim strProjectDataPath As String, strGeneralDataPath As String
   
   strGeneralDataPath = GetSettingValue(SettingName:="Data root path", SessionID:=IIf(Me.SessionID > 0, Me.SessionID, -1))
   strProjectDataPath = Nz(DLookup("DataFolderRoot", "Project", "ProjectID=" & ProjectID), "")
   
   'see if the strProjectDataPath already has a drive letter or network path chars
   If Not ((Mid(strProjectDataPath, 2, 1) = ":") Or (Left(strProjectDataPath, 2) = "\\")) Then
      strProjectDataPath = strGeneralDataPath & "\" & strProjectDataPath
   End If
   
   GetDataRootPath = strProjectDataPath
   
End Function
Private Sub Populate()
   'set the DataRootPath based on the setting in the Project record; or if that is not available, get from the general Settings
   Dim ProjectID As Long
   ProjectID = Nz(DLookup("ProjectID", "Session", "SessionID=" & Me.SessionID), 0)
   mstrDataRootPath = Me.GetDataRootPath(ProjectID)
   
   Dim rsSession As New ADODB.Recordset
   Dim strSQL As String
   strSQL = "SELECT * FROM [Session] WHERE [Session].[SessionID]=" & mSessionID
   rsSession.Open strSQL, CurrentProject.Connection, adOpenStatic, adLockReadOnly
   
   If rsSession.EOF Then
      Err.Raise vbObjectError + 512, "clsSession.Populate", "SessionID '" & Me.SessionID & "' not found in Session table"
   Else
      With rsSession
      'SessionID  ProjectID   SessionGroupID   SubjectID   Description RootFolder
         mProjectID = Nz(![ProjectID], 0)
         mSessionGroupID = Nz(![SessionGroupID], 0)
         mSubjectID = Nz(![SubjectID], 0)
         mDescription = Nz(![Description])
         mRootFolder = ![RootFolder]
         mstrOriginalImportFolder = Nz(![OriginalImportFolder], "")
      End With
      
      If (mRootFolder Like "?:\*") Then  'if RootFolder is declared with a drive letter, take it as is
         mstrSessionPath = mRootFolder
      Else
         mstrSessionPath = mstrDataRootPath & "\" & mRootFolder
      End If
            
   End If
   rsSession.Close
   
   
End Sub
----------- end of component
Component: clsStringBuilder; Class module
Option Compare Database
Option Explicit

Private Const initialLength As Long = 32

Private totalLength As Long  ' Length of the buffer
Private curLength As Long    ' Length of the string value within the buffer
Private buffer As String     ' The buffer

Private Sub Class_Initialize()
  ' We set the buffer up to it's initial size and the string value ""
  totalLength = initialLength
  buffer = Space(totalLength)
  curLength = 0
End Sub

Public Sub Append(Text As String)

  Dim incLen As Long ' The length that the value will be increased by
  Dim newLen As Long ' The length of the value after being appended
  incLen = Len(Text)
  newLen = curLength + incLen

  ' Will the new value fit in the remaining free space within the current buffer
  If newLen <= totalLength Then
    ' Buffer has room so just insert the new value
    Mid(buffer, curLength + 1, incLen) = Text
  Else
    ' Buffer does not have enough room so
    ' first calculate the new buffer size by doubling until its big enough
    ' then build the new buffer
    While totalLength < newLen
      totalLength = totalLength + totalLength
    Wend
    buffer = Left(buffer, curLength) & Text & Space(totalLength - newLen)
  End If
  curLength = newLen
End Sub

Public Property Get Length() As Integer
  Length = curLength
End Property

Public Property Get Text() As String
  Text = Left(buffer, curLength)
End Property

Public Sub Clear()
  totalLength = initialLength
  buffer = Space(totalLength)
  curLength = 0
End Sub
----------- end of component
Component: clsNiiFilename; Class module
Option Compare Database
Option Explicit

Private mFilename_Original As String
Private mFileTitle_Base As String
Private mFileTitle_SuffixOriginal As String
Private mFileTitle_SuffixNew As String
Private mExtension As String
Private mPath As String

Public IncludeOriginalSuffix As Boolean
Public IncludePath As Boolean
Public NewFilename_IsCompressed As Boolean

Const FilenamePattern As String = "^((\d+_)?(.*_)(\d+))(\..+)?(\.nii(.gz)?)$"
Const CompressedFileExtension As String = ".gz"
Private ApplyCompressedFileExtenion_OnlyToNII As Boolean


'with a filename like this: 73_b_mprage_2.label.nii.gz
'the capture groups are:
'$matches Array:
'(
'    mats(0).Value => 73_b_mprage_2.label.nii.gz
'    mats(0).SubMatches(0) => 73_b_mprage_2
'    mats(0).SubMatches(1) => 73_
'    mats(0).SubMatches(2) => b_mprage_
'    mats(0).SubMatches(3) => 2
'    mats(0).SubMatches(4) => .label
'    mats(0).SubMatches(5) => .nii.gz
'    mats(0).SubMatches(6) => .gz
')
'
'

Public Property Let Filename_Original(value As String)
   If InStr(1, value, "\") > 0 Then
      Dim posLastSlash As Integer
      posLastSlash = InStrRev(value, "\")
      mPath = Left(value, posLastSlash - 1)
      value = Mid(value, posLastSlash + 1)
   Else
      mPath = ""
   End If
   
   mFilename_Original = value
   Dim regex As New VBScript_RegExp_55.RegExp
   regex.Pattern = FilenamePattern
   Dim mats As VBScript_RegExp_55.MatchCollection
   Set mats = regex.Execute(Me.Filename_Original)
   Dim mat As VBScript_RegExp_55.Match

   If mats.Count = 0 Then
      'try something more simple
      regex.Pattern = "^(.*?)(\.nii(.gz)?)$"
      Set mats = regex.Execute(Me.Filename_Original)
      mFileTitle_Base = mats(0).SubMatches(0)
      mFileTitle_SuffixOriginal = ""
      mExtension = mats(0).SubMatches(1)
   
   Else
      mFileTitle_Base = mats(0).SubMatches(0)
      mFileTitle_SuffixOriginal = mats(0).SubMatches(4)
      mExtension = mats(0).SubMatches(5)
   End If
   
End Property
Public Property Get Filename_Original() As String
   Filename_Original = mFilename_Original
End Property

Public Property Get Extension() As String
   Extension = mExtension
End Property

Public Property Let Extension(value As String)
   mExtension = value
End Property

Public Property Get FileTitle_Base() As String
   FileTitle_Base = mFileTitle_Base
End Property

Public Property Let FileTitle_Base(value As String)
   mFileTitle_Base = value
End Property

Public Property Get FileTitle_SuffixOriginal() As String
   FileTitle_SuffixOriginal = mFileTitle_SuffixOriginal
End Property

Public Property Let FileTitle_SuffixNew(value As String)
   mFileTitle_SuffixNew = value
End Property
Public Property Get FileTitle_SuffixNew() As String
   FileTitle_SuffixNew = mFileTitle_SuffixNew
End Property

Public Property Get Filename_New() As String
   Dim str As String
   If Me.IncludeOriginalSuffix Then
      str = Me.FileTitle_Base & Me.FileTitle_SuffixOriginal & Me.FileTitle_SuffixNew & Me.Extension
   Else
      str = Me.FileTitle_Base & Me.FileTitle_SuffixNew & Me.Extension
   End If
   
   Dim FilenameIsCompressed As Boolean
   FilenameIsCompressed = (LCase(Right(str, 3)) = LCase(CompressedFileExtension))
      
   If (FilenameIsCompressed <> NewFilename_IsCompressed) And _
      ((LCase(Me.Extension) = ".nii") Or (Not ApplyCompressedFileExtenion_OnlyToNII)) Then     'NOTE: only apply the '.gz' extension to NII files.
      'fix it
      If NewFilename_IsCompressed Then 'need to add the ".gz"
         str = str & CompressedFileExtension
      Else 'need to remove the ".gz"
         str = Left(str, Len(str) - Len(CompressedFileExtension))
      End If
   End If
   
   Filename_New = str
End Property

Private Sub Class_Initialize()
   IncludeOriginalSuffix = True
   IncludePath = True
  
   NewFilename_IsCompressed = CBool(GetSettingValue("Brainsuite Produce Gzipped Files", ValueIfNotFound:="true"))
   ApplyCompressedFileExtenion_OnlyToNII = True  'NOTE: only apply the '.gz' extension to NII files.  IF some reason to do otherwise, we can make this a public property later to allow user to change; or we can add more logic somewhere in this class

End Sub
----------- end of component
Component: modUtility; Standard module
Option Explicit

#If Office_64bit Then
Public Declare PtrSafe Sub Sleep Lib "kernel32" (ByVal dwMilliseconds As Long)
#Else
Public Declare Sub Sleep Lib "kernel32" (ByVal dwMilliseconds As Long)
#End If

Private Const ThisModName As String = "modUtility"

Public Enum eRunCommand_WindowStyle
   NewWindow = 0    'Hides the window and activates another window.
   RestoreOrDisplay_Activate = 1    'Activates and displays a window. If the window is minimized or maximized, the system restores it to its original size and position. An application should specify this flag when displaying the window for the first time.
   Minimize_Activate = 2     'Activates the window and displays it as a minimized window.
   Maximize_Activate = 3    'Activates the window and displays it as a maximized window.
   Restore_NotActivate = 4    'Displays a window in its most recent size and position. The active window remains active.
   Activate = 5    'Activates the window and displays it in its current size and position.
   Minimize_ActivateNext = 6     'Minimizes the specified window and activates the next top-level window in the Z order.
   Minimize = 7    'Displays the window as a minimized window. The active window remains active.
   Display = 8    'Displays the window in its current state. The active window remains active.
   Restore_Activate = 9     'Activates and displays the window. If the window is minimized or maximized, the system restores it to its original size and position. An application should specify this flag when restoring a minimized window.
   BasedOnCaller = 10    'Sets the show-state based on the state of the program that started the application.

End Enum

#If Office_64bit Then
Private Type SHITEMID
    cb As LongLong
    abID As Byte
End Type
#Else
Private Type SHITEMID
    cb As Long
    abID As Byte
End Type

#End If

Private Type ITEMIDLIST
    mkid As SHITEMID
End Type

Public Enum eSpecialFolders
   Desktop = 0  ' #define CSIDL_DESKTOP   0
   Internet = 1  ' #define CSIDL_INTERNET  1
   Programs = 2  ' #define CSIDL_PROGRAMS  2
   Controls = 3  ' #define CSIDL_CONTROLS  3
   Printers = 4  ' #define CSIDL_PRINTERS  4
   MyDocuments = 5  ' #define CSIDL_PERSONAL  5
   Favorites = 6  ' #define CSIDL_FAVORITES 6
   Startup = 7  ' #define CSIDL_STARTUP   7
   Recent = 8  ' #define CSIDL_RECENT    8
   Sendto = 9  ' #define CSIDL_SENDTO    9
   Bitbucket = 10  ' #define CSIDL_BITBUCKET 10
   Startmenu = 11  ' #define CSIDL_STARTMENU 11
   Desktopdirectory = 16  ' #define CSIDL_DESKTOPDIRECTORY  16
   Drives = 17  ' #define CSIDL_DRIVES    17
   Network = 18  ' #define CSIDL_NETWORK   18
   Nethood = 19  ' #define CSIDL_NETHOOD   19
   Fonts = 20  ' #define CSIDL_FONTS     20
   Templates = 21  ' #define CSIDL_TEMPLATES 21
   Common_Startmenu = 22  ' #define CSIDL_COMMON_STARTMENU  22
   Common_Programs = 23  ' #define CSIDL_COMMON_PROGRAMS   23
   Common_Startup = 24  ' #define CSIDL_COMMON_STARTUP    24
   Common_Desktopdirectory = 25  ' #define CSIDL_COMMON_DESKTOPDIRECTORY   25
   AppData = 26  ' #define CSIDL_APPDATA   26
   Printhood = 27  ' #define CSIDL_PRINTHOOD 27
   Altstartup = 29  ' #define CSIDL_ALTSTARTUP    29
   Common_Altstartup = 30  ' #define CSIDL_COMMON_ALTSTARTUP 30
   Common_Favorites = 31  ' #define CSIDL_COMMON_FAVORITES  31
   Internet_Cache = 32  ' #define CSIDL_INTERNET_CACHE   32
   Cookies = 33  ' #define CSIDL_COOKIES   33
   History = 34  ' #define CSIDL_HISTORY   34

End Enum

#If Office_64bit Then
    Private Declare PtrSafe Function SHGetSpecialFolderLocation Lib _
        "shell32.dll" (ByVal hwndOwner As LongPtr, ByVal nFolder As Long, _
        pidl As ITEMIDLIST) As LongPtr

      Private Declare PtrSafe Function SHGetPathFromIDList Lib "shell32.dll" Alias "SHGetPathFromIDListA" _
        (ByVal pidl As LongPtr, ByVal pszPath As String) As Boolean
#Else

   Private Declare Function SHGetSpecialFolderLocation Lib "shell32.dll" _
                           (ByVal hwndOwner As Long, ByVal nFolder As Long, _
                            pidl As ITEMIDLIST) As Long
                            
   Private Declare Function SHGetPathFromIDList Lib "shell32.dll" Alias "SHGetPathFromIDListA" _
                           (ByVal pidl As Long, ByVal pszPath As String) As Long
#End If

Public Function TextFile_ReadAll(strTextFilePath As String) As String
   Dim strAll As String
   Dim fso As New Scripting.FileSystemObject
   Dim strm As Scripting.TextStream
   
   On Error GoTo TextFile_ReadAll_Err
   Set strm = fso.OpenTextFile(strTextFilePath, ForReading)
   strAll = strm.ReadAll
   strm.Close
   Set fso = Nothing
   TextFile_ReadAll = strAll
Exit Function

TextFile_ReadAll_Err:
   TextFile_ReadAll = "File read error: " & Err.Description
End Function

Public Function EliminateDoubleSpace(strInput As String) As String
   
   Dim str As String
   
   str = strInput
   Do Until InStr(1, str, "  ", vbBinaryCompare) = 0
      str = VBA.Replace(str, "  ", " ", , , vbBinaryCompare)
   Loop
   EliminateDoubleSpace = str
End Function


Public Function EliminateEOLChars(strInput As String, Optional ReplaceWithSpaces As Boolean = False) As String
   Dim str As String
   
   str = strInput
   str = VBA.Replace(str, vbCr, IIf(ReplaceWithSpaces, " ", ""), , , vbBinaryCompare)
   str = VBA.Replace(str, vbLf, IIf(ReplaceWithSpaces, " ", ""), , , vbBinaryCompare)
   EliminateEOLChars = str
End Function

Public Sub EliminateEOLChars_Records(RecordSource As String, Optional FieldName As String = "")
   Dim fld As ADODB.Field
   Dim rs As New ADODB.Recordset
   rs.Open RecordSource, Application.CurrentProject.Connection, adOpenStatic, adLockOptimistic
   Do Until rs.EOF
      If FieldName = "" Then
         For Each fld In rs.Fields
            If (fld.Type = adWChar) Or (fld.Type = adVarWChar) Or (fld.Type = adLongVarWChar) Then
               fld.value = EliminateEOLChars(CStr(fld.value))
            End If
         Next fld
      Else
         Set fld = rs.Fields(FieldName)
         fld.value = EliminateEOLChars(CStr(fld.value))
      End If
      rs.Update
      rs.MoveNext
      DoEvents
   Loop
   
End Sub


Function RandomHexString(Optional num_words As Integer = 4) As String

   Dim strHex As String
   Dim i As Integer
   
   strHex = ""
   For i = 0 To num_words - 1
      strHex = strHex & Replace(Format(Hex(Int(&H10000 * Rnd())), "@@@@"), " ", "0")
   Next i

   RandomHexString = strHex
End Function


Function RegEx_Test(strText As String, strPattern As String, _
   Optional IgnoreCase As Boolean = True, Optional MatchAll As Boolean = False, _
   Optional Multiline As Boolean = True) As Boolean

   Dim regex As New VBScript_RegExp_55.RegExp
   
   regex.Pattern = strPattern
   regex.IgnoreCase = IgnoreCase  ' Set case insensitivity.
   regex.Global = False  ' this is ignored for the Test function ... just needs one match to be True
   regex.Multiline = Multiline
   RegEx_Test = regex.test(strText)    ' Execute search.
 
End Function

Public Function RegEx_ExtractSubstrings(strText As String, strPattern As String, _
   Optional IgnoreCase As Boolean = True, Optional MatchAll As Boolean = False, _
   Optional Multiline As Boolean = True) As String()
   'supplied pattern should include one or more captures ()

   'returns a string array of captured values

   Dim matches As VBScript_RegExp_55.MatchCollection, thisMatch As VBScript_RegExp_55.Match
   Dim mat As VBScript_RegExp_55.Match
   Set matches = RegEx_ExtractMatches(strText, strPattern, IgnoreCase, MatchAll, Multiline)
   
   Dim strValues() As String, sm As Integer
   Dim ValuesCount As Long

   For Each mat In matches
      For sm = 0 To mat.SubMatches.Count - 1
         ReDim Preserve strValues(ValuesCount)
         strValues(ValuesCount) = mat.SubMatches(sm)
         ValuesCount = ValuesCount + 1
      Next sm
   Next mat

   RegEx_ExtractSubstrings = strValues
End Function


Public Function RegEx_ExtractSubstring(strText As String, strPattern As String, _
   Optional IgnoreCase As Boolean = True, Optional MatchAll As Boolean = False, _
   Optional Multiline As Boolean = True) As String
   'supplied pattern should include a capture ()
   Dim matches As VBScript_RegExp_55.MatchCollection, thisMatch As VBScript_RegExp_55.Match
   Set matches = RegEx_ExtractMatches(strText, strPattern, IgnoreCase, MatchAll, Multiline)
   
   RegEx_ExtractSubstring = ""

   If matches.Count > 0 Then
      Set thisMatch = matches.Item(0)
      If Not thisMatch Is Nothing Then
         RegEx_ExtractSubstring = thisMatch.SubMatches(0)
      End If
   End If

End Function
Public Function RegEx_ExtractMatches(strText As String, strPattern As String, _
   Optional IgnoreCase As Boolean = True, Optional MatchAll As Boolean = False, _
   Optional Multiline As Boolean = True) As VBScript_RegExp_55.MatchCollection
   
   Dim regex As New VBScript_RegExp_55.RegExp
   
   regex.Pattern = strPattern
   regex.IgnoreCase = IgnoreCase  ' Set case insensitivity.
   regex.Global = MatchAll ' Set global applicability.
   regex.Multiline = Multiline
   Set RegEx_ExtractMatches = regex.Execute(strText)   ' Execute search.
      
   
End Function


Public Function RegEx_Substitute(strText As String, strPattern As String, strSubstitute As String, _
   Optional IgnoreCase As Boolean = True, Optional MatchAll As Boolean = True, _
   Optional Multiline As Boolean = True) As String
   Dim regex As New RegExp

   With regex
      .Pattern = strPattern
      .Multiline = Multiline
      .IgnoreCase = IgnoreCase
      .Global = MatchAll
      RegEx_Substitute = .Replace(strText, strSubstitute)
   End With

End Function

Public Function RegEx_Concatenate(strText As String, strPattern As String, _
   Optional MatchDelimiter As String = "", Optional SubMatchDelimiter As String = "", _
   Optional IgnoreCase As Boolean = True, Optional MatchAll As Boolean = True, _
   Optional Multiline As Boolean = True) As String

   Dim matches As VBScript_RegExp_55.MatchCollection
   Dim m As VBScript_RegExp_55.Match, smi As Integer
   Dim strThisMatch As String, strRegExExtractionResult As String

   Set matches = modUtility.RegEx_ExtractMatches(strText, strPattern, IgnoreCase, MatchAll, Multiline)
   For Each m In matches
      strThisMatch = ""
      For smi = 0 To m.SubMatches.Count - 1
         strThisMatch = strThisMatch & IIf(smi > 0, SubMatchDelimiter, "") & m.SubMatches(smi)
      Next smi

      strRegExExtractionResult = strRegExExtractionResult & IIf(strRegExExtractionResult <> "", MatchDelimiter, "") & strThisMatch

   Next m

   RegEx_Concatenate = strRegExExtractionResult
End Function

Public Function StrToHex(s As String) As String
   'converts string to a hexedecimal string; useful to generate case-sensitive keys (Access indexes are case-insensitive)
   
   Dim in_pos As Long, out_pos As Long
   Dim sHex As String
   
   sHex = String(Len(s) * 2, " ") 'make empty string twice as long as starting string
   'do this as buffer insterts instead of concatenation just to speed up a little bit
   
   out_pos = 1
   For in_pos = 1 To Len(s)
      Mid(sHex, out_pos, 2) = Hex(Asc(Mid(s, in_pos, 1)))
      out_pos = out_pos + 2
   Next in_pos
   
   StrToHex = sHex
End Function


Public Function StringsEquivalent(s1 As String, s2 As String) As Boolean
   'What does Equivalent mean?
   'This is a simple-minded function that strips all punctuation, converts to uppercase, and trims;
   ' then test for exact equality
   Dim s As String
   Dim i As Integer
   
   If s1 = s2 Then  'in many cases, they are already exactly same, so don't bother with stuff below
      StringsEquivalent = True
   Else
      For i = 1 To 2
         s = Choose(i, s1, s2)
         s = Trim(UCase(s))
         s = VBA.Replace(s, ",", "")
         s = VBA.Replace(s, ".", "")
         s = VBA.Replace(s, ";", "")
         s = VBA.Replace(s, ":", "")
         s = VBA.Replace(s, "-", "")
         
         'eliminate all spaces
         Do
            s = VBA.Replace(s, " ", "")
         Loop Until InStr(1, s, " ", vbBinaryCompare) = 0
         
         Select Case i
            Case 1: s1 = s
            Case 2: s2 = s
         End Select
      Next i
      
      StringsEquivalent = (s1 = s2)
   End If

End Function


Public Function CInt_Month_English(strMonth As String) As Integer
   Const ThisProcName = "CInt_Month_English"
   Dim intMonth As Integer
   Select Case UCase(strMonth)
      Case "JAN", "JANUARY":   intMonth = 1
      Case "FEB", "FEBRUARY":  intMonth = 2
      Case "MAR", "MARCH":     intMonth = 3
      Case "APR", "APRIL":     intMonth = 4
      Case "MAY", "MAY":       intMonth = 5
      Case "JUN", "JUNE":      intMonth = 6
      Case "JUL", "JULY":      intMonth = 7
      Case "AUG", "AUGUST":    intMonth = 8
      Case "SEP", "SEPTEMBER": intMonth = 9
      Case "OCT", "OCTOBER":   intMonth = 10
      Case "NOV", "NOVEMBER":  intMonth = 11
      Case "DEC", "DECEMBER":  intMonth = 12

      Case Else
         Err.Raise vbObjectError + 512, ThisModName & ":" & ThisProcName, "Month name not recognized:" & strMonth
   End Select
End Function


Public Sub CreatePath(ByVal PathToCreate As String)

   'if folder does not exist, create it
   
   'the idea is to step through the supplied path one folder at a time, and create folders as necessary
   
   Dim PathParser As New clsParser
   Dim strTestPath As String
   Dim i As Integer
   Dim StartParam As Integer
   
   On Error GoTo CreatePathErr
   
   'if caller supplied a final "\", strip it off
   If Right(PathToCreate, 1) = "\" Then
      PathToCreate = Left(PathToCreate, Len(PathToCreate) - 1)
   End If
   
   If Dir(PathToCreate, vbDirectory) = "" Then 'if the supplied Path already exists, do nothing
      
      With PathParser
         .Delimiter = "\"
         .SuccessiveDelimitersAsOne = False
         .ParseLine PathToCreate
         
         If Left(PathToCreate, 2) = "\\" Then 'if supplied with a network path, needs slight special handling
            StartParam = 3
            strTestPath = "\\" & .Parameter(2)
         Else
            StartParam = 0
            strTestPath = ""
         End If
         
         For i = StartParam To .ParameterCount - 1
            If strTestPath <> "" Then strTestPath = strTestPath & "\"
            strTestPath = strTestPath & .Parameter(i)
            
            If Dir(strTestPath, vbDirectory) = "" Then
               MkDir strTestPath
            End If
   
         Next i
      End With
   
   End If
   
CreatePathExit:

Exit Sub

CreatePathErr:
   Err.Raise vbObjectError, "CreatePath:" & Err.Source, Err.Description
End Sub


Public Function Max(a As Variant, b As Variant) As Variant
   
   If a > b Then
      Max = a
   Else
      Max = b
   End If
End Function

Public Function Min(a As Variant, b As Variant) As Variant
   
   If a < b Then
      Min = a
   Else
      Min = b
   End If
End Function


Public Function ComputerIsAlive(strComputerName As String) As Boolean
   Dim strCommandLine  As String
   Dim strCommandResponse  As String
   Dim FoundTTL  As Boolean

   strCommandLine = "ping -n 1 -w 30 " & strComputerName
   strCommandResponse = ExecCommandLine_StdOut(strCommandLine, 30)
   FoundTTL = InStr(1, strCommandResponse, "TTL=") > 0
'   Debug.Print "Ping for " & strComputerName & ": " & FoundTTL
   
   ComputerIsAlive = FoundTTL
End Function

Public Function ExecCommandLine_StdOut(CommandLine As String, Optional Timeout_sec As Single = 30, Optional StartInDirectory As String = "") As String
   Dim strStdOut As String, strStdErr As String
   Dim retval As String

   If ExecCommandLine_StdOutAndErr(Command, strStdOut, strStdErr, StartInDirectory, Timeout_sec) Then
      retval = strStdOut
   Else
      retval = "TIMEOUT"
   End If
   ExecCommandLine_StdOut = retval
End Function

Public Function ExecCommandLine_StdOutAndErr(CommandLine As String, ByRef strStdOut As String, ByRef strStdErr As String, _
                                 Optional StartInDirectory As String = "", Optional Timeout_sec As Single = 30) As Boolean
   Dim wshShl As IWshRuntimeLibrary.WshShell
   Dim oExec As IWshRuntimeLibrary.WshExec
   Dim datTimeout  As Date
   Dim retval As Boolean

   Set wshShl = New IWshRuntimeLibrary.WshShell  'or can do: Set wshShl = CreateObject("WScript.Shell")

   If StartInDirectory <> "" Then
      wshShl.CurrentDirectory = StartInDirectory
   End If

   Set oExec = wshShl.Exec(CommandLine)

   datTimeout = DateAdd("s", Timeout_sec, Now())
   Do While (oExec.Status = 0) And (Now() < datTimeout)
      Sleep 100
      DoEvents
   Loop

   If Now() < datTimeout Then
      strStdOut = oExec.StdOut.ReadAll
      strStdErr = oExec.StdErr.ReadAll
      retval = True
   Else
      retval = False
   End If
   
   ExecCommandLine_StdOutAndErr = retval

End Function


Public Function RunCommandLine_Synchronous(CommandLine As String, Optional StartInDirectory As String = "", _
         Optional WindowStyle As eRunCommand_WindowStyle = eRunCommand_WindowStyle.RestoreOrDisplay_Activate, _
         Optional WaitForFinish As Boolean = True) As Long


   Dim wshShl As IWshRuntimeLibrary.WshShell
   Dim retval As Long

   Set wshShl = New IWshRuntimeLibrary.WshShell  'or can do: Set wshShl = CreateObject("WScript.Shell")

   If StartInDirectory <> "" Then
      wshShl.CurrentDirectory = StartInDirectory
   End If

   retval = wshShl.Run(CommandLine, WindowStyle, WaitForFinish)

   RunCommandLine_Synchronous = retval


End Function

Public Function OpenFileDialog(Optional FileTypeFilters As Scripting.Dictionary = Nothing, _
            Optional DialogTitle As String = "") As String

#If OfficeVersion >= 10 Then
      OpenFileDialog = OpenFileDialog_10(FileTypeFilters, DialogTitle)

#Else
      OpenFileDialog = OpenFileDialog_9(FileTypeFilters, DialogTitle)

#End If


End Function

Public Sub Clipboard_SetText(strText As String)
    'VBA Macro using late binding to copy text to clipboard.
    'By Justin Kay, 8/15/2014
    Dim MSForms_DataObject As Object
    Set MSForms_DataObject = CreateObject("new:{1C3B4210-F441-11CE-B9EA-00AA006B1A69}")
    MSForms_DataObject.SetText strText
    MSForms_DataObject.PutInClipboard
    Set MSForms_DataObject = Nothing
End Sub

Public Function OpenFileDialog_10(Optional FileTypeFilters As Scripting.Dictionary = Nothing, _
            Optional DialogTitle As String = "", Optional OpenMode As Long) As String
'Public Function OpenFileDialog(Optional FileTypeFilters As Office.FileDialogFilters = Nothing, _
            Optional DialogTitle As String = "", Optional OpenMode As MsoFileDialogType = MsoFileDialogType.msoFileDialogOpen) As String
   Dim strTemp As String
'   Dim flt As Office.FileDialogFilter
'   Dim flt As clsOpenFileDialog_2000_FileFilter


#If OfficeVersion >= 10 Then

   Dim dlg As FileDialog
   Set dlg = Application.FileDialog(OpenMode)

   Dim i As Integer, strDescription As String, strExtensions As String

   With dlg
      .AllowMultiSelect = False
      If DialogTitle <> "" Then
         .Title = DialogTitle
      End If

      If FileTypeFilters Is Nothing Then
         .Filters.Clear
      Else
         For i = 0 To FileTypeFilters.Count - 1
'            .Filters.Add flt.Description, flt.Extensions
            strDescription = FileTypeFilters.Keys(i)
            strExtensions = FileTypeFilters.Item(strDescription)
            .Filters.Add strDescription, strExtensions
         Next i
      End If

      If .Filters.Count > 0 Then
         .FilterIndex = 1
      End If
      ' Display the File Dialog
      If dlg.Show Then
         OpenFileDialog_10 = .SelectedItems(1)
      Else
         OpenFileDialog_10 = ""
      End If
   End With
#End If

End Function

'
'Public Function OpenFileDialog_9(Optional FileTypeFilters As Collection = Nothing, Optional DialogTitle As String = "") As String
'
'#If OfficeVersion < 10 Then
'
'
'   Dim dlg As New clsOpenFileDialog_2000
'
'   Dim strFilter As String
'   Dim lngFlags As Long
'   Dim strFileNameSelected As String
'   Dim i As Integer, strDescription As String, strExtensions As String
'
'   If Not FileTypeFilters Is Nothing Then
'      For i = 0 To FileTypeFilters.Count - 1
'         strDescription = FileTypeFilters.Keys(i)
'         strExtensions = FileTypeFilters.Item(strDescription)
'         strFilter = dlg.ahtAddFilterItem(strFilter, strDescription & " (" & strExtensions & ")", strExtensions)
'      Next i
'   End If
'
'   lngFlags = 0
'
'   strFileNameSelected = dlg.ahtCommonFileOpenSave(Filter:=strFilter, Flags:=lngFlags, DialogTitle:=DialogTitle)
'
''   strFilenameSelected = dlg.ahtCommonFileOpenSave(InitialDir:="C:\", _
''   Filter:=strFilter, FilterIndex:=3, Flags:=lngFlags, _
''   DialogTitle:="Hello! Open Me!")
'
'    OpenFileDialog_9 = strFileNameSelected
'
'#End If
'
'End Function



Public Function CDbl_PeriodDecimalSeperator(strValue As String) As Double
   'the idea here is to process a string which contains a "." as the decimal separator,
   ' and replace the "." with the local decimal separator, in order to ensure that the CDbl()
   ' function works correctly
   Const ThisProcName As String = "CDbl_PeriodDecimalSeperator"

   Dim decimal_sep_local As String
   Dim strValue_Localized

   decimal_sep_local = Mid(CStr(11 / 10), 2, 1)
   strValue_Localized = Replace(strValue, ".", decimal_sep_local, , 1)
   
   If IsNumeric(strValue_Localized) Then
      CDbl_PeriodDecimalSeperator = CDbl(strValue_Localized)
   Else
      Err.Raise vbObjectError + 512, ThisModName & ":" & ThisProcName, "Not a numeric value: " & strValue_Localized
   End If
End Function

Public Function CBool_English(strBool As String) As Boolean
   CBool_English = (LCase(Trim(strBool)) = "true")
End Function
Public Function CBool_Local(strBool As String) As Boolean
   Dim strTrue_Local As String
   strTrue_Local = CStr(CBool(True))
   CBool_Local = (LCase(Trim(strBool)) = LCase(Trim(strTrue_Local)))
End Function




Public Function PathShortName(ByVal LongName As String, Optional ByVal IsFolder As Boolean = False) As String
   'returns the 8-character path for a given folder or file path
'    Dim fso As Object, fl As Object
'   Set fso = CreateObject("scripting.filesystemobject")
   Dim fso As New Scripting.FileSystemObject
   Dim fil As Scripting.File

   If IsFolder Then
       PathShortName = fso.GetFolder(LongName).ShortPath
   Else
       Set fil = fso.GetFile(LongName)
       PathShortName = fil.ShortPath '& "\" & fil.ShortName
   End If
   Set fso = Nothing
   Set fil = Nothing
End Function

Public Function WriteTextFile(strFilename As String, FileContent As String) As Boolean
   Dim fso As New IWshRuntimeLibrary.FileSystemObject
   Dim strmOut As TextStream

   Set strmOut = fso.CreateTextFile(strFilename, True)

   strmOut.Write FileContent
   strmOut.Close

   Set fso = Nothing
   Set strmOut = Nothing
End Function

Public Function FileExists(strFilename As String) As Boolean
   Dim fso As New IWshRuntimeLibrary.FileSystemObject
   FileExists = fso.FileExists(strFilename)
   Set fso = Nothing
End Function



Public Sub SaveRecordsetAsText(rs As ADODB.Recordset, OutStream As Scripting.TextStream, _
         Optional Delimiter As String = vbTab, Optional OutputHeaderLine As Boolean = True)
   'the text stream must be open for write or append

   Dim fld As ADODB.Field
   Dim s As Scripting.TextStream
   Dim i As Integer, PastFirst As Boolean

   Set s = OutStream

   If OutputHeaderLine Then
      PastFirst = False
      For Each fld In rs.Fields
         s.Write IIf(PastFirst, Delimiter, "") & fld.Name
         PastFirst = True
      Next fld
      s.WriteLine
   End If


   Do Until rs.EOF
      PastFirst = False
      For Each fld In rs.Fields
         s.Write IIf(PastFirst, Delimiter, "") & CStr(Nz(fld.value, ""))
         PastFirst = True
      Next fld
      s.WriteLine
      rs.MoveNext
   Loop


End Sub

Public Function ReadTextFile(Filename As String) As String
   Dim strFile As String
   Dim fso As New Scripting.FileSystemObject
   Dim strm As Scripting.TextStream

   Set strm = fso.OpenTextFile(Filename, ForReading)

   ReadTextFile = strm.ReadAll
   strm.Close
   Set fso = Nothing
End Function

Public Function CreateTempFile(ByRef OutFilename As String) As Scripting.TextStream
   'returns an open text stream, created in the users temp directory, with timestamp for name

   Dim strm As Scripting.TextStream
   Dim fso As New Scripting.FileSystemObject

   Dim Filename As String
   Filename = Environ("TEMP")
   
   Filename = Filename & "\" & Format(Now(), "yyyymmdd_hhnnss") & ".txt"

   OutFilename = Filename

   Set strm = fso.OpenTextFile(Filename, ForWriting, True)

   Set CreateTempFile = strm
   Set fso = Nothing

End Function


Public Function StringSimilarityJoin(strQuery As String, TargetTableName As String, TargetFieldName As String, _
      Optional ReturnFieldName As String = "", Optional MinValForMatch As Double = 0) As String
   'Given a query string, searches in the target table for the most similar value in the field TargetFieldName
   'The return value is either the best matching value in TargetFieldName; or, if ReturnFieldName is specified,
   ' returns the value of that field from the row that had the best match
   
   Dim strSQL As String
   Dim rs As New ADODB.Recordset
   Dim BestMatchScore As Double, BestMatchValue As String, BestMatchReturnValue As String
   Dim ThisMatchScore As Double, ThisMatchValue As String

   strSQL = "SELECT [" & TargetFieldName & "] " & IIf(ReturnFieldName <> "", ",[" & ReturnFieldName & "] ", "") & _
            "FROM [" & TargetTableName & "]"
   rs.Open strSQL, Application.CurrentProject.Connection, adOpenStatic, adLockReadOnly
   
   With rs
      Do Until .EOF Or BestMatchScore = 1
         ThisMatchValue = Nz(.Fields(TargetFieldName), "")
         ThisMatchScore = StringSimilarity(strQuery, ThisMatchValue)
         If (ThisMatchScore > BestMatchScore) And (ThisMatchScore >= MinValForMatch) Then
            BestMatchScore = ThisMatchScore
            BestMatchValue = ThisMatchValue
            If ReturnFieldName <> "" Then
               BestMatchReturnValue = CStr(Nz(.Fields(ReturnFieldName), ""))
            End If
         End If
         .MoveNext
      Loop
   End With

   If ReturnFieldName <> "" Then
      StringSimilarityJoin = BestMatchReturnValue
   Else
      StringSimilarityJoin = BestMatchValue
   End If
End Function

Public Function StringSimilarity(strQuery As String, strTarget As String) As Double
   'returns a value 0 to 1 indicating the amount of similarity between the two strings.
   
   'Similarity is based upon the number of identical characters between the two.
   'Both strings are converted to lower case for the comaprison

   Dim i As Long
   Dim strQ As String, strT As String
   Dim max_len As Long, min_len As Long
   Dim count_identical As Long

   strQ = LCase(strQuery)
   strT = LCase(strTarget)
   max_len = Max(Len(strQ), Len(strT))
   min_len = Min(Len(strQ), Len(strT))

   If max_len > 0 Then
      For i = 1 To min_len
         If Mid(strQ, i, 1) = Mid(strT, i, 1) Then
            count_identical = count_identical + 1
         End If
      Next i
      StringSimilarity = count_identical / max_len
   Else
      StringSimilarity = 0
   End If
End Function



Public Sub BubbleSort(ByRef arr() As Double, Optional SortAscending As Boolean = True)

   Dim tmp As Double
   Dim test As Boolean

   Dim i As Integer, j As Integer


   For i = UBound(arr) - 1 To LBound(arr) Step -1
      For j = 0 To i
         If SortAscending Then
            test = arr(j) > arr(j + 1)
         Else
            test = arr(j) < arr(j + 1)
         End If
         If test Then
            tmp = arr(j)
            arr(j) = arr(j + 1)
            arr(j + 1) = tmp
         End If
      Next j
   Next i
End Sub


Public Function LogFileTimestamp(Optional FormatName As String = "") As String
   Dim strTimestamp As String
   Dim datNow As Date
   datNow = Now
   
   Select Case FormatName
      Case "", "General"   'like 10-Nov-2017 10:04:20
         strTimestamp = Format(datNow, "dd-MMM-yyyy HH:mm:ss")
      Case "Filename"
         strTimestamp = Format(Now, "yyyymmdd_HHMMSS")
   End Select
   
   LogFileTimestamp = strTimestamp
End Function

Public Function Environ_SpecialFolder(SpecialFolder As eSpecialFolders) As String

#If Office_64bit Then
    Dim lRet As LongPtr, IDL As ITEMIDLIST, sPath As String
    lRet = SHGetSpecialFolderLocation(100&, CLng(SpecialFolder), IDL)
    If lRet = 0 Then
        sPath = String$(512, Chr$(0))
        lRet = SHGetPathFromIDList(ByVal IDL.mkid.cb, ByVal sPath)
        Environ_SpecialFolder = Left$(sPath, InStr(sPath, Chr$(0)) - 1)
    Else
        Environ_SpecialFolder = vbNullString
    End If

#Else
    Dim lRet As Long, IDL As ITEMIDLIST, sPath As String
    lRet = SHGetSpecialFolderLocation(100&, CLng(SpecialFolder), IDL)
    If lRet = 0 Then
        sPath = String$(512, Chr$(0))
        lRet = SHGetPathFromIDList(ByVal IDL.mkid.cb, ByVal sPath)
        Environ_SpecialFolder = Left$(sPath, InStr(sPath, Chr$(0)) - 1)
    Else
        Environ_SpecialFolder = vbNullString
    End If

#End If
End Function


Public Sub LogFile_AppendLine(Filename As String, LogLine As String)
   Dim strm As Scripting.TextStream
   
   If Filename <> "" Then
      Dim fso As New Scripting.FileSystemObject
      Set strm = fso.OpenTextFile(Filename, ForAppending, True)
      strm.WriteLine LogLine
      strm.Close
      Set fso = Nothing
   End If
End Sub
----------- end of component
Component: modAccessUtilities; Standard module
Option Compare Database
Option Explicit

'#Const Include_DDL_Functions = True

Public Enum eDBOperation
   opSelect = 1 'these values must reflect those on table DB_Operation
   opInsert = 2
   opUpdate = 3
   opDelete = 4
End Enum

Private m_Application_Version As Single

Public Function Application_Version() As Single
   Dim strApplication_Version As String

   'Access 2003 = "10.0", Access 2000 = "9.0"

   If m_Application_Version = 0 Then 'on first use, determine Access version
      strApplication_Version = "9.0"  'by default, set to 9
      On Error Resume Next
#If OfficeVersion > 9 Then
      strApplication_Version = Application.Version  'Version 9 does not support the Version property
#Else
    strApplication_Version = "9.0"
#End If

      On Error GoTo 0

      If IsNumeric(strApplication_Version) Then
         m_Application_Version = CDbl_PeriodDecimalSeperator(strApplication_Version)
      Else
         MsgBox "Cannot determine version of Access.  Cannot proceed until this problem is resolved.  See modAccessUtilities.Application_Version()"
         Quit acQuitPrompt
      End If
   
   End If

   Application_Version = m_Application_Version
End Function

'#If Not Application_Version = "10.0" Then
'Public Function Replace(Expression As String, FindString As String, ReplaceWith As String, Optional Start As Long = 1, _
'                     Optional Count As Long = -1, Optional Compare As VbCompareMethod = VbCompareMethod.vbBinaryCompare) As String
'
'    Replace = VBA.Replace(Expression, FindString, ReplaceWith, Start, Count, Compare)
'
'End Function
'
'Public Function VB_InStrRev(StringCheck As String, StringMatch As String, _
'         Optional Start As Long = -1, Optional CompareMethod As VbCompareMethod = vbBinaryCompare)
'   VB_InStrRev = VBA.InStrRev(StringCheck, StringMatch, Start, CompareMethod)
'End Function
'
'#End If

Public Function ForceCurrentUserPrompt()
   DoCmd.OpenForm "CurrentUser", acNormal, , , acFormAdd, acDialog
   DoEvents

End Function

Public Function CurrentUserID() As Long
   Dim rs As New ADODB.Recordset
   Dim lastEntryID As Long
   Dim UserID As Long
   Dim LatestEntryIsValid As Boolean
   UserID = -1
   
   rs.Open "SELECT TOP 1 CurrentUser.* FROM CurrentUser ORDER BY CurrentUser.EntryID DESC", CurrentProject.Connection, adOpenStatic, adLockOptimistic
   If Not (rs.EOF) Then
      lastEntryID = rs![EntryID]
      LatestEntryIsValid = (DateDiff("h", CDate(rs![EntryDate]), Now()) < 12)
   End If

   If LatestEntryIsValid Then
      UserID = rs![CurrentUserID]
   Else 'too old, ask who they are
      DoCmd.OpenForm "CurrentUser", acNormal, , , acFormAdd, acDialog
      DoEvents

      'ok, check again to see what they entered
      rs.Close
      rs.Open "SELECT TOP 1 CurrentUser.* FROM CurrentUser ORDER BY CurrentUser.EntryID DESC", CurrentProject.Connection, adOpenStatic, adLockOptimistic
      If lastEntryID <> rs![EntryID] Then 'if they click 'Cancel' the last entry will still be the same
         UserID = rs![CurrentUserID]
      End If
   End If

   rs.Close

   CurrentUserID = UserID  'will be -1 if they canceled
End Function

Public Function CountUniqueItems(strRecordSource As String, CountThisField As String, CounterField As String) As Boolean
   Dim db As DAO.Database
   Dim rs As DAO.Recordset
   
   Dim CurrentCounter As Long
   Dim LastItem As Variant, CurrentItem As Variant
   
   Set db = CurrentDb
   Set rs = db.OpenRecordset(strRecordSource, dbOpenDynaset)
   
   LastItem = 0
   CurrentCounter = 0
   With rs
      Do Until .EOF
         CurrentItem = .Fields(CountThisField).value
         If (CurrentItem <> LastItem) Or (CurrentCounter = 0) Then
            CurrentCounter = CurrentCounter + 1
         End If
         .Edit
         .Fields(CounterField).value = CurrentCounter
         .Update
         
         LastItem = CurrentItem
         .MoveNext
      Loop
   End With
   
End Function


Public Function CountIterationsOfItems(strRecordSource As String, CountThisField As String, CounterField As String) As Long
   'strRecordSource should be a SQL statement that provides a sorted recordset containing a field to count, and
   ' a field into which to put the count.
   'The function iterates the recordset; each time it sees a new value in the "CountThisField" field, it increments
   '  the counter; each time it sees a new value in the "CountThisField" field the counter is reset to 1.
   'The counter value is placed into the "CounterField" field for each record

   'Returns the number of groups that were found
 
   Dim db As DAO.Database
   Dim rs As DAO.Recordset
   
   Dim CurrentCounter As Long
   Dim LastItem As Variant, CurrentItem As Variant
   Dim GroupCount As Long

   Set db = CurrentDb
   Set rs = db.OpenRecordset(strRecordSource, dbOpenDynaset)
   
   LastItem = 0
   CurrentCounter = 0
   GroupCount = 1

   With rs
      Do Until .EOF
         CurrentItem = .Fields(CountThisField).value
         If (CurrentItem = LastItem) Or (CurrentCounter = 0) Then
            CurrentCounter = CurrentCounter + 1
         Else
            CurrentCounter = 1
            GroupCount = GroupCount + 1
         End If
         .Edit
         .Fields(CounterField).value = CurrentCounter
         .Update
         
         LastItem = CurrentItem
         .MoveNext
      Loop
   End With
   
   rs.Close
   Set rs = Nothing

   CountIterationsOfItems = GroupCount
End Function

Public Function NVL(OriginalValue As Variant, NullReplaceValue As Variant) As Variant
   'replicates functionality of Oracle NVL function --
   '   if the value supplied is Not Null, returns the value
   '   if the value supplied is     Null, returns the NullReplaceValue
   
   If IsNull(OriginalValue) Then
      NVL = NullReplaceValue
   Else
      NVL = OriginalValue
   End If
   
   
End Function


Public Function cboList_Tables(fld As Control, ID As Variant, Row As Variant, col As Variant, _
     code As Variant) As Variant
  'use as a combo-box row source to list all tables in the current database
    Static TableNames(0 To 255) As String, Entries As Integer, i As Integer
    Dim ReturnVal As Variant
    Dim db As DAO.Database
    
    ReturnVal = Null
    
    Select Case code
        Case acLBInitialize                ' Initialize.
            Set db = CurrentDb
            Entries = modUtility.Min(db.TableDefs.Count, 255)  'only display up to 255 tables
         
            For i = 0 To Entries - 1
               TableNames(i) = db.TableDefs(i).Name
            Next i
            ReturnVal = Entries
        Case acLBOpen                        ' Open.
            ' Generate unique ID for control.
            ReturnVal = Timer
        Case acLBGetRowCount            ' Get number of rows.
            ReturnVal = Entries
        Case acLBGetColumnCount    ' Get number of columns.
            ReturnVal = 1
        Case acLBGetColumnWidth    ' Column width.
            ' -1 forces use of default width.
            ReturnVal = -1
        Case acLBGetValue                    ' Get data.
            ReturnVal = TableNames(Row)
        Case acLBEnd                        ' End.
            Erase TableNames
    End Select
    cboList_Tables = ReturnVal
End Function

Public Sub BumpAutoNumber(TableName As String, ID_FieldName As String, SurpassID As Long)

   Dim rs As DAO.Recordset
   Dim newID As Long
   
   
   Set rs = CurrentDb.OpenRecordset(TableName, dbOpenDynaset)
   
   Do
      rs.AddNew
      newID = rs.Fields(ID_FieldName)
      rs.CancelUpdate
      If (newID Mod 100000) = 0 Then
         Debug.Print newID
      End If
   Loop Until (newID > SurpassID)

End Sub


Public Sub PrintTables()
   Dim db As DAO.Database, tbl As DAO.TableDef
   
   Set db = CurrentDb
   
   For Each tbl In db.TableDefs
      If (tbl.Attributes And dbAttachedTable) Or (tbl.Attributes And dbAttachedODBC) Then
         Debug.Print tbl.Name
         
      End If
   Next tbl
End Sub

Public Function StrToHex(X As String) As String
Dim i As Long, temp As String
  temp = Space$(Len(X) * 2)
  For i = 1 To Len(X)
    Mid$(temp, i * 2 - 1, 2) = Right$("0" & Hex$(Asc(Mid$(X, i, 1))), 2)
  Next i
  StrToHex = temp
End Function

Public Function WellToRowCol(WellNumber As Long, Optional strFormat As String = "Rc", _
                              Optional PlateType As Integer, Optional Rows As Integer = 8, _
                              Optional Columns As Integer = 12) As String
                                 
   'Converts a well number to a Row/Column string representation.
   'By defaults, converts to a RowLetter/Column number, assuming a 96-well plate
   'For example, converts WellNumber=13 to "B1".
   
   'Assumes WellNumber is 1-based, row-major index
   
   'User can specify a format string that is interpreted as follows:
   
   ' R : row in upper-case letter format A...Z, AA, AB, etc.; specifying multiple 'R' causes leading blank
   ' r : row in numeric format; specifying multiple 'r' causes leading zeroes
   ' c : column in numeric format; specifying multiple 'c' causes leading zeroes
   
   'all other chars are put into the final string as literals
   'use a '\' preceeding any single character for literal of any of the recognized format characters
   'For example, given WellNumber=14, the following format strings produce these outputs
   '     strFormat       Result
   '     Rc              B2
   '     Rcc             B02
   '     \R:R \C:cc      R:B C:02
   
   'Not fully implemented yet ... only does the very simplest conversion
   
   Const ThisProcName = "WellToRowCol"
   Dim thisRow As Long, thisCol As Long
   Dim CapA As Integer
   
   thisRow = Int((WellNumber - 1) / Columns)  'note: both of these calculated indices are 0-based
   thisCol = WellNumber - thisRow * Columns - 1
   
   If (thisRow >= Rows) Or (thisCol >= Columns) Then
      Err.Raise vbObjectError, ThisProcName, "Well number out of range: " & CStr(WellNumber)
   End If
   
   CapA = Asc("A")
   
   If strFormat = "Rc" Then
      WellToRowCol = Chr(CapA + thisRow) & CStr(thisCol + 1)
   ElseIf strFormat = "Rcc" Then
      WellToRowCol = Chr(CapA + thisRow) & Format(thisCol + 1, "00")
   Else
      Err.Raise vbObjectError, ThisProcName, "Does not yet support user-defined format strings"
   End If
   
End Function

Public Function IsOpen(strName As String, _
         Optional ObjectType As AcObjectType = acForm) As Boolean
            
   'found this function syntax in Access 2000 Developer's Handbook, pg. 490
   
   IsOpen = (SysCmd(acSysCmdGetObjectState, ObjectType, strName) <> 0)
         
'Constant         State of database object   Value
'acObjStateOpen   Open                       1
'acObjStateDirty  Changed but not saved      2  'for Forms, means that there is a Design change that is not saved
'acObjStateNew    New                        4
'Note   If the object referred to by the objectname argument is either not open or doesn't exist, the SysCmd method returns a value of zero.
         
         
End Function


#If Include_DDL_Functions Then


Public Sub rename_tables()

   Dim cat As New ADOX.Catalog
   Dim tbl As ADOX.Table
   
   Set cat.ActiveConnection = CurrentProject.Connection
   
   For Each tbl In cat.Tables
      If Right(tbl.Name, 6) = "_local" Then
         tbl.Name = Left(tbl.Name, Len(tbl.Name) - 6)
      End If
   Next tbl
End Sub



Public Sub drop_tables()

   Dim cat As New ADOX.Catalog
   Dim tbl As ADOX.Table
   
   Set cat.ActiveConnection = CurrentProject.Connection
   
   For Each tbl In cat.Tables
      If Right(tbl.Name, 6) = "_local" Then
         cat.Tables.Delete tbl.Name
         Set tbl = Nothing
      End If
   Next tbl
End Sub


Function ChangeSeed(strTbl As String, strCol As String, lngSeed As Long) As Boolean
'from http://support.microsoft.com/?kbid=287756
'must reference both the Microsoft ActiveX Data Objects 2.x and the Microsoft ADO Ext 2.x for DDL and Security Libraries

'You must pass the following variables to this function.
'strTbl = Table containing autonumber field
'strCol = Name of the autonumber field
'lngSeed = Long integer value you want to use for next AutoNumber.

Dim cnn As ADODB.Connection
Dim cat As New ADOX.Catalog
Dim col As ADOX.Column

'Set connection and catalog to current database.
Set cnn = CurrentProject.Connection
cat.ActiveConnection = cnn

Set col = cat.Tables(strTbl).Columns(strCol)

col.Properties("Seed").value = lngSeed
cat.Tables(strTbl).Columns.Refresh
If col.Properties("seed") = lngSeed Then
    ChangeSeed = True
Else
    ChangeSeed = False
End If
Set col = Nothing
Set cat = Nothing
Set cnn = Nothing

End Function


#End If

Public Sub CreateLocalCopiesOfLinkedTables(Optional ODBC_Linked_Only As Boolean = False)

   Dim tbl As DAO.TableDef, LinkedTableName As String, LocalTableName As String
   Dim qdf As DAO.QueryDef, strSQL As String
   Dim db As DAO.Database
   
   
  
   Set db = CurrentDb
   For Each tbl In db.TableDefs
      If (tbl.Attributes And dbAttachedODBC) Or (tbl.Attributes And dbAttachedTable And (Not ODBC_Linked_Only)) Then
         LinkedTableName = tbl.Name
         LocalTableName = LinkedTableName & "_Local"
         strSQL = "SELECT [" & LinkedTableName & "].* INTO [" & LocalTableName & "] FROM [" & LinkedTableName & "];"
         Set qdf = db.CreateQueryDef("", strSQL)
         Debug.Print "Creating table: " & LocalTableName
         qdf.Execute
         Set qdf = Nothing
      
      End If
   Next tbl
End Sub


Public Function ExtractTableName(strSQL, strKeyword) As String
   'the strKeyword should be something like " INTO " or " FROM "

   Dim Pos_Keyword As Integer, Pos_NextChar As Integer
   Dim Pos_TableName As Integer
   Dim NextIsDelimiter As Boolean, NextChar As String, ThisTableName As String, ChangeChar As Boolean
   Dim i As Integer
   

   'first replace any CR, LF, Tab with spaces; also put a space before a terminal semicolon
   For i = 1 To Len(strSQL)
      NextChar = Mid(strSQL, i, 1)
      ChangeChar = True
      Select Case NextChar
         Case vbCr, vbLf, vbTab: NextChar = " "
         Case ";": NextChar = " ;"
         Case Else
            ChangeChar = False
      End Select
      If ChangeChar Then
         Mid(strSQL, i) = NextChar
         i = i + Len(NextChar) - 1
      End If
   Next i
   
   
   Pos_Keyword = InStr(1, strSQL, strKeyword, vbTextCompare)
   Pos_TableName = Pos_Keyword + Len(strKeyword) - 1
   Do
      NextChar = Mid(strSQL, Pos_TableName, 1)
      NextIsDelimiter = ((NextChar = " ") Or (NextChar = vbCr) Or (NextChar = vbLf))
      If NextIsDelimiter Then
         Pos_TableName = Pos_TableName + 1
      End If
   Loop Until Not NextIsDelimiter
   
   If NextChar = "[" Then
      ThisTableName = Trim(Mid(strSQL, Pos_TableName, InStr(Pos_TableName + 1, strSQL, "]", vbBinaryCompare) - Pos_TableName + 1))
      ThisTableName = Mid(ThisTableName, 2, Len(ThisTableName) - 2)
   Else
      ThisTableName = Trim(Mid(strSQL, Pos_TableName, InStr(Pos_TableName + 1, strSQL, " ", vbBinaryCompare) - Pos_TableName))
   End If


   ExtractTableName = ThisTableName
End Function


Public Function GetQuerySQL(QueryName As String) As String
   'Returns the SQL of a stored query.
   'Useful for queries that are based upon tables that have been deleted/renamed.  If you open
   '  those queries in the Design view, Access will break Joins, alias all of the fields that is doesn't
   '  recognize, etc.  If all you really need to do is rename one of the source tables, this function
   '  allows you to get at the original SQL.
   
   Dim qdf As DAO.QueryDef
   Dim strQueryName As String, strFilename As String
   Dim f As Integer, DumpToFile As Boolean
   Dim PauseCounter As Integer
   
   If QueryName = "" Then
      strQueryName = InputBox("Query name to examine.  Type 'All' to list all to the Debug window.")
   Else
      strQueryName = QueryName
   End If
   
   If strQueryName = "All" Then
      strFilename = InputBox("Dump to file?  If so, enter filename.", , "")
      If strFilename <> "" Then
         f = FreeFile
         Err.Clear
         On Error Resume Next
         Open strFilename For Output As f
         If Err.Number = 0 Then
            DumpToFile = True
         Else
            MsgBox "Error opening output file: " & Err.Description
            Exit Function
         End If
         On Error GoTo 0
      End If
   End If
   
   If strQueryName <> "All" Then
      
      Set qdf = CurrentDb.QueryDefs(strQueryName)
      MsgBox qdf.SQL
      Debug.Print qdf.SQL
   Else
      For Each qdf In CurrentDb.QueryDefs
         If Left(qdf.Name, 1) <> "~" Then
            Debug.Print qdf.Name
            Debug.Print qdf.SQL
            If DumpToFile Then
               Print #f, qdf.Name
               Print #f, qdf.SQL
            End If
            PauseCounter = PauseCounter + 1
            If PauseCounter >= 40 Then
               DoEvents  'put a breakpoint here
               PauseCounter = 0
            End If
         End If
      Next qdf
   End If
   
   If DumpToFile Then Close f
End Function

Public Sub GetQuerySQL_Interactive()
   Call GetQuerySQL("")
End Sub

Public Function GetSettingValue_OLD(SettingName As String, _
                     Optional SettingsTableName As String = "", Optional AllowSymbolSubstitution As Boolean = True) As String

   'Supports these replaceable symbols in the setting string (not case sensitive):
   '$(AppPath)  The path of the executing project/MDB/MDE/EXE  for example:    ;DATABASE=$(AppPath)\SynthesisPipeline_LocalSettings.mdb
   '$(WinDir)   typically c:\winnt or c:\windows
   '$(Temp)     for example C:\DOCUME~1\eysce\IMPOST~1\Temp
   '$(HomeFolder)  typically H:\
   '$(ProgramFiles)
   '$(Desktop)
   '$(Setting:setting_name)   -- this does a recursive call to look up the specified setting value


   Dim rs As DAO.Recordset
   Dim strSettingsTable As String, strSQL As String, strSettingValue As String
   
   If SettingsTableName = "" Then
      strSettingsTable = "DatabaseSettings"
   Else
      strSettingsTable = SettingsTableName
   End If
   
   strSQL = "SELECT SettingValue,IsNumeric FROM [" & strSettingsTable & "] " & _
            "WHERE SettingName='" & SettingName & "';"
            
   Set rs = CurrentDb.OpenRecordset(strSQL, dbOpenSnapshot)
   
   If Not rs.EOF Then
      If IsNull(rs![SettingValue]) Then
         strSettingValue = ""
      Else
         strSettingValue = rs![SettingValue]
      End If
   Else
      'if not found, raise an error
      Err.Raise vbObjectError, "GetSettingValue", "SettingName '" & SettingName & "' was not found."
   End If
   

   If AllowSymbolSubstitution Then
      Dim mat As VBScript_RegExp_55.Match, mats As VBScript_RegExp_55.MatchCollection
      Dim wsh As New IWshRuntimeLibrary.WshShell
      Dim wEnv As IWshRuntimeLibrary.WshEnvironment
      Dim strSubstituteSymbol As String, strSubstituteValue As String, strSettingSubstituteName As String
      
      Set wEnv = wsh.Environment
      Set mats = modUtility.RegEx_ExtractMatches(strSettingValue, "\$\((.+)\)")

      Do Until mats.Count = 0
         Set mat = mats.Item(0)
         If mat.SubMatches(0) Like "setting:*" Then
            strSubstituteSymbol = "setting"
            strSettingSubstituteName = Mid(mat.SubMatches(0), Len("setting:") + 1)
         Else
            strSubstituteSymbol = LCase(mats(0).SubMatches(0))
         End If

         Select Case strSubstituteSymbol
            Case "apppath"
               strSubstituteValue = CurrentProject.Path
            Case "windir"
               strSubstituteValue = wsh.ExpandEnvironmentStrings(wEnv.Item("WINDIR"))
            Case "temp"
               strSubstituteValue = wsh.ExpandEnvironmentStrings(wEnv.Item("TEMP"))
            Case "homefolder"
               strSubstituteValue = wsh.ExpandEnvironmentStrings(wEnv.Item("HOMEDRIVE") & wEnv.Item("HOMEPATH"))
            Case "desktop"
               strSubstituteValue = wsh.ExpandEnvironmentStrings(wsh.SpecialFolders("Desktop"))
            Case "programfiles"
               strSubstituteValue = wsh.ExpandEnvironmentStrings(Environ("ProgramFiles"))
            Case "setting"
               strSubstituteValue = GetSettingValue_OLD(strSettingSubstituteName, SettingsTableName, AllowSymbolSubstitution)

            Case Else
               Err.Raise vbObjectError, "GetSettingValue_OLD", "In Setting '" & SettingName & "' did not recognize the replaceable symbol '" & _
                     mat.value & "' in the setting value: " & rs![SettingValue]
         End Select

         strSettingValue = Left(strSettingValue, mat.FirstIndex) & strSubstituteValue & Mid(strSettingValue, mat.FirstIndex + 1 + mat.Length)

         Set mats = modUtility.RegEx_ExtractMatches(strSettingValue, "(/$/(.+?/))")
      Loop
   End If

   If CBool(rs![IsNumeric]) Then
      'by definition, numeric values should be entered on table with "." separator.  This call will convert into local symbol.
      strSettingValue = CStr(modUtility.CDbl_PeriodDecimalSeperator(strSettingValue))
   End If
   
   

   Set rs = Nothing
   


   GetSettingValue_OLD = strSettingValue
End Function


Public Function qryExists(qryName As String) As Boolean
'    Dim thisDB As Database
'    Dim i As Integer
'
'    Set thisDB = CurrentDb()
'    qryExists = False
'    For i = 0 To thisDB.QueryDefs.count - 1
'        If (thisDB.QueryDefs(i).Name = qryName) Then
'         qryExists = True
'         Exit For
'      End If
'    Next i
'
   Dim thisDB As DAO.Database, qdf As DAO.QueryDef
   
   Set thisDB = CurrentDb()
   
   On Error Resume Next
   Set qdf = Nothing
   Set qdf = thisDB.QueryDefs(qryName)
   On Error GoTo 0
   qryExists = Not (qdf Is Nothing)

End Function


Public Function tblExists(tblName As String) As Boolean

'    Dim thisDB As Database
'    Dim i As Integer
    
'    Set thisDB = CurrentDb()
'    tblExists = 0
'    For i = 0 To thisDB.TableDefs.Count - 1
'        If (thisDB.TableDefs(i).Name = tblName) Then
'            tblExists = 1
'            Exit For
'        End If
'    Next i

   Dim tbl As DAO.TableDef
   
   Err.Clear
   On Error Resume Next
   Set tbl = CurrentDb.TableDefs(tblName)
   
   tblExists = (Err.Number = 0)
      

End Function

Public Function PrimaryKeyFieldName(TableName As String) As String
   Dim strPKFieldName As String
   Dim indx As DAO.index, indxPrimary As DAO.index, tdf As DAO.TableDef
   Dim db As DAO.Database

   Set db = Application.CurrentDb
   Set tdf = db.TableDefs(TableName)

   For Each indx In tdf.Indexes
      If indx.Primary Then
         Set indxPrimary = indx
         Exit For
      End If
   Next indx


   If Not (indxPrimary Is Nothing) Then
      If indxPrimary.Fields.Count = 1 Then
         strPKFieldName = indxPrimary.Fields(0).Name   'NOTE -- does not support tables with composite PK
      Else
         Err.Raise vbObjectError + 512, "PrimaryKeyFieldName", "The table " & TableName & " has a primary key composed of " & indxPrimary.Fields.Count & " fields, and thus you cannot use this simple function."
      End If
   Else
      strPKFieldName = ""
   End If

   PrimaryKeyFieldName = strPKFieldName
End Function

'For some reason this function does not work properly!  It finds the index properly, but it refuses to return the object correctly ... TF 18 Sep 2005
'Public Function PrimaryKeyIndex(TableName As String) As DAO.index
'   Dim indx As DAO.index, indxPrim As DAO.index, tdf As DAO.TableDef
'   Dim db As DAO.Database
'
'   Set db = Application.CurrentDb
'   Set tdf = db.TableDefs(TableName)
'
'   For Each indx In tdf.Indexes
'      If indx.Primary Then
'         Set indxPrim = indx
'         Exit For
'      End If
'   Next indx
'
'   Set PrimaryKeyIndex = indxPrim
'End Function

Public Sub BypassSet()

'-----------This subroutine allows you to prevent the use of the "shift" key to open a secure DB---------

Dim thisDB As Database
Dim prp As Property

Set thisDB = CurrentDb()

'Set prp = thisDB.CreateProperty("AllowBypassKey", dbBoolean, True)
'thisDB.Properties.Append prp

'thisDB.Properties("AllowBypassKey") = True
thisDB.Properties("AllowBypassKey") = False

thisDB.Close


End Sub



Public Function ParameterizedQuery_RecordSet(QueryName As String, Params As Scripting.Dictionary, _
               Optional RsType As Long = dbOpenDynaset, Optional RsOptions As Long = dbReadOnly) As DAO.Recordset
   Dim qdf As DAO.QueryDef
   Set qdf = CurrentDb.QueryDefs(QueryName)
   Dim rs As DAO.Recordset

   Dim i As Integer, strKey As String
   For i = 0 To Params.Count - 1
      strKey = Params.Keys(i)
      qdf.Parameters(strKey) = Params.Item(strKey)
   Next i

   Set rs = qdf.OpenRecordset(RsType, RsOptions)

   Set ParameterizedQuery_RecordSet = rs
End Function

Public Function ParameterizedQuery_RecordSet_ADO(QueryName As String, Params As Scripting.Dictionary, _
               Optional CursorType As ADODB.CursorTypeEnum = adOpenStatic, _
               Optional LockType As ADODB.LockTypeEnum = adLockReadOnly, _
               Optional CursorLocation As ADODB.CursorLocationEnum = adUseClient) As ADODB.Recordset
   'returns the number of records affected
   Dim cmd As New ADODB.Command
   Dim rs As ADODB.Recordset
   Dim p As ADODB.Parameter
   Dim lngRecordsAffected As Long

   Dim CursorLocation_Previous As ADODB.CursorLocationEnum

   Dim qdf As DAO.QueryDef
   Set qdf = CurrentDb.QueryDefs(QueryName)


   Set cmd.ActiveConnection = CurrentProject.Connection
   cmd.CommandText = QueryName
   cmd.CommandText = "SELECT * FROM (" & QueryName & ")"
'   cmd.CommandText = qdf.SQL
'   cmd.CommandType = adCmdUnknown    ' adCmdStoredProc
'   cmd.Prepared = True
   cmd.CommandType = adCmdText

'   cmd.Parameters.Refresh

   Do Until cmd.Parameters.Count = 0
      cmd.Parameters.Delete 0
   Loop

   Dim i As Integer, strKey As String
   For i = 0 To Params.Count - 1
      strKey = Params.Keys(i)
      Set p = cmd.CreateParameter(strKey, adInteger, adParamInput)
      p.value = Params.Item(strKey)
      'Set p = cmd.CreateParameter(strKey, adVarWChar, adParamInput, , params.Item(strKey))
      cmd.Parameters.Append p
      Set p = Nothing
   Next i
   
'   Set rs = cmd.Execute(lngRecordsAffected, , adOptionUnspecified)
   'NOTE WELL: using the Execute method to return a recordset will always return a Forward-only cursor
   ' which is not very useful for most things in Access.  Instead, pass the command object as the
   ' source for a recordset Open

   Set rs = New ADODB.Recordset
   CursorLocation_Previous = cmd.ActiveConnection.CursorLocation
   cmd.ActiveConnection.CursorLocation = CursorLocation
   rs.Open cmd, , CursorType, LockType
   'Debug.Print rs.CursorLocation

   'restore the previous setting so that future users of the connection will have the same cursor location as they had previously
   cmd.ActiveConnection.CursorLocation = CursorLocation_Previous

   Set cmd = Nothing
   
   Set ParameterizedQuery_RecordSet_ADO = rs
End Function

Public Function ParameterizedQuery_ExecuteAction(QueryName As String, Params As Scripting.Dictionary) As Long
   'returns the number of records affected
   Dim cmd As New ADODB.Command
   Dim p As ADODB.Parameter
   Dim lngRecordsAffected As Long

   Set cmd.ActiveConnection = CurrentProject.Connection
   cmd.CommandText = QueryName
   cmd.CommandType = adCmdUnknown  ' adCmdStoredProc

   Dim i As Integer, strKey As String
   For i = 0 To Params.Count - 1
      strKey = Params.Keys(i)
      Set p = cmd.CreateParameter(strKey, adBigInt, adParamInput, , Params.Item(strKey))
      cmd.Parameters.Append p
      Set p = Nothing
   Next i

   cmd.Execute lngRecordsAffected

   Set cmd = Nothing
   
   ParameterizedQuery_ExecuteAction = lngRecordsAffected
End Function

Public Sub HideShowFormColumns(frm As Access.Form, ColumnList() As String, _
                                HideTheseColumns As Boolean, IgnoreIfNotInList As Boolean)
   
   'ColumnList is names of columns to set
   'if HideTheseColumns=True, the columns in the list are hidden; if False, those columns are un-hidden
   'if IgnoreIfNotInList=True, then does nothing to columns not in the list; if False, sets them to the other status.

   Const conErrPropertyNotFound = 3270
   Dim ctrl As Control
   Dim prpColumnHidden As Property, prpControlSource As Property
   Dim DisplayThisColumn As Boolean, ColumnNameIsInList As Boolean
   Dim ColumnName As String

   Dim i As Integer, lb As Integer, ub As Integer

   On Error Resume Next
   lb = -1: ub = -1
   lb = LBound(ColumnList)
   ub = UBound(ColumnList)
   On Error GoTo 0


   For Each ctrl In frm.Controls
      On Error Resume Next
      Set prpColumnHidden = Nothing
      Set prpControlSource = Nothing
      Set prpControlSource = ctrl.Properties("ControlSource")
      Set prpColumnHidden = ctrl.Properties("ColumnHidden")
      On Error GoTo 0
      
      If Not ((prpControlSource Is Nothing) Or (prpColumnHidden Is Nothing)) Then
         ColumnName = prpControlSource.value
         ColumnNameIsInList = False
         For i = lb To ub
            If ColumnList(i) = ColumnName Then
               ColumnNameIsInList = True
               Exit For
            End If
         Next i

         If ColumnNameIsInList Then
            prpColumnHidden.value = HideTheseColumns
         ElseIf Not IgnoreIfNotInList Then
            prpColumnHidden.value = Not HideTheseColumns
         End If
         
      End If
   Next ctrl

End Sub

Public Sub CreateRelationship(ParentTable As String, ParentField As String, ChildTable As String, ChildField As String, _
            Optional RelationName As String = "", Optional Attributes As Long = 0)
   
   'If caller wishes to specify Attributes, it should be a combination of these constants:
'dbRelationUnique The relationship is one-to-one.
'dbRelationDontEnforce The relationship isn't enforced (no referential integrity).
'dbRelationInherited The relationship exists in a non-current database that contains the two linked tables.
'dbRelationUpdateCascade Updates will cascade.
'dbRelationDeleteCascade Deletions will cascade.

   'if caller does not pass Attributes, relation is created as : dbRelationUpdateCascade Or dbRelationDeleteCascade

   Dim db As DAO.Database
'   Dim rels As DAO.Relations
   Dim relNew As DAO.Relation
   Dim strRelationName As String
   Dim lngAttributes As Long
   Dim fldParent As DAO.Field, fldChild As DAO.Field, fldRelation As DAO.Field

   If RelationName <> "" Then
      strRelationName = RelationName
   Else
      strRelationName = Left(VBA.Replace(ParentTable & "_" & ChildTable, " ", ""), 64)
   End If

   If Attributes <> 0 Then
      lngAttributes = Attributes
   Else
      lngAttributes = dbRelationUpdateCascade Or dbRelationDeleteCascade
   End If
   
   Set db = CurrentDb

   'do this to ensure that the field names exist
   Set fldParent = db.TableDefs(ParentTable).Fields(ParentField)
   Set fldChild = db.TableDefs(ChildTable).Fields(ChildField)

   Set relNew = db.CreateRelation(strRelationName, ParentTable, ChildTable, lngAttributes)
   With relNew
      Set fldRelation = .CreateField(fldParent.Name)
      fldRelation.ForeignName = fldChild.Name
      .Fields.Append fldRelation
   End With

   db.Relations.Append relNew
   

End Sub

Public Sub SetFormToolbars(Optional DesignMode As Boolean = False)
   Dim cb As CommandBar
   For Each cb In Application.CommandBars
      'Debug.Print cb.Name

      If (cb.Name = "Formatting (Form/Report)") Or (cb.Name = "Formatting (Datasheet)") Or (cb.Name = "Form Design") Then
         cb.Visible = DesignMode
      ElseIf cb.Name = "Form View" Then
         cb.Visible = Not DesignMode
      End If
   Next
End Sub

Public Function GetRecentRecordIdentity() As Long
   Dim rs As ADODB.Recordset
   Dim cn As ADODB.Connection
   Set cn = CurrentProject.Connection
   Set rs = cn.Execute("SELECT @@IDENTITY")
   GetRecentRecordIdentity = rs.Fields(0).value
   rs.Close
   Set rs = Nothing
   Set cn = Nothing
End Function

Public Sub Form_Resize_SingleControl(frm As Form, cntrl As Control, ByRef Spacing_Bottom As Integer, ByRef Spacing_Right As Integer, _
         Optional WidthIsFixed As Boolean = False, Optional HeightIsFixed As Boolean)

   'to use this routine, in your Form_Resize event place the following code

'   Static Spacing_Bottom As Integer
'   Static Spacing_Right As Integer
'
'   'For a control at the bottom-right of the form (to be resized in both directions, maintaining constant bottom and right margins:
'   modAccessUtilities.Form_Resize_SingleControl Me, <SubForm or other control at bottom right of form>, Spacing_Bottom, Spacing_Right
'
'   'If desired, resize additional controls by specifying a dimension to hold fixed
'   modAccessUtilities.Form_Resize_SingleControl Me, <another control at right of form, but not to be resized in height>, Spacing_Bottom, Spacing_Right,False, True


   If Spacing_Bottom = 0 Then
      Spacing_Bottom = frm.InsideHeight - (cntrl.top + cntrl.Height)
      Spacing_Right = frm.InsideWidth - (cntrl.Left + cntrl.Width)
   End If

   If Not HeightIsFixed Then
      cntrl.Height = Max(frm.InsideHeight - cntrl.top - Spacing_Bottom, 10)
   End If

   If Not WidthIsFixed Then
      cntrl.Width = Max(frm.InsideWidth - cntrl.Left - Spacing_Right, 10)
   End If
End Sub

Public Sub Form_Resize_SingleControl_New(frm As Form, cntrl As Control, _
         Optional ExpandFactor_Width As Single = 1, Optional ExpandFactor_Height As Single = 1, _
         Optional MoveFactor_Left As Single = 0, Optional MoveFactor_Top As Single = 0, _
         Optional FormDesignWidth_RelThisControl As Integer = -1, Optional FormDesignHeight_RelThisControl As Integer = -1)


' Code works by trying to keep a constant distance from the right side of the control to the right edge of the form; and also
'  from the bottom of the control to the bottom of the form.
' With the default options, this is accomplished simply by adjusting the height and width.
' However, it is also possible to adjust the position of the control by supplying fractional values (0 to 1) for the MoveFactors

   
   Dim Spacing_Bottom_Current As Integer, Spacing_Right_Current As Integer
   Dim Spacing_Bottom_Original As Integer, Spacing_Right_Original As Integer
   Dim Left_Original As Integer, Width_Original As Integer
   Dim Top_Original As Integer, Height_Original As Integer

   Dim FormDesignWidth As Integer, FormDesignHeight As Integer

   Dim strSettingsParts() As String
   Dim C As Control
   
   Set C = cntrl

   If C.Tag = "" Then 'get all initial settings
      'Get the Design-time width and height of the form.  These are encoded into the form
      'tag (or may be automatically set by the first call to this routine)

      'In this case, these numbers will be used to calculate the bottom/right spacings that should
      'be maintained, instead of the current height/width.  This is good because the form could
      'open with a different size than it was when it was designed.

      If frm.Tag <> "" Then
         strSettingsParts = Split(frm.Tag, ";")
         If Not UBound(strSettingsParts) >= 1 Then
            Err.Raise vbObjectError + 512, "Form_Resize_SingleControl_New", "Tag value of form '" & frm.Name & "' is invalid.  You cannot use the Tag property if you want to use this function."
         End If
         FormDesignWidth = CInt(strSettingsParts(0))
         FormDesignHeight = CInt(strSettingsParts(1))

      Else 'get the design-time size of form, save it into the tag
         If FormDesignWidth_RelThisControl >= 0 Then
            FormDesignWidth = C.Left + C.Width + FormDesignWidth_RelThisControl
         Else
            FormDesignWidth = frm.InsideWidth
         End If

         If FormDesignHeight_RelThisControl >= 0 Then
            FormDesignHeight = C.top + C.Height + FormDesignHeight_RelThisControl
         Else
            FormDesignHeight = frm.InsideHeight
         End If

         'now save these settings into the tag of the form, for use for the other controls being managed
         frm.Tag = CStr(FormDesignWidth) & ";" & CStr(FormDesignHeight)
      End If


      Spacing_Bottom_Original = FormDesignHeight - (C.top + C.Height)
      Spacing_Right_Original = FormDesignWidth - (C.Left + C.Width)
      C.Tag = CStr(C.top) & ";" & CStr(C.Height) & ";" & _
              CStr(C.Left) & ";" & CStr(C.Width) & ";" & _
              CStr(Spacing_Bottom_Original) & ";" & CStr(Spacing_Right_Original)

   End If

   strSettingsParts = Split(C.Tag, ";")
   If Not UBound(strSettingsParts) >= 5 Then
      Err.Raise vbObjectError + 512, "Form_Resize_SingleControl_New", "Tag value of control '" & C.Name & "' is invalid.  You cannot use the Tag property if you want to use this function."
   End If
   Top_Original = CInt(strSettingsParts(0))
   Height_Original = CInt(strSettingsParts(1))
   Left_Original = CInt(strSettingsParts(2))
   Width_Original = CInt(strSettingsParts(3))
   Spacing_Bottom_Original = CInt(strSettingsParts(4))
   Spacing_Right_Original = CInt(strSettingsParts(5))

   Dim new_height As Integer, new_top As Integer
   Dim new_width As Integer, new_left As Integer
   
   Dim total_adjust As Integer

   If Not ((MoveFactor_Top = 0) And (ExpandFactor_Height = 0)) Then
      'determine the total amount of adjustment needed to keep the original spacing
      Spacing_Bottom_Current = (frm.InsideHeight - (Top_Original + Height_Original))
      total_adjust = (Spacing_Bottom_Current - Spacing_Bottom_Original)

      'now apply these to the top & height of control as desired
      C.Height = Max(Height_Original + total_adjust * ExpandFactor_Height, 10)
      C.top = Max(Top_Original + total_adjust * MoveFactor_Top, 0)
   End If

   If Not ((MoveFactor_Left = 0) And (ExpandFactor_Width = 0)) Then
      'determine the total amount of adjustment needed to keep the original spacing
      Spacing_Right_Current = (frm.InsideWidth - (Left_Original + Width_Original))
      total_adjust = (Spacing_Right_Current - Spacing_Right_Original)

      'now apply these to the left & width of control as desired
      C.Width = Max(Width_Original + total_adjust * ExpandFactor_Width, 10)
      C.Left = Max(Left_Original + total_adjust * MoveFactor_Left, 0)
   End If

End Sub


Public Function BinaryFieldsEqual(fld1 As ADODB.Field, fld2 As ADODB.Field) As Boolean
   If fld1.Type <> adLongVarBinary Or fld2.Type <> adLongVarBinary Then
      Err.Raise vbObjectError + 512, "BinaryFieldsEqual", "Fields must be of type adLongVarBinary (in Access, OLEObject)."
   End If
   Dim retval As Boolean
   Dim chunksize As Long
   Const chunksize_max As Long = 10000

   Dim i As Long, nextindex As Long, totalsize As Long
   Dim fld1_bytes() As Byte, fld2_bytes() As Byte

   If fld1.ActualSize <> fld2.ActualSize Then
      retval = False
   Else 'if they are the same size, must compare bytes
      retval = True 'assume True until find byte mismatch
      totalsize = fld1.ActualSize
      Do
         chunksize = Min(chunksize_max, totalsize - nextindex)
         fld1_bytes = fld1.GetChunk(chunksize)
         fld2_bytes = fld2.GetChunk(chunksize)
         For i = 0 To chunksize - 1
            If fld1_bytes(i) <> fld2_bytes(i) Then
               retval = False
               Exit For
            End If
         Next i
         nextindex = nextindex + chunksize
      Loop Until nextindex >= totalsize
   End If

   BinaryFieldsEqual = retval
End Function



Public Function Form_OpenArgs_CreateDictionary(strOpenArgs As String) As Scripting.Dictionary

   'expects an arguement string to be separated into section by ';'; each section is either a simple name, or a name-value pair separated by '='
   Dim sections() As String
   Dim i As Integer
   Dim param_part() As String
   Dim dic As New Scripting.Dictionary

   sections = Split(strOpenArgs, ";")

   For i = LBound(sections) To UBound(sections)
      param_part = Split(sections(i), "=")
      If UBound(param_part) > 0 Then
         dic.Add Trim(param_part(0)), Trim(Mid(sections(i), InStr(1, sections(i), "=") + 1))
      Else
         dic.Add Trim(param_part(0)), ""
      End If
   Next i

   Set Form_OpenArgs_CreateDictionary = dic
End Function



Public Function ConfirmPermission(op As eDBOperation, TableName As String) As Boolean
   Dim lngCurrentUserID As Long
   lngCurrentUserID = modAccessUtilities.CurrentUserID

   ConfirmPermission = True
End Function

#If SupportCustomUIControls Then

Public Function MsgBox_UserButtons(msg As String, ButtonList As String) As Integer
   
   'Caller specifies a list of button choices, up to 4, seperated by semicolons
   'Returns index of button chosen (1-based); is user pressed cancel, returns 0
   'Relies upon Form_UserListChoice

   Dim frmChoice As Form_UserListChoice
   Dim retval As Integer

   Dim MousePointer_Prev As Long

   MousePointer_Prev = Application.Screen.MousePointer
   Application.Screen.MousePointer = 0

   Set frmChoice = New Form_UserListChoice
   With frmChoice
      .ShowAsButtons = True
      .ListRowSource = ButtonList
      .TitleText = msg
      .Visible = True
      
      Do
         DoEvents
         Sleep 100
         
      Loop Until .UserOK Or .UserCancel

      .Visible = False
      If .UserOK Then
         retval = CInt(.ListValue)
      Else
         retval = 0
      End If

      Set frmChoice = Nothing
   End With

   Application.Screen.MousePointer = MousePointer_Prev

   MsgBox_UserButtons = retval
End Function

Public Function UserChoiceList_MultiSelect(strTitle As String, strSQL_List As String) As Long()
   'caller must specify a  SQL statement which has two columns:
   '  the first is the value column, an Integer or Long Integer type
   '  the second is a test string which will be shown in the list
   'If User chooses "Cancel" returns empty array
   Dim arr() As Long
   arr = privUserChoiceList_Multi(strTitle, strSQL_List, True)
   UserChoiceList_MultiSelect = arr
End Function


Public Function UserChoiceList(strTitle As String, strSQL_List As String) As Long
   'caller must specify a  SQL statement which has two columns:
   '  the first is the value column, an Integer or Long Integer type
   '  the second is a test string which will be shown in the list
   'If User chooses "Cancel" returns 0

   Dim arr() As Long, retval As Long
   arr = privUserChoiceList_Multi(strTitle, strSQL_List, False)
   retval = 0
   On Error Resume Next
   retval = arr(0)
   On Error GoTo 0
   UserChoiceList = retval
End Function

Private Function privUserChoiceList_Multi(strTitle As String, strSQL_List As String, AllowMultiSelect As Boolean) As Long()
   'caller must specify a  SQL statement which has two columns:
   '  the first is the value column, an Integer or Long Integer type
   '  the second is a test string which will be shown in the list
   'If User chooses "Cancel" returns empty array

   Dim frmChoice As Form_UserListChoice
   Dim retval() As Long
   Dim MousePointer_Prev As Long

   MousePointer_Prev = Application.Screen.MousePointer
   Application.Screen.MousePointer = 0

   Set frmChoice = New Form_UserListChoice
   With frmChoice
      .TitleText = strTitle
      .AllowMultiSelect = AllowMultiSelect
      .ListRowSource = strSQL_List
      .Visible = True
      Do
         DoEvents
         Sleep 100
         
      Loop Until .UserOK Or .UserCancel
   
      .Visible = False
      If .UserOK Then
         retval = .SelectedValues    ' Nz(.ListValue, 0)
      Else
         If AllowMultiSelect Then
            retval = .SelectedValues    ' Nz(.ListValue, 0)
         Else
         ReDim retval(0)
            retval(0) = 0
         End If
      End If
   
      Set frmChoice = Nothing
   End With

   Application.Screen.MousePointer = MousePointer_Prev

   privUserChoiceList_Multi = retval
End Function


#End If

Public Function CompareTables(dbNew As DAO.Database, dbOld As DAO.Database, strLogFilename As String) As Boolean
   'dbNew is the database that may have new the changes relative to dbOld

   Dim tdsNew As DAO.TableDefs, tdsOld As DAO.TableDefs
   Dim tdNew As DAO.TableDef, tdOld As DAO.TableDef
   Dim fso As New Scripting.FileSystemObject
   Dim log As Scripting.TextStream
   Dim fldNew As DAO.Field, fldOld As DAO.Field, f As Integer
   Dim AllFieldsMatch As Boolean
   Dim pNew As DAO.Property, pOld As DAO.Property, p As Integer
   Dim valNew As Variant, valOld As Variant, values_match As Boolean


   Set log = fso.CreateTextFile(strLogFilename)
   log.WriteLine "Table Name" & vbTab & "Status" & vbTab & "Comment"

   Set tdsNew = dbNew.TableDefs
   Set tdsOld = dbOld.TableDefs

   For Each tdNew In tdsNew
      On Error Resume Next
      Set tdOld = Nothing
      Set tdOld = tdsOld(tdNew.Name)
      On Error GoTo 0

      Debug.Print "Comparing NEW table: " & tdNew.Name
      DoEvents

      log.Write tdNew.Name & vbTab

      If LinkManager.IsALinkedTable(tdNew) Then
         log.WriteLine "LINKED" & vbTab & "table was not analyzed"
      ElseIf tdOld Is Nothing Then
         log.WriteLine "NEW" & vbTab & "table exists in new DB, but not in old DB"
      Else
         If tdNew.Fields.Count <> tdOld.Fields.Count Then
            log.Write "MODIFIED" & vbTab & "field count is different"
            AllFieldsMatch = False
         Else
            AllFieldsMatch = True
            For f = 0 To tdNew.Fields.Count - 1
               Set fldNew = tdNew.Fields(f)
               Set fldOld = tdOld.Fields(f)
               If fldOld.Name <> fldNew.Name Then
                  log.Write "MODIFIED" & vbTab & "fields have changed in name or order"
                  AllFieldsMatch = False
               ElseIf fldOld.Type <> fldNew.Type Then
                  log.Write "MODIFIED" & vbTab & "data type changed for field " & fldNew.Name
                  AllFieldsMatch = False
               Else 'check all properties of the field
                  If fldNew.Properties.Count <> fldOld.Properties.Count Then
                     log.Write "MODIFIED" & vbTab & "different number of properties for field " & fldNew.Name
                     AllFieldsMatch = False
                  Else
                     For p = 0 To fldNew.Properties.Count - 1
                        Set pNew = fldNew.Properties(p)
                        Set pOld = fldOld.Properties(p)
                        On Error Resume Next
                        values_match = True 'by default, assume match
                        values_match = (pNew.value = pOld.value)  'this comparison can cause an error for some property types ... for those we will essentially not make a proper comparison
                        On Error GoTo 0

                        If (pNew.Name <> pOld.Name) Or (Not values_match) Then
                           log.Write "MODIFIED" & vbTab & "different value for property " & pNew.Name & " for field " & fldNew.Name
                           AllFieldsMatch = False
                           Exit For
                        End If
                     Next p
                  End If
               End If
               If Not AllFieldsMatch Then Exit For
            Next f
            If AllFieldsMatch Then
               log.Write "OK" & vbTab & " No changes"
            End If
         End If
         log.WriteLine
      End If
   Next tdNew

   For Each tdOld In tdsOld
      Debug.Print "Comparing OLD table: " & tdOld.Name
      DoEvents

      If Not LinkManager.IsALinkedTable(tdOld) Then
         On Error Resume Next
         Set tdNew = Nothing
         Set tdNew = tdsNew(tdOld.Name)
         On Error GoTo 0
   
         If tdNew Is Nothing Then
            log.WriteLine tdOld.Name & vbTab & "DELETED" & vbTab & "table exists in old DB, but not in new DB"
         End If
         DoEvents
      End If
   Next tdOld
   
   log.Close
End Function

Public Function CompareQueries(dbNew As DAO.Database, dbOld As DAO.Database, strLogFilename As String) As Boolean
   'dbNew is the database that may have new the changes relative to dbOld

   Dim qdsNew As DAO.QueryDefs, qdsOld As DAO.QueryDefs
   Dim qdNew As DAO.QueryDef, qdOld As DAO.QueryDef
   Dim fso As New Scripting.FileSystemObject
   Dim log As Scripting.TextStream
   Dim pNew As DAO.Property, pOld As DAO.Property, p As Integer
   Dim valNew As Variant, valOld As Variant, values_match As Boolean


   Set log = fso.CreateTextFile(strLogFilename)
   log.WriteLine "Query Name" & vbTab & "Status" & vbTab & "Comment" & vbTab & "Old" & vbTab & "New"

   Set qdsNew = dbNew.QueryDefs
   Set qdsOld = dbOld.QueryDefs

   For Each qdNew In qdsNew
      On Error Resume Next
      Set qdOld = Nothing
      Set qdOld = qdsOld(qdNew.Name)
      On Error GoTo 0

      If Left(qdNew.Name, 3) <> "~sq" Then
         
         Debug.Print "Comparing NEW Query: " & qdNew.Name
         DoEvents
   
         log.Write qdNew.Name & vbTab
   
         If qdOld Is Nothing Then
            log.WriteLine "NEW" & vbTab & "Query exists in new DB, but not in old DB"
         Else
            If qdNew.SQL <> qdOld.SQL Then
               log.Write "MODIFIED" & vbTab & "SQL is different" & vbTab & qdOld.SQL & vbTab & qdNew.SQL
            ElseIf qdNew.Fields.Count <> qdOld.Fields.Count Then
               log.Write "MODIFIED" & vbTab & "field count is different" & vbTab & qdOld.Fields.Count & vbTab & qdNew.Fields.Count
            Else
               log.Write "OK" & vbTab & " No changes"
            End If
            log.WriteLine
         End If

      End If
   Next qdNew

   For Each qdOld In qdsOld
      If Left(qdOld.Name, 3) <> "~sq" Then

         Debug.Print "Comparing OLD Query: " & qdOld.Name
         DoEvents
   
         On Error Resume Next
         Set qdNew = Nothing
         Set qdNew = qdsNew(qdOld.Name)
         On Error GoTo 0
   
         If qdNew Is Nothing Then
            log.WriteLine qdOld.Name & vbTab & "DELETED" & vbTab & "Query exists in old DB, but not in new DB"
         End If
      End If
      DoEvents
   Next qdOld
   
   log.Close
End Function


Public Sub DumpAllCode()
   Dim md As Access.Module
   Dim ao As Access.AccessObject
   Dim i As Integer
   Dim Count As Long
   Dim lines_count As Long

   Dim fso As New FileSystemObject
   Dim ts As Scripting.TextStream
   Dim OutFilename As String
   Dim strModText As String


   Dim sfd As FileDialog
   Set sfd = Application.FileDialog(msoFileDialogSaveAs)
   
   With sfd
      .InitialFileName = Environ("USERPROFILE") & "\Documents\Access_Code_" & Format(Now, "yyyyMMdd") & ".txt"
      .Title = "Specify file for code dump"
      If .Show Then

         Dim comp As VBIDE.VBComponent
         Dim TypeName As String

         Count = 0
         lines_count = 0
         Set ts = fso.OpenTextFile(.SelectedItems(1), ForWriting, True)
         
            For Each comp In Application.VBE.ActiveVBProject.VBComponents
               Count = Count + 1
               Debug.Print Count & ": " & comp.Name; " Lines: " & comp.CodeModule.CountOfLines
               lines_count = lines_count + comp.CodeModule.CountOfLines
         
               Select Case comp.Type
         
                  Case vbext_ct_StdModule: TypeName = "Standard module"
                  Case vbext_ct_ClassModule: TypeName = "Class module"
                  Case vbext_ct_MSForm: TypeName = "Microsoft Form"
                  Case vbext_ct_ActiveXDesigner:: TypeName = "ActiveX Designer"
                  Case vbext_ct_Document: TypeName = "Document Module"
                  Case Else
                     TypeName = "Unknown component type, Type=" & CStr(comp.Type)
               End Select
         
               ts.WriteLine "Component: " & comp.Name & "; " & TypeName
               If comp.CodeModule.CountOfLines > 0 Then
                  strModText = comp.CodeModule.Lines(1, comp.CodeModule.CountOfLines)
               End If
               ts.Write strModText
               ts.WriteLine
               ts.WriteLine "----------- end of component"
            Next comp
         
            ts.Close
            Debug.Print "Total codes lines: " & lines_count
      
      End If
   End With
'   For i = 0 To Application.Modules.count - 1
'      Set md = Application.Modules(i)
'      Debug.Print md.Name
'   Next i
'   For Each ao In Application.CodeProject.AllModules
'      count = count + 1y
'      Debug.Print count & ": " & ao.Name
'   Next ao


End Sub


Public Sub SearchQueryText(SearchString As String, Optional CompareMethod As VbCompareMethod = VbCompareMethod.vbTextCompare, _
                           Optional DoReplace As Boolean = False, Optional ReplaceString As String = "")
   Dim qdf As DAO.QueryDef
   Dim CountFound As Integer

   Debug.Print
   Debug.Print

   For Each qdf In Application.CurrentDb.QueryDefs
      If InStr(1, qdf.SQL, SearchString, CompareMethod) > 0 Then
         CountFound = CountFound + 1

         Debug.Print qdf.Name
         Debug.Print String(Len(qdf.Name), "-")
         Debug.Print qdf.SQL
         Debug.Print

         If DoReplace Then
            qdf.SQL = Replace(qdf.SQL, SearchString, ReplaceString, , , CompareMethod)

            Debug.Print "Changed to:"
            Debug.Print qdf.SQL
            Debug.Print
         End If

      End If
   Next qdf

   Debug.Print "Found """ & SearchString & """ in " & CountFound & " queries."
   Debug.Print "SearchQueryText """ & SearchString & """"

End Sub

Public Sub DumpQuery()
   Dim qdf As DAO.QueryDef
   Dim ts As Scripting.TextStream
   Dim fso As New FileSystemObject

   Const OutFilename As String = "C:\Documents and Settings\eysce\Desktop\YomicsQueryDump.txt"
   
   Set ts = fso.OpenTextFile(OutFilename, ForWriting, True)
   For Each qdf In Application.CurrentDb.QueryDefs
      ts.WriteLine qdf.Name
      ts.WriteLine qdf.SQL
      ts.WriteLine "-----------------"
      ts.WriteLine
   Next qdf

   ts.Close

End Sub



----------- end of component
Component: LinkManager; Standard module
Option Compare Database
Option Explicit

Public RunningProductionDatabase As Boolean

Public Enum eLinkStatus
   LinksAllOK
   SomeLinksNotConsistentWithTargetGroup
   SomeLinksNotValid
   SomeLinksNotRefreshed
End Enum


#If OldLinkShit Then
Public Function BuildLinkForm() As Boolean
   
   'This procedure dynamically loads as many option buttons as necessary onto the form "RelinkManager", depending
   ' on the number of records in the LinkGroups table.  It sets them with the proper values, then opens the form.
   Dim rsLinkGroups As DAO.Recordset
   Dim optNew As OptionButton, optDefault As OptionButton
   Dim lblNew As Label, lblDefault As Label
   Dim iLinkGroupCount As Integer, iLinkGroup As Integer
   Dim frm As Form
   Dim strOptName As String, strLblName As String
   Dim ctrl As Control, CtrlsToDelete As New Collection, i As Integer
   Dim iOriginalLeft As Integer, iOriginalTop As Integer, iOriginalWidth As Integer, ogpLinks As OptionGroup
   Dim relCmdSpacing As Integer, relTxtSpacing As Integer
   
   
   Set rsLinkGroups = CurrentDb.OpenRecordset("LinkGroups")
   rsLinkGroups.MoveLast
   iLinkGroupCount = rsLinkGroups.RecordCount
   rsLinkGroups.MoveFirst
   
   DoCmd.OpenForm "RelinkingManager", acDesign, , , acFormEdit, acHidden  'open the form in design mode

   Set frm = [Forms]![RelinkingManager]
   Set optDefault = frm.Controls("optLinkGroup1")
   Set lblDefault = frm.Controls("lblLinkGroup1")
   
   
   'keep the original left/top settings of the frame, because it gets
   Set ogpLinks = frm.Controls("fraLinkGroups")
   iOriginalLeft = ogpLinks.Left
   iOriginalTop = ogpLinks.top
   iOriginalWidth = ogpLinks.Width
   
   'determine the current distance from the bottom of the LinkGroup frame to the command button
   relCmdSpacing = frm.Controls("cmdRelink").top - (ogpLinks.top + ogpLinks.Height)
   'determine the current distance from the bottom of the command button to the text box
   relTxtSpacing = frm.Controls("txtLinkStatus").top - (frm.Controls("cmdRelink").top + frm.Controls("cmdRelink").Height)
   
   'first, delete all option/label pairs in the frame except the first
   For Each ctrl In frm.Controls
      If ctrl.Parent.Name = "fraLinkGroups" Then
         If ctrl.Name <> "optLinkGroup1" And ctrl.Name <> "lblLinkGroup1" And ctrl.Name <> "lblLinkGroupTitle" Then
         'don't delete these... they are the example objects to build the others
            CtrlsToDelete.Add ctrl.Name
         End If
      End If
   Next ctrl
   'do the delete in two steps like this because if you delete the current object during the For.. Next loop,
   ' you will miss some of the objects
   
   For i = 1 To CtrlsToDelete.Count
      Call DeleteControl("RelinkingManager", CtrlsToDelete.Item(i))
   Next i
      
   For iLinkGroup = 1 To iLinkGroupCount
      'load new option button and label
      
      strOptName = "optLinkGroup" & CStr(iLinkGroup)
      strLblName = "lblLinkGroup" & CStr(iLinkGroup)
      
      If iLinkGroup > 1 Then 'don't load for first link group -- use the one already on the form
         Set optNew = CreateControl("RelinkingManager", acOptionButton, acDetail, "fraLinkGroups")
   '      Set lblNew = CreateObject("Label")
         'set the default properties of the new objects
         With optNew
            .Name = strOptName
            .top = lblDefault.top + (iLinkGroup - 1) * (lblDefault.Height * 1.5)
            .Left = optDefault.Left
            .Visible = True
         End With
         Set lblNew = CreateControl("RelinkingManager", acLabel, acDetail, "optLinkGroup" & CStr(iLinkGroup))
         With lblNew
            .Name = strLblName
            .BackColor = lblDefault.BackColor
            .BackStyle = lblDefault.BackStyle
            .BorderColor = lblDefault.BorderColor
            .BorderStyle = lblDefault.BorderStyle
            .BorderWidth = lblDefault.BorderWidth
            .FontName = lblDefault.FontName
            .FontSize = lblDefault.FontSize
            .Height = lblDefault.Height
            .Width = lblDefault.Width
            .Left = lblDefault.Left
            .top = lblDefault.top + (iLinkGroup - 1) * (lblDefault.Height * 1.5)
            .Visible = True
         End With
      
      Else
         Set optNew = optDefault
         Set lblNew = lblDefault
      End If
   
   
      optNew.OptionValue = rsLinkGroups![LinkGroupID]
      lblNew.Caption = rsLinkGroups![LinkGroupName]
   
      rsLinkGroups.MoveNext
   Next iLinkGroup
   
   rsLinkGroups.Close
   
   'do some cosmetic sizing of the option group frame
   frm.AutoResize = True
   ogpLinks.Left = iOriginalLeft
   ogpLinks.top = iOriginalTop
   ogpLinks.Height = lblDefault.Height * 1.5 * (iLinkGroupCount + 1)
   ogpLinks.Width = iOriginalWidth
   
   frm.Controls("cmdRelink").top = ogpLinks.top + ogpLinks.Height + relCmdSpacing
   frm.Controls("txtLinkStatus").top = (frm.Controls("cmdRelink").top + frm.Controls("cmdRelink").Height) + relTxtSpacing
   frm.Controls("lblLinkStatus").top = frm.Controls("txtLinkStatus").top
   frm.Section(acDetail).CanGrow = True
   frm.Section(acDetail).Height = frm.Controls("txtLinkStatus").top + frm.Controls("txtLinkStatus").Height * 1.5
   DoCmd.Save acForm, "RelinkingManager"
   DoCmd.Close acForm, "RelinkingManager"
   
End Function

#End If

Public Function ThisDbInProductionFrontEndPath(ProductionFrontEndPath As String) As Boolean
   ThisDbInProductionFrontEndPath = (LCase(Application.CurrentProject.Path) = LCase(ProductionFrontEndPath))
End Function

Public Function CheckLinks(ProductionFrontEndPath As String, ProductionLinkGroupName As String, _
                Optional CheckOnePerDatasource As Boolean = False, _
                Optional CheckOneTable As Boolean = False, Optional txtStatus As TextBox = Nothing, _
                Optional ShowWarningMessages As Boolean = True) As eLinkStatus
   'Checks to see that linked tables are or are not pointing at the Production databases.
   
   'First determines whether we are running in a 'magic' front-end location which should be linked to
   ' Production databases (i.e. "C:\ChemTrak\ChemTrakWORK.*" )
   
   'If running what should be the Production-linked front-end, confirm that all tables are linked to
   '  Production datasources.
   
   'If running anywhere other than the 'magic' location, confirm that all tables are NOT linked to
   '  Production datasources.
    
   'if optional param CheckOnePerDatasource is TRUE, only checks the links of one table for each datasource.
   'if optional param CheckOneTable is TRUE, only checks the links of ONE table (the LinkGroups table).
   'if optional param ShowWarningMessages is TRUE, then displays necessary warnings about the consistency status of
   '  links (Production front-end / back-end conflict), and even will close the database if necessary;
   '   if FALSE, then allows the caller to decide what to do.
      
'   Dim FrontEndFilename As String, iDotLocation As Integer
   Dim ShouldBeLinkedToProduction As Boolean
   Dim rsLinkGroups As DAO.Recordset, lLinkGroupID As Long
   Dim strMsg As String, strSQL As String
   Dim retval As eLinkStatus
   
   If Not (txtStatus Is Nothing) Then
      txtStatus = "Checking Database Links"
      DoEvents
   End If
   On Error GoTo 0
   CheckLinks = SomeLinksNotConsistentWithTargetGroup

'   FrontEndFilename = CurrentDb.Name
'   iDotLocation = InStr(1, FrontEndFilename, ".")
'   If iDotLocation > 0 Then FrontEndFilename = Left(FrontEndFilename, iDotLocation - 1) 'strip off the extension .. I don't care if it's a "mde" or "mdb" or something else
'
'   ShouldBeLinkedToProduction = (InStr(1, "C:D:E:", UCase(Left(FrontEndFilename, 2))) > 0)
   'TF18Jan2001 -- now assumes that we are should be linked to Production if running on
   '  any local drive C, D, or E.  Clearly this is still a half-assed method of determining
   '  if we are being run from a local vs. network location, but so be it.  This doesn't
   '  have to be perfect, and will work in almost all cases

   'different idea now.  Caller must supply what they consider to be the path to the production version of the front-end.  This
   ' should be hard-coded into whatever startup form is calling this procedure.

   ShouldBeLinkedToProduction = ThisDbInProductionFrontEndPath(ProductionFrontEndPath)

   RunningProductionDatabase = ShouldBeLinkedToProduction
   
   'this next line could fail if the Link Management tables are have bad links!
   On Error Resume Next
   Err.Clear
   Set rsLinkGroups = CurrentDb.OpenRecordset("LinkGroups", dbOpenSnapshot)

   On Error GoTo 0

'   strSQL = "[LinkGroupName] ='Production'"
   strSQL = "[LinkGroupName]='" & ProductionLinkGroupName & "'"

   rsLinkGroups.FindFirst strSQL
   If Not rsLinkGroups.NoMatch Then
      lLinkGroupID = rsLinkGroups![LinkGroupID]
   Else
      MsgBox "Error in CheckAllLinks: could not find " & strSQL & " in table 'LinkGroups'."
      CheckLinks = SomeLinksNotValid
      Exit Function
   End If
   rsLinkGroups.Close
   
   
   'now go check the links.  The "Not ShouldBeLinkedToProduction" means that if we should NOT be linked to
   '  Production, confirm that we all links are to some other datasource
   retval = UpdateLinks(lLinkGroupID, txtStatus, True, Not ShouldBeLinkedToProduction, CheckOnePerDatasource, CheckOneTable)
   If ShowWarningMessages Then
      If retval = SomeLinksNotConsistentWithTargetGroup Then
         strMsg = FrontEnd_BackEnd_InconsistencyWarningMsg(ShouldBeLinkedToProduction)
         
         If MsgBox(strMsg, vbYesNo Or vbCritical, "LINKING ERROR") = vbNo Then
            DoCmd.Quit acQuitPrompt
         End If
      ElseIf retval = SomeLinksNotValid Then
         
      End If
   End If
   
   CheckLinks = retval

End Function

Public Function FrontEnd_BackEnd_InconsistencyWarningMsg(ShouldBeLinkedToProduction As Boolean) As String
   Dim strMsg  As String
   
   strMsg = "LINK CONFIRMATION FAILED! " & vbCrLf & vbCrLf & _
   "It was determined that you are running a front-end that SHOULD " & IIf(ShouldBeLinkedToProduction, "", "NOT ") & _
   "be linked to the 'Production' databases.  However, a check of linked tables found a linking error."
   If ShouldBeLinkedToProduction Then
      strMsg = strMsg & vbCrLf & "This means that some of the data you will be accessing or adding will not be " & vbCrLf & _
      "in the 'real' database tables."
   Else
      strMsg = strMsg & vbCrLf & "This means that some of the data you will be accessing or adding will " & vbCrLf & _
      "be in the REAL database tables, not the developmental copies." & vbCrLf & "PLEASE DO NOT PROCEED IF YOU ARE UNSURE OF WHAT YOU ARE DOING."
   End If
   strMsg = strMsg & vbCrLf & vbCrLf & "Do you want to proceed?"

   FrontEnd_BackEnd_InconsistencyWarningMsg = strMsg
End Function

Public Sub MakeLocalCopiesOfLinkedTable(Optional RestrictToODBC As Boolean = False, _
                        Optional RemoveOriginals As Boolean = True, _
                        Optional RenameToOrignal As Boolean = True, _
                        Optional StatusTextBox As TextBox = Nothing)
   
   Dim colTablesToCopy As New Collection
   Dim tbl As DAO.TableDef, db As DAO.Database
   Dim strSQL As String, strTableName_Original As String, strTableName_Local As String
   Dim qdf As QueryDef
   
   Set db = CurrentDb
   'first build a collection of tables that we will be operating on
   
   For Each tbl In db.TableDefs
      'table qualifies if it is a linked ODBC table, or a linked Access table (if RestrictToODBC=False)
      '  and also must not be Hidden
      If ((tbl.Attributes And dbAttachedODBC) Or _
          (tbl.Attributes And dbAttachedTable And (Not RestrictToODBC))) And _
          (Not (tbl.Attributes And dbHiddenObject)) Then
         colTablesToCopy.Add tbl, tbl.Name
      End If
   Next tbl

   'now make local copies of each, using SQL
   For Each tbl In colTablesToCopy
      strTableName_Original = tbl.Name
      strTableName_Local = strTableName_Original & "_local"
      strSQL = "SELECT [" & strTableName_Original & "].* " & _
               "INTO [" & strTableName_Local & "] " & _
               "FROM [" & strTableName_Original & "];"
      
      If Not (StatusTextBox Is Nothing) Then
         StatusTextBox.SetFocus
         StatusTextBox.Text = "Converting table '" & strTableName_Original & "'" & vbCrLf & _
                     strSQL

      Else
         Debug.Print strSQL
      End If
      
      DoEvents
      
      Set qdf = db.CreateQueryDef("", strSQL)
      qdf.Execute  'no error checking ... could implement
      Set qdf = Nothing
      
      If RemoveOriginals Then
         db.TableDefs.Delete strTableName_Original
         
         If RenameToOrignal Then
            db.TableDefs.Refresh  'to allow it to see the new table!
            db.TableDefs(strTableName_Local).Name = strTableName_Original
         End If
      End If
      
   Next tbl
End Sub

Public Function RelinkToLocalDatabase() As Boolean
   'resets the link to the local SynthesisPipeline_LocalSettings -- must be in the same folder as the application
   
   RelinkToLocalDatabase = UpdateLinks(LinkGroupID:=1, LinkDataSourceID_only:="SynthesisPipeline_LocalSettings")
   
End Function

Public Sub RemoveSchemaName_OracleLinkedTables()
   Dim tbl As DAO.TableDef
   Dim strNewTableName As String
   
   For Each tbl In CurrentDb.TableDefs
      If (tbl.Attributes And dbAttachedODBC) Then
         If InStr(1, tbl.Name, "OPS$RS3_", vbTextCompare) = 1 Then
            strNewTableName = Mid(tbl.Name, Len("OPS$RS3_") + 1)
            tbl.Name = strNewTableName
         End If
      End If
   Next tbl
   
End Sub

Public Sub FindOracleLinkedTables_LackingPassword()
   Dim tbl As DAO.TableDef
   Dim strNewTableName As String
   
   For Each tbl In CurrentDb.TableDefs
      If (tbl.Attributes And dbAttachedODBC) Then
         If Not CBool((tbl.Attributes And dbAttachSavePWD)) Then
 '           MsgBox "ODBC Linked Table '" & tbl.Name & "' does not have saved password."
            Debug.Print tbl.Name
            
         End If
      End If
   Next tbl
   
End Sub

Public Sub Remove_1_Suffix_LinkedTables()
   Dim tbl As DAO.TableDef
   Dim strOriginalTableName As String
   
   For Each tbl In CurrentDb.TableDefs
      If (Right(tbl.Name, 1) = "1") And (Not IsNumeric(Right(tbl.Name, 2))) And _
        ((tbl.Attributes And dbAttachedTable) Or (tbl.Attributes And dbAttachedODBC)) Then
         strOriginalTableName = tbl.Name
         
         On Error Resume Next
         Err.Clear
         tbl.Name = Left(strOriginalTableName, Len(strOriginalTableName) - 1)
         
         If Err.Number <> 0 Then
            tbl.Name = strOriginalTableName
         End If
         On Error GoTo 0
         
      End If
   Next tbl
   
End Sub

Private Sub SetCurrentLinkGroupName(CurrentLinkGroupName As String)
   'this records the given text in the 'CurrentlyExecutingVersion' table
   
   Dim rs As DAO.Recordset
    
   On Error GoTo SetCurrentLinkGroupName_Err
   
   Set rs = CurrentDb.OpenRecordset("SELECT * FROM CurrentlyExecutingVersion ORDER BY VersionEntryID DESC;", dbOpenDynaset)
   
   rs.Edit
   rs![CurrentLinkGroupName] = CurrentLinkGroupName
   rs.Update
   
SetCurrentLinkGroupName_Err:
   Set rs = Nothing
   
End Sub

Public Function GetCurrentLinkGroupName() As String
   'reurns the text in the CurrentLinkGroupName field of the 'CurrentlyExecutingVersion' table
   
   Dim rs As DAO.Recordset
   
   Set rs = CurrentDb.OpenRecordset("SELECT * FROM CurrentlyExecutingVersion ORDER BY VersionEntryID DESC;", dbOpenDynaset)
   
   GetCurrentLinkGroupName = rs![CurrentLinkGroupName]
   
   Set rs = Nothing
   
End Function

Private Sub test()
   
  MakeLocalCopiesOfLinkedTable True, True, True
   
  'UpdateLinks LinkGroupID:=1, LinkDataSourceID_only:="SynthesisPipeline_LocalSettings"
  ' CheckAllLinks False, True
   'Call BuildLinkForm
 'Call UpdateLinks(4)
  ' Call CheckAllLinks
  
End Sub


Public Function UpdateLinks(LinkGroupID As Long, Optional txtStatus As Control = Nothing, _
                  Optional ConfirmLinks As Boolean = False, Optional ConfirmExclude As Boolean = False, _
                  Optional CheckOnePerDatasource As Boolean = False, _
                  Optional CheckOneTable As Boolean = False, _
                  Optional LinkDataSourceID_only As String = "", _
                  Optional BypassODBC As Boolean = True, _
                  Optional OnlyODBC As Boolean = False, _
                  Optional DisableSubdatasheets As Boolean = True, _
                  Optional RefreshLink As Boolean = True, _
                  Optional ConfirmOnlyLinkValidity As Boolean = False) As eLinkStatus
   'caller passes in the the LinkGroupID that defines the set of datasources to use for linking -- these are
   '  defined in the "LinkDirector" table.
   'Optionally may pass a ref to a Textbox or Label control to display status.
   'If the optional param ConfirmLinks is True, then
   ' - no links are changed; they are only confirmed to be set as directed by the LinkGroupID
   ' - if the optional param ConfirmExclude is True, then instead of confirming that the links are set
   '   to the value as directed by the LinkGroupID, it confirms that the links are set to something OTHER THAN the
   '   value as directed by the LinkGroupID.  This is designed to, for example, confirm that none of the tables are
   '   linked to the Production datasources
   'If the optional param CheckOnePerDatasource is True, only checks the links of one table from each datasource
   'If the optional param CheckOneTable is True, only checks the links of ONE TABLE
   'If the optional param ConfirmOnlyLinkValidity  is True, then the confirmation does *not* check that the table
   '  is or is not linked to the stated LinkGroupID, but simply confirms that it is linked to something valid.
   'NOTE WELL: the option RefreshLink does not work as intended!  I leave it here only because in the future I may figure
   ' out how to make it work!  At the moment, if this value is False the link is not actually changed.
      'If the optional param RefreshLink is False, then only resets the connection string but does not call the Refresh method.
      '  This is valuable if the link path is not valid at the moment, but will be when the MDB is moved to its final location, etc.
      '  Note that this is ignored for ODBC tables (since they are relinked in a different fashion)
   'if the optional param LinkDataSourceID_only is set, then only refreshes links on tables that are part of that link datasource
   
   
   Dim db As DAO.Database
   Dim rsDirections As DAO.Recordset, rsDataSources As DAO.Recordset, rsLinkGroups As DAO.Recordset
   Dim rsTableDataSources As DAO.Recordset
   Dim ThisTable As DAO.TableDef
   Dim strSQL As String
   Dim iTable As Integer, i As Integer
   Dim strProperties As String
   Dim lngAttributes As Long
   Dim strCurrentConnectStr, strNewConnectStr As String, strNewSourceName As String
   Dim strLinkDatasourceName As String, strDirective As String, strCompleteDirective As String
   Dim iLeftBrace As Integer, iRightBrace As Integer, EndOfProperties As Boolean, iColon As Integer
   Dim UpdateTextBox As Boolean
   Dim ConfirmationOK As Boolean, AllConfirmationsOK As Boolean, AllRelinkingOK As Boolean, LinkErrThisTable As Boolean
   Dim CancelRelinking As Boolean, strErrMsg As String, intResponse As Integer
   Dim strLinkGroupName As String
   Dim strTextMsg As String
   Dim DatasourceChecked() As String, ThisDataSourceAlreadyChecked As Boolean
   Dim OneTableChecked As Boolean, OneTableCheckedOK As Boolean
   Dim DynamicPath_StartPos As Long, DynamicPath_EndPos As Long, DynamicPathParam As String
   Dim DynamicPath As New clsFilename
   Dim CurrentlyLinked_Access As Boolean, CurrentlyLinked_ODBC As Boolean, CurrentTableName As String
   Dim NewLinkIsODBC As Boolean
   Dim colTables_Initial As New Collection, intTablesProcessed As Integer
   Dim NewLinkedTable As DAO.TableDef
   Dim retvalConfirmation As eLinkStatus

   
   UpdateTextBox = Not (txtStatus Is Nothing)
   AllConfirmationsOK = True
   AllRelinkingOK = True
   retvalConfirmation = LinksAllOK
   
   strSQL = "SELECT ([LinkDatasources].[LinkDatasourceName]) AS LinkDatasourceName, LinkDirector.LinkDatabaseConnectStr, LinkDirector.LinkSourceTableNamePrefix " & _
            "FROM LinkDirector INNER JOIN LinkDatasources ON LinkDirector.LinkDatasourceID = LinkDatasources.LinkDatasourceID " & _
            "WHERE (((LinkDirector.LinkGroupID)=" & CStr(LinkGroupID) & "));"

   Set db = CurrentDb
   Set rsDirections = db.OpenRecordset(strSQL, dbOpenSnapshot)
   
   
   strSQL = "SELECT LinkTableDatasources.TableName, LinkDatasources.LinkDatasourceName " & _
            "FROM LinkTableDatasources INNER JOIN LinkDatasources " & _
            "ON LinkTableDatasources.LinkDatasourceID = LinkDatasources.LinkDatasourceID;"
   Set rsTableDataSources = db.OpenRecordset(strSQL, dbOpenDynaset)
   
   
   Set rsLinkGroups = db.OpenRecordset("LinkGroups", dbOpenSnapshot)
   strSQL = "[LinkGroupID] =" & CStr(LinkGroupID)
   rsLinkGroups.FindFirst strSQL
   If Not rsLinkGroups.NoMatch Then
      strLinkGroupName = rsLinkGroups![LinkGroupName]
   Else
      MsgBox "Error in UpdateLinks: could not find " & strSQL & " in table 'LinkGroups'."
      Exit Function
   End If
   rsLinkGroups.Close
   
   On Error Resume Next
   rsDirections.MoveLast
   On Error GoTo 0
   
   'check to make sure that we have the correct number of records
   Set rsDataSources = db.OpenRecordset("LinkDatasources")
   rsDataSources.MoveLast

'   If rsDirections.RecordCount <> rsDataSources.RecordCount Then
'      If MsgBox("The number of entries on LinkDirector for the supplied LinkGroupID (" & CStr(LinkGroupID) & ") do not equal the number of " & _
'             "datasources listed in the LinkDatasources table." & vbCrLf & _
'             "OK to continue?.", vbOKCancel + vbInformation) = vbCancel Then
'         rsDataSources.Close
'         rsDirections.Close
'         Exit Function
'      End If
'   End If

   ReDim DatasourceChecked(0 To rsDataSources.RecordCount - 1)
   rsDataSources.Close
   
   Screen.MousePointer = 11 'hourglass
   
   If Not ConfirmLinks Then  'if we are actually planning on relinking tables, mark this entry to denote possible failure
      SetCurrentLinkGroupName "ERROR: relinking only partially completed!!" 'if this procedure bombs out, this will be displayed when the next user
               'opens this front-end, to alert them that there is a problem
   End If
   
   'build a collection of all tables (must do this instead of just iterating through the
   '  db.Tables collection because we need to delete/add some tables, which will change that collection
   For Each ThisTable In db.TableDefs
      colTables_Initial.Add ThisTable
   Next ThisTable
   
   intTablesProcessed = 0
   For Each ThisTable In colTables_Initial
      DoEvents
      lngAttributes = ThisTable.Attributes
      
      'check if it is an attached table
      CurrentlyLinked_Access = CBool(lngAttributes And dbAttachedTable)
      CurrentlyLinked_ODBC = CBool(lngAttributes And dbAttachedODBC)
      If (CurrentlyLinked_Access And Not OnlyODBC) Or (CurrentlyLinked_ODBC And Not BypassODBC) Then
      #If old_method Then
         ' previously used a method in which the DataSource to link to was stored
            ' in the Properties of the table, in a string like "{link:DataSourceName}".
            ' Now, instead, keep all the info in another table.
            'now extract the needed parameter from the properties string
         strProperties = ""
         On Error Resume Next
         strProperties = ThisTable.Properties("Description").value
         On Error GoTo 0
         
      #Else  'new method -- pull info out of table
         strSQL = "TableName='" & ThisTable.Name & "'"
         rsTableDataSources.FindFirst strSQL
         
         If rsTableDataSources.NoMatch Then
            strLinkDatasourceName = ""
         Else
            strLinkDatasourceName = rsTableDataSources![LinkDatasourceName]
         End If
         strProperties = strLinkDatasourceName  'for code backward compatibility
      #End If
      
         If strProperties <> "" Then
            If UpdateTextBox Then
               strTextMsg = ThisTable.Name & IIf(ConfirmLinks, ": checking", ": interpreting") & " link info"
               If TypeOf txtStatus Is TextBox Then
                  txtStatus = strTextMsg
               ElseIf TypeOf txtStatus Is Label Then
                  txtStatus.Caption = strTextMsg
               End If
            End If
            DoEvents
            strCurrentConnectStr = ThisTable.Connect
      
         #If old_method Then
         
            iRightBrace = 0
            strLinkDatasourceName = ""
            EndOfProperties = False
            Do
              'NOTE: this loop is set up to allow more than just the "Link" directive in the future; each directive should
              ' be in a separate set of braces, and have a colon between the directive and the paramater; for example: {link: Xfrm}
               iLeftBrace = InStr(iRightBrace + 1, strProperties, "{")
               If iLeftBrace > 0 Then
                  iRightBrace = InStr(iLeftBrace + 1, strProperties, "}")
                  If iRightBrace > 0 Then
                     strCompleteDirective = Trim(Mid(strProperties, iLeftBrace + 1, iRightBrace - iLeftBrace - 1))
                     iColon = InStr(1, strCompleteDirective, ":")
                     If iColon > 0 Then
                        strDirective = UCase(Left(strCompleteDirective, iColon - 1))
                        
                        Select Case strDirective
                           Case "LINK": strLinkDatasourceName = UCase(Trim(Mid(strCompleteDirective, iColon + 1)))
                           Case Else
                              MsgBox "Unrecognized directive: " & Left(strCompleteDirective, iColon - 1)
                              AllRelinkingOK = False
                        End Select
                     Else
                        MsgBox "Malformed directive (no colon): " & strCompleteDirective
                        AllRelinkingOK = False
                     End If
                  Else
                     EndOfProperties = True
                  End If
               Else
                  EndOfProperties = True
               End If
            Loop Until strLinkDatasourceName <> "" Or EndOfProperties
         #Else  '-- in new method of reading from table, no need to parse;
                'we have the strLinkDatasourceName directly
            
         #End If
         
            If CheckOnePerDatasource Then
               'go through the datasources we have already checked to see if we have already checked the source of the current table

               For i = 0 To UBound(DatasourceChecked, 1)
                  If DatasourceChecked(i) = strLinkDatasourceName Then
                     ThisDataSourceAlreadyChecked = True
                     Exit For
                  End If
                  
                  If DatasourceChecked(i) = "" Then
                     'if we get up to a blank entry in the DatasourceChecked array, that means that we have not
                     ' yet checked this datasource. So, add the name of the
                     ' datasource for the current table, and proceed to check it.
                     ThisDataSourceAlreadyChecked = False
                     DatasourceChecked(i) = strLinkDatasourceName
                     Exit For
                  End If
               Next i
            End If
            
            If (Not CheckOnePerDatasource) Or (CheckOnePerDatasource And Not ThisDataSourceAlreadyChecked) Then
               If strLinkDatasourceName <> "" Then
                  If (LinkDataSourceID_only = strLinkDatasourceName Or LinkDataSourceID_only = "") Then
                     'new criteria: if caller supplies the name of a LinkDatasource that they want to refresh,
                     '  proceed only if the current table has that datasource
                     strSQL = "LinkDatasourceName = '" & strLinkDatasourceName & "'"
                     rsDirections.FindFirst strSQL
                     
                     
                     If Not rsDirections.NoMatch Then
                        strNewConnectStr = rsDirections![LinkDatabaseConnectStr]
                        'the external source table name must be either exactly the same as the Access Tablename,
                        '  or it may include a prefix
                        If (rsDirections![LinkSourceTableNamePrefix] & "") = "" Then
                           strNewSourceName = ""
                        Else
                           strNewSourceName = rsDirections![LinkSourceTableNamePrefix] & ThisTable.Name
                        End If
                        
                        'new feature (TF 17Jan2001): now supports some system-dependent paths in the connect string,
                        ' to dynamically change path for the current environment.
                        ' Currently supported are:
                        '$(AppPath)    The path of the executing project/MDB/MDE/EXE  for example:    ;DATABASE=$(AppPath)\SynthesisPipeline_LocalSettings.mdb
                        '$(WinSysPath)  - not yet supported
                        
                        'These dynamic params are replaced with the relavent path
                        DynamicPath_StartPos = InStr(1, strNewConnectStr, "$(")
                        If DynamicPath_StartPos > 0 Then
                           DynamicPath_EndPos = InStr(DynamicPath_StartPos + 1, strNewConnectStr, ")")
                           If DynamicPath_EndPos > 0 Then
                              DynamicPathParam = UCase(Mid(strNewConnectStr, DynamicPath_StartPos, DynamicPath_EndPos - DynamicPath_StartPos + 1))
                              Select Case DynamicPathParam
                                 Case "$(APPPATH)"
                                    'DynamicPath.Filename = Application.CurrentProject.Path
                                    'DynamicPath.FinalSlashOnPath = False
                                    'oops! "Application.CurrentProject.Path" actually returns *only* the path, without
                                    '   the actual filename!  Even more convenient than I thought.
                                    strNewConnectStr = Left(strNewConnectStr, DynamicPath_StartPos - 1) & _
                                                       Application.CurrentProject.Path & _
                                                       Mid(strNewConnectStr, DynamicPath_EndPos + 1)
                                 Case Else
                                    'not recognized - do nothing (let it generate an error when the linking fails)
                              End Select
                           End If
                        End If
                        
                        If Not ConfirmLinks Then  'if doing regular linking, set the new values and refresh
                           If UpdateTextBox Then
                              strTextMsg = ThisTable.Name & ": refreshing link to " & vbCrLf & _
                                   strLinkGroupName & ":" & strLinkDatasourceName
                              If TypeOf txtStatus Is TextBox Then
                                 txtStatus = strTextMsg
                              ElseIf TypeOf txtStatus Is Label Then
                                 txtStatus.Caption = strTextMsg
                              End If
                           End If

                           On Error GoTo UpdateLinks_Relink_Err

                           LinkErrThisTable = RelinkTable(ThisTable, strNewConnectStr, strNewSourceName, DisableSubdatasheets, RefreshLink)

                           On Error GoTo 0
                           If CancelRelinking Then Exit For

                        Else 'if doing only confirmation, check to see that the values match
                           If Not ConfirmOnlyLinkValidity Then
                              ConfirmationOK = IIf(ConfirmExclude, (ThisTable.Connect <> strNewConnectStr), (ThisTable.Connect = strNewConnectStr))
                           Else 'added this check 3 May 2005 -- basically just checks that the table is linked to something
                              ConfirmationOK = True
                           End If

                           If (strNewSourceName <> "") And Not ConfirmExclude Then
                              'if they are also specifying a SourceTableName, check to see that it matches also
                              'Note that this test makes no sense if they are doing a ConfirmExclude ... in that case all we need to know is that
                              '   the Connect param is different
                              ConfirmationOK = ConfirmationOK And (ThisTable.SourceTableName = strNewSourceName)
                           End If
                           If Not ConfirmationOK Then retvalConfirmation = SomeLinksNotConsistentWithTargetGroup

                           'NOTE, this check has a higher priorty over the consistency check; that is, if a table
                           ' has a connection string which is not consistent with the desired link group, but also that
                           ' link is invalid (not alive), then the return status will be SomeLinksNotValid
                           If Not LinkIsValid(ThisTable) Then
                              retvalConfirmation = SomeLinksNotValid
                              ConfirmationOK = False
                           End If


                           AllConfirmationsOK = AllConfirmationsOK And ConfirmationOK
'                           If Not ConfirmationOK Then
'                              If MsgBox("WARNING: Link confirmation failure!  While verifying that all linked tables are " & _
'                                       IIf(ConfirmExclude, "NOT ", "") & "linked to the LinkGroup called '" & strLinkGroupName & "', " & _
'                                       "a conflicting link was found for the table '" & ThisTable.Name & "'." & vbCrLf & _
'                                       "Press 'OK' to proceed to next table; 'Cancel' to abort checking the remaining tables.", vbOKCancel Or vbCritical) = vbCancel Then
'                                 Exit For
'                              End If
'                           End If
                           OneTableChecked = True
                           OneTableCheckedOK = ConfirmationOK
                        End If
                        
                        DoEvents
                     Else
                        AllRelinkingOK = False
                        MsgBox "For the table '" & ThisTable.Name & "' no match could be found for the LinkDatasourceName = " & strLinkDatasourceName & vbCrLf & _
                                 "Linking will be aborted."
                        Exit For
                     End If
                  End If
               Else
                  AllRelinkingOK = False
                  If MsgBox("No Auto-link information found for the linked table '" & ThisTable.Name & "'" & vbCrLf & _
                            "Press 'OK' to proceed to next table; 'Cancel' to abort relinking.", vbOKCancel) = vbCancel Then Exit For
               End If
            End If
         
         Else 'If strProperties =""
            AllRelinkingOK = False
            If MsgBox("No Auto-link information found for the linked table '" & ThisTable.Name & "'" & vbCrLf & _
                      "Press 'OK' to proceed to next table; 'Cancel' to abort relinking.", vbOKCancel) = vbCancel Then Exit For
         End If
      End If
      
      If CheckOneTable And OneTableChecked Then Exit For
      If ConfirmLinks And (retvalConfirmation <> LinksAllOK) Then Exit For
      intTablesProcessed = intTablesProcessed + 1
   Next ThisTable
   
   
   Screen.MousePointer = 0 'default
   
   
   If CancelRelinking Then 'Or ((intTablesProcessed <> colTables_Initial.Count) And Not (CheckOneTable  ) Then
      MsgBox "Relinking was terminated prematurely.  Not all tables may not have been relinked."
   End If
   
   Set ThisTable = Nothing
   rsDirections.Close
   
   If UpdateTextBox Then
      strTextMsg = IIf(ConfirmLinks, "Link confirmation check complete.", "Relinking complete.")
      If TypeOf txtStatus Is TextBox Then
         txtStatus = strTextMsg
      ElseIf TypeOf txtStatus Is Label Then
         txtStatus.Caption = strTextMsg
      End If
   End If
   
   If ConfirmLinks Then
      UpdateLinks = retvalConfirmation
   Else
      UpdateLinks = IIf(AllRelinkingOK, eLinkStatus.LinksAllOK, eLinkStatus.SomeLinksNotRefreshed)
      SetCurrentLinkGroupName strLinkGroupName & IIf(AllRelinkingOK, "", " - incomplete!")
   End If
   
Exit Function


UpdateLinks_Relink_Err:
   AllRelinkingOK = False
   LinkErrThisTable = True
   intResponse = MsgBox(Err.Description, vbOKCancel)
   If (intResponse = vbCancel) Then
      CancelRelinking = True
   End If
   Resume Next
   Resume 'for debugging
'
'   AllRelinkingOK = False
'   strErrMsg = "For the table '" & CurrentTableName & "', the link failed." & vbCrLf & _
'        "Error msg: " & Err.Description & vbCrLf & _
'        "ConnectStr was: " & strNewConnectStr & vbCrLf & _
'        IIf(strNewSourceName <> "", "SourceTable was: " & strNewSourceName & vbCrLf, "") & _
'       "Press 'OK' to proceed to next table; 'Cancel' to abort relinking."
'   intResponse = MsgBox(strErrMsg, vbOKCancel)
'
'
'   If (intResponse = vbCancel) Then
'      CancelRelinking = True
'   End If
'   Resume Next
'
'
'UpdateLinks_LinkNewTable_Err:
'   AllRelinkingOK = False
'   LinkErrThisTable = True
'   strErrMsg = "Failed trying to rebuild link to table called '" & CurrentTableName & "'" & vbCrLf & _
'      "Connect string was: " & strNewConnectStr & vbCrLf & _
'       "Error: " & Err.Description & vbCrLf & _
'       "This table may need to be relinked by hand." & vbCrLf & vbCrLf & _
'       "Press 'OK' to proceed to next table; 'Cancel' to abort relinking."
'   intResponse = MsgBox(strErrMsg, vbOKCancel)
'
'   If (intResponse = vbCancel) Then
'      CancelRelinking = True
'   End If
'   Resume Next
'   Resume  'for debugging
End Function


Public Function RelinkTable(ThisTable As DAO.TableDef, strNewConnectStr As String, _
         Optional strNewSourceName As String = "", Optional DisableSubdatasheets As Boolean = False, _
         Optional RefreshLink As Boolean = True) As Boolean
   Dim strTextMsg As String
   Dim CurrentTableName As String
   Dim NewLinkIsODBC As Boolean, LinkErrThisTable As Boolean
   Dim CurrentlyLinked_Access As Boolean, CurrentlyLinked_ODBC As Boolean
   Dim NewLinkedTable As DAO.TableDef
   Dim strErrMsg As String
   Dim db As DAO.Database

   Set db = CurrentDb
   
   CurrentTableName = ThisTable.Name
   CurrentlyLinked_Access = CBool(ThisTable.Attributes And dbAttachedTable)
   CurrentlyLinked_ODBC = CBool(ThisTable.Attributes And dbAttachedODBC)


   NewLinkIsODBC = (InStr(1, strNewConnectStr, "ODBC", vbTextCompare) = 1)
   LinkErrThisTable = False
   'NOTE: if going from an ODBC tables to Access table link, or going from Access link to ODBC,
   '  we must emply a different approach (delete and relink)
   '
   DoEvents  'the next section can take a few seconds, so process user events
   
   If (CurrentlyLinked_Access And Not NewLinkIsODBC) Then ' Or _
      (CurrentlyLinked_ODBC And NewLinkIsODBC) Then
      ThisTable.Connect = strNewConnectStr
      
      If RefreshLink Then
         Err.Clear
         On Error GoTo RelinkTable_RefreshLink_Err
         ThisTable.RefreshLink
         On Error GoTo 0
      Else
         DoEvents
      End If

      Set NewLinkedTable = ThisTable
      'ThisTable.Properties("Description").Value = "{link: " & strNewConnectStr
      
   Else 'If (CurrentlyLinked_Access And NewLinkIsODBC) Or
         '(CurrentlyLinked_ODBC And Not NewLinkIsODBC) Then
      'cannot change from an ODBC link to Access link directly (or other way)
      'So delete the table, and relink it in
                                    
      On Error GoTo RelinkTable_LinkNewTable_Err
      
      Set NewLinkedTable = db.CreateTableDef(ThisTable.Name)
      'set the connection proprties of the new table to be linked
      NewLinkedTable.Connect = strNewConnectStr
      NewLinkedTable.SourceTableName = IIf(strNewSourceName = "", CurrentTableName, strNewSourceName)
      NewLinkedTable.Name = CurrentTableName & "_newlink"  'temporary name
      NewLinkedTable.Attributes = dbAttachSavePWD '+ dbAttachedODBC --- do not try to set "dbAttachedODBC"; illegal for some reason
         'simply specifying the Attribute "dbAttachSavePWD" is sufficient (and necessary to preserve the password in the connect string!)
      
      
      'add new table to the database tables collection
      db.TableDefs.Append NewLinkedTable
      'NewLinkedTable.Attributes = dbAttachedODBC + dbAttachSavePWD

      If RefreshLink Then
         On Error Resume Next 'if the external table could not be linked, will have aleady
           'displayed an error message
         'refresh the new table
         NewLinkedTable.RefreshLink
         On Error GoTo 0
      End If
   
      
      If Not LinkErrThisTable Then 'if did not generate an error, then proceed
         db.TableDefs.Delete ThisTable.Name  'delete the existing table
         NewLinkedTable.Name = CurrentTableName 'rename to the old table name
         'NewLinkedTable.Properties.Append
         'NewLinkedTable.Properties("Description").Value = "{link: " & strNewConnectStr
      Else
         On Error Resume Next  'this next line will generally fail, because the .Append above is typically
               'the point of the error, so it never made it into the Tables collection
         db.TableDefs.Delete NewLinkedTable.Name  'delete the new table
      End If
                                    
      On Error GoTo 0
   End If
   
   DoEvents  'the previous section can take a few seconds, so process user events
   
   'NOTE: for another approach that may have been better, see Microsft Knowledge Base
   ' article "HOWTO: Link and Refresh Linked Jet Tables Using ADOX", Article ID: Q230588
   
   
   If DisableSubdatasheets Then
      SetSubdatasheetName_TableDef NewLinkedTable, "[NONE]"
   End If
   
   Set NewLinkedTable = Nothing

   RelinkTable = (Not LinkErrThisTable)
Exit Function

RelinkTable_RefreshLink_Err:
   LinkErrThisTable = True
   strErrMsg = "For the table '" & CurrentTableName & "', the link failed." & vbCrLf & _
        "Error msg: " & Err.Description & vbCrLf & _
        "ConnectStr was: " & strNewConnectStr & vbCrLf & _
        IIf(strNewSourceName <> "", "SourceTable was: " & strNewSourceName & vbCrLf, "") & _
       "Press 'OK' to proceed to next table; 'Cancel' to abort relinking."

   On Error GoTo 0
   Err.Raise vbObjectError + 512, RelinkTable, strErrMsg


RelinkTable_LinkNewTable_Err:
   LinkErrThisTable = True
   strErrMsg = "Failed trying to rebuild link to table called '" & CurrentTableName & "'" & vbCrLf & _
      "Connect string was: " & strNewConnectStr & vbCrLf & _
       "Error: " & Err.Description & vbCrLf & _
       "This table may need to be relinked by hand." & vbCrLf & vbCrLf & _
       "Press 'OK' to proceed to next table; 'Cancel' to abort relinking."
   Err.Raise vbObjectError + 512, RelinkTable, strErrMsg

End Function


Public Function cboList_LinkedTables(fld As Control, ID As Variant, Row As Variant, col As Variant, _
     code As Variant) As Variant
  'use as a combo-box row source to list all tables in the current database
    Static TableNames() As String, Entries As Integer, i As Integer
    Dim ReturnVal As Variant
    Dim db As DAO.Database, tbl As DAO.TableDef
    
    ReturnVal = Null
    
    Select Case code
        Case acLBInitialize                ' Initialize.
            Set db = CurrentDb
            Entries = 0
            For Each tbl In db.TableDefs
               If (tbl.Attributes And dbAttachedTable) Or (tbl.Attributes And dbAttachedODBC) Then
                  ReDim Preserve TableNames(0 To Entries)
                  TableNames(Entries) = tbl.Name
                  Entries = Entries + 1
               End If
            Next tbl
            
            ReturnVal = Entries
        Case acLBOpen                        ' Open.
            ' Generate unique ID for control.
            ReturnVal = Timer
        Case acLBGetRowCount            ' Get number of rows.
            ReturnVal = Entries
        Case acLBGetColumnCount    ' Get number of columns.
            ReturnVal = 1
        Case acLBGetColumnWidth    ' Column width.
            ' -1 forces use of default width.
            ReturnVal = -1
        Case acLBGetValue                    ' Get data.
            ReturnVal = TableNames(Row)
        Case acLBEnd                        ' End.
            Erase TableNames
    End Select
    cboList_LinkedTables = ReturnVal
End Function

Public Function UpdateLinkStatusTable() As Boolean

   Dim db As DAO.Database
   Dim rsStatus As DAO.Recordset
   Dim ThisTable As DAO.TableDef
   Dim lngAttributes As Long, strAttributes As String
   Dim iTable As Integer

   Set db = CurrentDb
   
   Set rsStatus = db.OpenRecordset("LinkStatus", dbOpenDynaset)
   On Error Resume Next
   rsStatus.MoveFirst
   On Error GoTo 0
   
   Do Until rsStatus.EOF
      rsStatus.Delete
      rsStatus.MoveFirst
   Loop
   
   Screen.MousePointer = 11 'hourglass
   
   For iTable = 0 To db.TableDefs.Count - 1
      Set ThisTable = db.TableDefs(iTable)
      
      'assemble text description of Attributes number
      lngAttributes = ThisTable.Attributes
      strAttributes = ""
      If lngAttributes And dbAttachedTable Then strAttributes = strAttributes & "Attached Table, "
      If lngAttributes And dbAttachedODBC Then strAttributes = strAttributes & "Attached ODBC, "
      If lngAttributes And dbAttachExclusive Then strAttributes = strAttributes & "Attached Exclusive, "
      If lngAttributes And dbAttachSavePWD Then strAttributes = strAttributes & "Saved Password, "
      If lngAttributes And dbSystemObject Then strAttributes = strAttributes & "System Object, "
      If lngAttributes And dbHiddenObject Then strAttributes = strAttributes & "Hidden Object, "
      'if added anything, strip off the final ", "
      If strAttributes <> "" Then strAttributes = Left(strAttributes, Len(strAttributes) - 2)
      
      
      With rsStatus
         .AddNew
         ![TableID] = iTable
         ![Name] = ThisTable.Name
         ![Attributes] = strAttributes
         ![ConnectStr] = ThisTable.Connect
         ![SourceTableName] = ThisTable.SourceTableName
         .Update
      End With
            
   Next iTable
   
   
   Screen.MousePointer = 0 'default
   Set ThisTable = Nothing
   rsStatus.Close
End Function

Public Sub AddLinkedTablesToLinkManagement()
   'look at all linked tables.  If they do not appear on the table 'LinkTableDatasources', add them
   '  and figure out the link datasource

   Dim db As DAO.Database, tbl As DAO.TableDef
   Dim rsLinkTableDatasources As DAO.Recordset, rsLinkDirector As DAO.Recordset
   Dim SomeDatasourceNotFound As Boolean, FoundDatasourceID As Long, TablesAdded As Long
   Dim strMsg As String
   Dim strTableDB_FileTitle As String, strTableDB_FileNameParts() As String
   Dim strSQL As String, strInsertTarget As String

   Set db = CurrentDb
   Set rsLinkTableDatasources = db.OpenRecordset("LinkTableDatasources", dbOpenDynaset)
   Set rsLinkDirector = db.OpenRecordset("LinkDirector_FileTitle", dbOpenSnapshot)
   
   
   For Each tbl In db.TableDefs
      If (tbl.Attributes And dbAttachedTable) Or (tbl.Attributes And dbAttachedODBC) Then
         
         rsLinkTableDatasources.FindFirst "TableName='" & tbl.Name & "'"
         If rsLinkTableDatasources.NoMatch And Not (Left(tbl.Name, 1) = "~") Then
            'must add this table to the LinkTableDatasources
            
            'try to figure out the datasource
            FoundDatasourceID = -1
            strTableDB_FileNameParts = Split(tbl.Connect, "\")  'split the connection string into parts using '\'
            strTableDB_FileTitle = strTableDB_FileNameParts(UBound(strTableDB_FileNameParts)) 'take the last section
            
            rsLinkDirector.FindFirst "DB_FileTitle='" & strTableDB_FileTitle & "'"
            If rsLinkDirector.NoMatch Then
               SomeDatasourceNotFound = True
            Else
               FoundDatasourceID = rsLinkDirector![LinkDataSourceID]
            End If
            
'            With rsLinkTableDatasources
'               .AddNew
'               ![TableName] = tbl.Name
'               If FoundDatasourceID >= 0 Then
'                  ![LinkDataSourceID] = FoundDatasourceID
'               Else
'                  ![LinkDataSourceID] = Null
'               End If
'               .Update
'            End With


         'NOTE: the recordset 'LinkTableDatasources' is no longer a simple table .. it is a UNION query of
         ' tables "LinkTableDatasources_Base" and  "LinkTableDatasources_Override".  Therefore the new value must be
         ' added to one of those tables.
            If strInsertTarget = "" Then
               strInsertTarget = IIf(MsgBox("For new tables, should they be inserted into 'LinkTableDatasources_Base'?" & vbCrLf & _
                "If you respond 'Yes', it will affect relinking in all databases; if 'No' will affect relinking only within this current MDB.", vbYesNo Or vbQuestion) = vbYes, _
                "LinkTableDatasources_Base", "LinkTableDatasources_Override")
            End If
            'insert into the base table
            strSQL = "INSERT INTO [" & strInsertTarget & "] (TableName, LinkDataSourceID) " & _
                     "VALUES ('" & tbl.Name & "'," & IIf(FoundDatasourceID >= 0, CStr(FoundDatasourceID), "Null") & ")"
            On Error Resume Next
            Err.Clear
            db.Execute strSQL
            If Err.Number <> 0 Then
               MsgBox Err.Description
            End If
            On Error GoTo 0

            TablesAdded = TablesAdded + 1
         End If
      End If
   Next tbl

   If TablesAdded > 0 Then
      strMsg = "Tablenames added to the table 'LinkTableDatasources': " & TablesAdded
      If SomeDatasourceNotFound Then
          strMsg = strMsg & vbCrLf & "NOTE: some data sources could not be identified -- you must set manually!"
      End If
   Else
      strMsg = "Found no linked table that are not listed on table 'LinkTableDatasources'"
   End If
   
   MsgBox strMsg

End Sub





Private Function SetSubdatasheetName_TableDef(tblTarget As DAO.TableDef, ValueToSet As String, _
         Optional CurrentValueRestriction As String) As Boolean
   Const RestrictToLocalTables As Boolean = True
      
   
  ' Dim MyProperty As DAO.Property
   Dim propName As String, propVal As String
   Dim propType As Integer, i As Integer
   Dim ErrNumber As Long, ErrDescription As String
   Dim CurrentValueMatchesFilter As Boolean
   Dim CurrentValueMatchesNewValue As Boolean
   Dim prop As DAO.Property


   propName = "SubDataSheetName"
   propType = 10
   propVal = ValueToSet
   
   On Error GoTo SetSubdatasheetName_TableDef_Err
   Set prop = tblTarget.Properties(propName)
   On Error GoTo 0

SetSubdatasheetName_TableDef_PropertyOK:
   CurrentValueMatchesNewValue = False
   CurrentValueMatchesNewValue = (prop.value = propVal)

   CurrentValueMatchesFilter = True
   If CurrentValueRestriction <> "" Then
      CurrentValueMatchesFilter = (UCase(prop.value) Like UCase(VBA.Replace(CurrentValueRestriction, "[", "[[]")))
   End If


   If (Not CurrentValueMatchesNewValue) And CurrentValueMatchesFilter Then
      prop.value = propVal
   End If

   SetSubdatasheetName_TableDef = True
Exit Function


SetSubdatasheetName_TableDef_Err:
   ErrNumber = Err.Number
   ErrDescription = Err.Description

   If ErrNumber = 3270 Then  'if property does not exist; by default will be set to [Auto] until property exists and is set otherwise
      Set prop = tblTarget.CreateProperty(propName)
      prop.Type = propType
      prop.value = propVal
      tblTarget.Properties.Append prop
      Resume SetSubdatasheetName_TableDef_PropertyOK
   Else
      If ErrNumber <> 0 Then
          Err.Raise ErrNumber, "", "Error: in setting SubDataSheetName on Table " _
          & tblTarget.Name & ".  " & vbCrLf & ErrDescription
      End If
   End If
End Function




Function SetSubdatasheetName(Optional ValueToSet As String = "[NONE]", _
          Optional dbTarget As DAO.Database = Nothing, _
          Optional TableNameRestrict As String = "", _
          Optional CurrentValueRestriction As String = "[AUTO]", _
          Optional RestrictToLocalTables As Boolean = False) As Integer
   
   'typically use this function with no parmeters to turn off the Subdatasheet feature for all tables in the
   '  current db.  This is important for performance when linking to these tables from another db.
   
   'Can optionally supply a different database, and/or restrict to a particular table or wildcarded TableNameRestrict filter
   'Or if user already has an active reference to the table def, they can just pass that directly

   'This code modified from code of Microsoft.  See article http://support.microsoft.com/?kbid=261000
   
   'SYMPTOMS
   'You may notice that linked tables in your database have slower performance when you open tables,
   'or that performing updates takes longer than you expect.
   'CAUSE
   'The database has many linked tables that also have many relationships, and the table that you are
   'opening has its subdatasheet Name property set to [Auto]. This can make the table slow to open.
   'RESOLUTION
   'To work around this behavior, set the subdatasheet Name property on each table in the back-end
   'database to [NONE]. You can do this manually or by using code.
   
 '  Const RestrictToLocalTables As Boolean = False
      
   
   Dim MyDB As DAO.Database
   Dim ThisTable As DAO.TableDef
   Dim MyProperty As DAO.Property
   Dim propName As String, propVal As String
   Dim propType As Integer, i As Integer
   Dim IsLocalTable As Boolean, IsSystemObject As Boolean, IsTargetTable As Boolean
   Dim CountTablesSet As Integer

   If dbTarget Is Nothing Then
      Set MyDB = CurrentDb
   Else
      Set MyDB = dbTarget
   End If
   
   propName = "SubDataSheetName"
   propType = 10
   propVal = ValueToSet
   
   On Error Resume Next
   
   For i = 0 To MyDB.TableDefs.Count - 1
      Set ThisTable = MyDB.TableDefs(i)
      IsSystemObject = (ThisTable.Attributes And dbSystemObject) <> 0
      IsLocalTable = (ThisTable.Attributes And dbAttachedTable) = 0
      IsTargetTable = (ThisTable.Name Like TableNameRestrict)

      If (Not IsSystemObject) And _
         (IsLocalTable Or (Not RestrictToLocalTables)) And _
         (IsTargetTable Or (TableNameRestrict = "")) Then
   

         If SetSubdatasheetName_TableDef(ThisTable, ValueToSet, CurrentValueRestriction) Then
            CountTablesSet = CountTablesSet + 1
            Debug.Print CountTablesSet; ": " & ThisTable.Name & " in database " & MyDB.Name
         Else
            MsgBox "Problem setting SubDatasheet value on table: " & ThisTable.Name & " in database " & MyDB.Name
         End If
      End If
   Next i
   
   
   Set MyDB = Nothing

   SetSubdatasheetName = CountTablesSet
End Function

   
Private Sub SetSubdatasheetName_test()
   Dim Count As Integer
   
   Dim db As DAO.Database
   
   Set db = CurrentDb  ' OpenDatabase("C:\Biolims_local\Public\BiolimsDatabaseFiles_Dev\Common.mdb", , False)
   Count = SetSubdatasheetName("[NONE]", db) ', "a*")
   db.Close

   Debug.Print Count
End Sub

Public Sub SetSubdatasheetProperty_EntireDb(Optional strDatabasePath As String = "", Optional SetToAuto As Boolean = False)
   Dim Count As Integer
   Dim db As DAO.Database
   
   If strDatabasePath <> "" Then
      Set db = OpenDatabase(strDatabasePath, , False)
   Else
      Set db = CurrentDb
   End If

   Count = SetSubdatasheetName(IIf(SetToAuto, "[AUTO]", "[NONE]"), db)

   If strDatabasePath <> "" Then
      db.Close
   End If
End Sub
   

Private Function LinkTableNames() As Collection
   Dim colLinkTables As New Collection

   colLinkTables.Add "LinkDatasources"
   colLinkTables.Add "LinkDirector"
   colLinkTables.Add "LinkGroups"
   colLinkTables.Add "LinkTableDatasources_Base"

   Set LinkTableNames = colLinkTables
End Function

Public Function LinkTablesAreValid() As Boolean
   Dim colLinkTables As Collection
   Dim fso As New Scripting.FileSystemObject
   Dim i As Integer, SomeLinkInvalid As Boolean
   Dim tblDef As DAO.TableDef
   Dim db As DAO.Database
   
   Set db = CurrentDb
   Set colLinkTables = LinkTableNames

   For i = 1 To colLinkTables.Count
      Set tblDef = db.TableDefs(CStr(colLinkTables(i)))
      If IsALinkedTable(tblDef) Then
         SomeLinkInvalid = SomeLinkInvalid Or (Not LinkIsValid(tblDef))
      End If

      If SomeLinkInvalid Then Exit For
   Next i

   LinkTablesAreValid = (Not SomeLinkInvalid)
End Function

Public Function IsALinkedTable(tblDef As DAO.TableDef) As Boolean
   IsALinkedTable = ((tblDef.Attributes And dbAttachedTable) Or (tblDef.Attributes And dbAttachedODBC))
End Function

Public Function LinkIsValid(tblDef As DAO.TableDef) As Boolean
   On Error GoTo LinkIsValid_Err
   If IsALinkedTable(tblDef) Then
      tblDef.RefreshLink
      LinkIsValid = True
   Else
      'could raise an error, or just report that all is well
      LinkIsValid = True
   End If
Exit Function

LinkIsValid_Err:
   LinkIsValid = False
   If Err.Number = 3024 Then 'could not find path
   ElseIf Err.Number = 3044 Then 'link not valid

   Else
      MsgBox "Unexpected error code in 'LinkIsValid', please report to programmer.  Error number: " & Err.Number & vbCrLf & _
         Err.Description
   End If
End Function

Public Function RelinkingBootstrap(Optional strPathTo_LinkManagerMDB As String = "", Optional txtStatus As TextBox = Nothing) As Boolean
   'The idea of this is that if you move a front end into a place where even the links to the Linking tables
   ' are invalid, it is impossible to relink using the link manager system.  Therefore, relink the linking
   ' tables themselves!  If the caller does not pass a path to a LinkManager.mdb file, then looks in the current
   ' application folder for one.
   
   
   Dim strLinkDb As String
   Dim fso As New Scripting.FileSystemObject
   Dim colLinkTables As Collection
   Dim i As Integer, SomeLinkInvalid As Boolean, RelinkOK As Boolean
   Dim db As DAO.Database, tblDef As DAO.TableDef
   Dim strNewConnectStr As String

   Set db = Application.CurrentDb

   If strPathTo_LinkManagerMDB = "" Then
      strLinkDb = Application.CurrentProject.Path & "\LinkManager.mdb"
   Else
      strLinkDb = strPathTo_LinkManagerMDB
   End If

   If fso.FileExists(strLinkDb) Then
      Set colLinkTables = LinkTableNames
   
      strNewConnectStr = ";DATABASE=" & strLinkDb
      SomeLinkInvalid = False

      For i = 1 To colLinkTables.Count
         Set tblDef = db.TableDefs(CStr(colLinkTables(i)))
         If Not (txtStatus Is Nothing) Then txtStatus = "Relinking " & tblDef.Name
         DoEvents
         RelinkOK = RelinkTable(tblDef, strNewConnectStr)
         SomeLinkInvalid = SomeLinkInvalid Or (Not RelinkOK)
         If SomeLinkInvalid Then Exit For
      Next i

      RelinkingBootstrap = (Not SomeLinkInvalid)
   Else
      RelinkingBootstrap = False
   End If

End Function

----------- end of component
Component: clsParser; Class module
Option Explicit

'local variable(s) to hold property value(s)
Private mvarParameter() As Variant 'local copy
Private nParameterCount As Integer 'local copy
Private sDelimiter As String
Private mstrInputLine As String

Private mSuccessiveDelimitersAsOne As Boolean
Private mMarkPosition_InputStr As Integer, mMarkParameter As Integer, mMarkCharPos As Integer
Public Property Get MarkPosition() As Integer
   MarkPosition = mMarkPosition_InputStr
End Property

Public Sub ParseLine(strInputLine As String)
   Dim NextDelimiter As Integer, PrevDelimiter As Integer
   Dim MarkedPositionFound As Boolean
   
   If sDelimiter = "" Then
      Err.Raise vbObjectError, "clsParser", "Must define delimiter."
      Exit Sub
   End If
   
   mstrInputLine = strInputLine
   
   nParameterCount = 0
   Erase mvarParameter
   
   If Len(strInputLine) = 0 Then Exit Sub
   
   mMarkParameter = 0
   mMarkCharPos = 0
   MarkedPositionFound = False
   
   NextDelimiter = 0
   PrevDelimiter = 0
   
   Do
      NextDelimiter = InStr(NextDelimiter + 1, strInputLine, sDelimiter, vbBinaryCompare)
      If NextDelimiter = 0 Then NextDelimiter = Len(strInputLine) + 1
      
      If (Not mSuccessiveDelimitersAsOne) Or _
         (mSuccessiveDelimitersAsOne And (NextDelimiter - PrevDelimiter) > Len(sDelimiter)) Then
      'if user wants to treat successive delimiters as one (e.g. if using a ' ' as delimiter, then
      ' the above test will only create a new mvarParameter if there is at least one non-delimiter character
      ' between the PrevDelimiter and the NextDelimiter
      
         nParameterCount = nParameterCount + 1
         ReDim Preserve mvarParameter(0 To nParameterCount - 1)
         mvarParameter(nParameterCount - 1) = Mid(strInputLine, PrevDelimiter + 1, _
           NextDelimiter - PrevDelimiter - 1)
      
         If (mMarkPosition_InputStr > 0) And (Not MarkedPositionFound) And (NextDelimiter > mMarkPosition_InputStr) Then
           'if user wants to track the desitiny of a given char, and if it is encompassed in this current segment
            'For example, for the input string "Asp-1223345---d[ImPy2]-Dp", lets say that you want to know where the
            '  '[' winds up after parsing.      12345678901234567890123
            '  You would call this sub with the intPositionToMark=14 (char pos of the '[' in the original string).
            '  Then you would pass the input string to ParseLine, which will split into the following Parameters
            '  Parameter(0)="Asp"
            '  Parameter(1)="1223345"
            '  Parameter(2)="d[ImPy2]"
            '  Parameter(3)="Dp"
            '
            'You can the call the sub "LocateMark" to retrieve the Parameter/Char Pos of the marked char, which will
            '   return ParameterIndex=2, CharPosition=2
            'Note: if you mark one of the delimiter characters, "LocateMark" will return the ParameterIndex of the
            '  preceeding section, and CharPosition=0
            MarkedPositionFound = True
            mMarkParameter = nParameterCount - 1
            If mMarkPosition_InputStr > PrevDelimiter Then
               mMarkCharPos = mMarkPosition_InputStr - PrevDelimiter
            Else
              'Note: if you mark one of the delimiter characters, it will be <= to PrevDelimiter; in this case, since
              '  that char is not part of any Parameter, set its char pos = 0
              '  preceeding section, and CharPosition=0
               mMarkCharPos = 0
            End If
         End If
      
      
      
      End If
      
      PrevDelimiter = NextDelimiter + Len(sDelimiter) - 1
   Loop Until NextDelimiter >= Len(strInputLine)

   
   If (mMarkPosition_InputStr > 0) And (Not MarkedPositionFound) Then
      mMarkParameter = Me.ParameterCount
      mMarkCharPos = 0
   End If

End Sub


Public Property Get MarkPosition_ParameterIndex() As Integer
   MarkPosition_ParameterIndex = mMarkParameter
End Property

Public Property Get MarkPosition_CharPosition() As Integer
   MarkPosition_CharPosition = mMarkCharPos
End Property

Public Property Get ParameterCount() As Integer
'used when retrieving value of a property, on the right side of an assignment.
'Syntax: Debug.Print X.ParameterCount
    ParameterCount = nParameterCount
End Property

Public Property Get Parameter(index As Integer) As Variant
'used when retrieving value of a property, on the right side of an assignment.
'Syntax: Debug.Print X.Parameter
   If index < 0 Or index >= nParameterCount Then
      Err.Clear
      Err.Raise vbObjectError, "clsParser", "Index out of range"
      Exit Property
   End If
   
   If IsObject(mvarParameter(index)) Then
       Set Parameter = mvarParameter(index)
   Else
       Parameter = mvarParameter(index)
   End If

End Property

Private Sub Class_Terminate()
   Erase mvarParameter
End Sub

Public Property Get Delimiter() As String
   Delimiter = sDelimiter
End Property

Public Property Let Delimiter(ByVal sNewValue As String)
   sDelimiter = sNewValue
End Property

Public Property Let MarkPosition(intPositionToMark As Integer)
   'using this procedure *before* parsing the user-supplied line request that the
   ' parser keep track of where the given character ends up in the final parameters
   '
   'For example, for the input string "Asp-1223345-d[ImPy2]-Dp", lets say that you want to know where the
   '  '[' winds up after parsing.      12345678901234567890123
   '  You would call this sub with the intPositionToMark=14 (char pos of the '[' in the original string).
   '  Then you would pass the input string to ParseLine, which will split into the following Parameters
   '  Parameter(0)="Asp"
   '  Parameter(1)="1223345"
   '  Parameter(2)="d[ImPy2]"
   '  Parameter(3)="Dp"
   '
   'You can the call the sub "LocateMark" to retrieve the Parameter/Char Pos of the marked char, which will
   '   return ParameterIndex=2, CharPosition=2
   'Note: if you mark one of the delimiter characters, "LocateMark" will return the ParameterIndex of the
   '  subsequent section, and CharPosition=0
   
   
   mMarkPosition_InputStr = intPositionToMark
   
End Property



Public Property Get SuccessiveDelimitersAsOne() As Boolean
   SuccessiveDelimitersAsOne = mSuccessiveDelimitersAsOne
End Property

Public Property Let SuccessiveDelimitersAsOne(ByVal bNewValue As Boolean)
   mSuccessiveDelimitersAsOne = bNewValue
End Property
----------- end of component
Component: clsFilename; Class module
Option Explicit

Private CompleteFilename_pr As String
Private FilePath_pr As String
Private FileTitle_pr As String
Private Corename_pr As String
Private Extension_pr As String

Private FinalSlashOnPath_pr As Boolean



Public Property Get Path() As String
   If (Not FinalSlashOnPath_pr) And (Right(FilePath_pr, 1) = "\") Then
      'if the user wants the path returned WITHOUT the final "\" (and, if the path that we have stored
      '  has a '\' as its final character), return everything except the last char
      Path = Left(FilePath_pr, Len(FilePath_pr) - 1)
   Else
      Path = FilePath_pr
      'note: path includes the last '\'
   End If

End Property


Public Property Let Path(value As String)
   Dim newpath_withslash As String
   newpath_withslash = value
   If Right(newpath_withslash, 1) <> "\" Then
      newpath_withslash = newpath_withslash & "\"
   End If
   
   Me.Filename = newpath_withslash & Me.FileTitle
End Property

Public Property Get FileTitle() As String
   FileTitle = FileTitle_pr
   
End Property


Public Property Let FileTitle(sNewValue As String)
   'if user calls this, keeps any exisiting path information, and just replaces the
   '  FileTitle, corename, and extension
   
   FileTitle_pr = sNewValue
   Dim LastPeriodPos As Integer
   LastPeriodPos = InStrRev(FileTitle_pr, ".")
   If LastPeriodPos > 0 Then
      Corename_pr = Left(FileTitle_pr, LastPeriodPos - 1)
      Extension_pr = Mid(FileTitle_pr, LastPeriodPos)
   Else
      Corename_pr = FileTitle_pr
      Extension_pr = ""
   End If
   
End Property


Public Property Get Filename() As String
   
   Filename = Me.Path & Me.FileTitle

End Property

Public Property Let Filename(ByVal sUserFilename As String)

   
   Dim SlashPos As Integer
   Dim LastSlashPos As Integer
   Dim ColonPos As Integer

   If sUserFilename = "" Then
      CompleteFilename_pr = ""
      FilePath_pr = ""
      FileTitle_pr = ""
      Corename_pr = ""
      Extension_pr = ""
      Exit Property
   End If

   CompleteFilename_pr = sUserFilename

   SlashPos = InStr(SlashPos + 1, CompleteFilename_pr, "\")
   If SlashPos = 0 Then 'no backslash; get current path to turn this into a fully qualified path
   ' look for just a colon
      If InStr(CompleteFilename_pr, ":") = 2 Then 'e.g.  "C:test.txt"
         CompleteFilename_pr = CurDir(Left(CompleteFilename_pr, 1)) & "\" & CompleteFilename_pr
      Else
         CompleteFilename_pr = CurDir & "\" & CompleteFilename_pr
      End If
   End If
   
   SlashPos = 0
   Do
      SlashPos = InStr(SlashPos + 1, CompleteFilename_pr, "\")
      If SlashPos > 0 Then LastSlashPos = SlashPos
   Loop Until SlashPos = 0
   
   FilePath_pr = Left(CompleteFilename_pr, LastSlashPos)  'note: path includes the last '\'
   Me.FileTitle = Mid(CompleteFilename_pr, LastSlashPos + 1)

End Property

Public Property Get Corename() As String
   Corename = Corename_pr
End Property


Public Property Get Extension() As String
   Extension = Extension_pr
   'extension includes the "."
End Property

Private Sub Class_Initialize()
   FinalSlashOnPath_pr = True
End Sub



Public Property Get FinalSlashOnPath() As Boolean
   FinalSlashOnPath = FinalSlashOnPath_pr
End Property

Public Property Let FinalSlashOnPath(ByVal bNewValue As Boolean)
   FinalSlashOnPath_pr = bNewValue
End Property
----------- end of component
Component: modASL_Processing; Standard module
Option Compare Database
Option Explicit

Const ModuleName As String = "modASL_Processing"

Private mobjMatlab As clsMatLab

'return value indicates if processing completed.  Return value is False if there was some error in processing, or if we hit a Pause Processing step
Public Function DoASL_Processing(SessionID As Long, _
            Optional ShowLogWindows As Boolean = False, _
            Optional ForceProcessing_StepName As String = "", _
            Optional LogFilename As String = "") As eProcessingStatus
            
   Dim return_value As eProcessingStatus
   return_value = eProcessingStatus.Unknown
   Dim strmLogFile As Scripting.TextStream
   Dim DidSomeProcessing As Boolean
   
   On Error GoTo DoASL_Processing_Err
   
   If LogFilename <> "" Then
      Dim fso As New FileSystemObject
      Set strmLogFile = fso.OpenTextFile(LogFilename, ForAppending, True)
   End If
   
   Dim oSession As New clsSession
   oSession.SessionID = SessionID
   
   Dim psi As New clsProcessingStepInfo
   psi.SessionID = oSession.SessionID
   psi.ProcessingStepGroupName = "ASL quantitation"
   
   Dim rsProcessingSteps As New ADODB.Recordset
   Dim strSQL As String
   strSQL = "SELECT * FROM ProcessingStep WHERE EnableStep=True AND ProcessingStepGroupID=" & psi.ProcessingStepGroupID & " ORDER BY ProcessingOrder ASC"
   rsProcessingSteps.Open strSQL, CurrentProject.Connection, adOpenStatic, adLockReadOnly
    
   Dim strMessage As String
   
   Do Until rsProcessingSteps.EOF
      psi.ProcessingStepName = rsProcessingSteps![ProcessingStep].value
      
      Dim ForceCBF_Recalculation As Boolean

      ForceCBF_Recalculation = CBool(modMRI_Common.GetSettingValue("Force CBF Recalculation", SessionID:=SessionID, ValueIfNotFound:="false"))
         
      If (Not psi.GetStatus) Or _
         (ForceProcessing_StepName <> "" And psi.ProcessingStepName = ForceProcessing_StepName) Or _
         (ForceCBF_Recalculation And _
         ((psi.ProcessingStepName = "CBF computation") Or (psi.ProcessingStepName = "CBF computation SIMPLE"))) Then
        
         If Not psi.DependenciesMet Then
            return_value = UnmetDependency
            If Not (strmLogFile Is Nothing) Then
               strmLogFile.WriteLine "Interrupting processing of SessionID=" & SessionID & ", ProcessingStep='" & rsProcessingSteps![ProcessingStep] & "'; this step requires previous completion of step '" & psi.ProcessingStepName_Dependency & "'."
            End If
            Exit Do  'assume that if we have an unmet dependency, we cannot proceed to the next step
         Else
            DidSomeProcessing = True
            
            If Not (strmLogFile Is Nothing) Then
               strmLogFile.WriteLine "Beginning processing for SessionID=" & SessionID & "; ProcessingStep='" & rsProcessingSteps![ProcessingStep] & "'"
            End If
            
            Select Case psi.ProcessingStepName
               Case "Copy ASL and Anatomical Nii files"
                  Do_CopyASL_NiiFiles oSession, psi, strmLogFile, ShowLogWindows
               
               Case "Extract ASL Image params"
                  Do_ExtractASL_ImageParams oSession, psi, strmLogFile, ShowLogWindows
   
               Case "Extract M0 and PASL Nii"
                  Do_ExtractM0andPASL_Nii oSession, psi, strmLogFile, ShowLogWindows
                  
               Case "CBF calc preparation", "TPM computation"
                  Do_CBF_Preparation oSession, psi, strmLogFile, ShowLogWindows
               
               Case "CBF computation", "CBF computation SIMPLE"
                  Do_CBF_Compute oSession, psi, strmLogFile, ShowLogWindows
                                 
               Case "ASL ROI Summarization"
                  Do_ASL_ROI_Summarization oSession, psi, strmLogFile, ShowLogWindows
                  
               Case "Extract ASL ROI Data"
                  Do_ExtractASL_ROI_Data oSession, psi, strmLogFile, ShowLogWindows
                  
               Case Else
                    Err.Raise vbObjectError + 512, "DoASL_Processing", _
                  "Unrecognized value for ProcessingStep: '" & rsProcessingSteps![ProcessingStep] & _
                  "' (ProcessingStepID=" & rsProcessingSteps![ProcessingStepID] & ")"
            End Select
            
            If Not (strmLogFile Is Nothing) Then
               strmLogFile.WriteLine "Completed processing for SessionID=" & SessionID & "; Processing Group=" & psi.ProcessingStepGroupName & "; ProcessingStep='" & rsProcessingSteps![ProcessingStep] & "'"
            End If
            
            If Not psi.ProcessingComplete Then  'if the step we just tried to execute did not complete, exit the loop
               return_value = ProcessingError
               Exit Do
            End If
         End If
      End If
      
      rsProcessingSteps.MoveNext
   Loop
   rsProcessingSteps.Close
   
   If return_value = eProcessingStatus.Unknown Then
      return_value = IIf(DidSomeProcessing, eProcessingStatus.Completed, eProcessingStatus.NothingToDo)
   End If
   
DoASL_Processing_Exit:
   If Not (strmLogFile Is Nothing) Then
      strmLogFile.Close
   End If
   DoASL_Processing = return_value
Exit Function

DoASL_Processing_Err:
   If Not (strmLogFile Is Nothing) Then
      strmLogFile.Close
   End If
   Dim strErrorMessage As String
   strErrorMessage = "Processing error: " & Err.Description
   If Not (rsProcessingSteps Is Nothing) Then
      If rsProcessingSteps.State = 1 Then
         If Not (rsProcessingSteps.EOF Or rsProcessingSteps.BOF) Then
            strErrorMessage = "Error while processing for ProcessingStep '" & rsProcessingSteps![ProcessingStep] & _
                  "' (ProcessingStepID=" & rsProcessingSteps![ProcessingStepID] & ")" & vbCrLf & _
                  strErrorMessage
         End If
         rsProcessingSteps.Close
      End If
   End If
   
   Err.Raise vbObjectError + 512, "DoASL_Processing", strErrorMessage

   
End Function

''' copy MPRAGE and all ASL files to subfolders.
Private Sub Do_CopyASL_NiiFiles(oSession As clsSession, psi As clsProcessingStepInfo, strmLogFile As Scripting.TextStream, ShowLogWindows As Boolean)
   Const MethodName As String = "Do_CopyASL_NiiFiles"
   Debug.Print ModuleName & "." & MethodName & " for SessionID=" & oSession.SessionID
   
   psi.StartProcessing_Now


   Dim strAnatomicalImagePattern As String, strAnatomicalSubfolderName As String, strAnatomicalImageRenamePattern As String
   Dim strASL_ImagePattern As String, strASL_SubfolderNamePattern As String, strASL_NiiRenamePattern As String
   Dim strFilesProduced As String
   
   strAnatomicalImagePattern = GetSettingValue(SettingName:="Anatomical Scan Filename pattern", SessionID:=oSession.SessionID)
   strAnatomicalImageRenamePattern = GetSettingValue(SettingName:="Anatomical Nii rename pattern", ProcessingStepID:=psi.ProcessingStepID, SessionID:=oSession.SessionID)
   strAnatomicalSubfolderName = GetSettingValue(SettingName:="Anatomical subfolder name", ProcessingStepID:=psi.ProcessingStepID, SessionID:=oSession.SessionID)
   strASL_ImagePattern = GetSettingValue(SettingName:="ASL Scan Filename pattern", SessionID:=oSession.SessionID)
   strASL_SubfolderNamePattern = GetSettingValue(SettingName:="ASL subfolder name pattern", ProcessingStepID:=psi.ProcessingStepID, SessionID:=oSession.SessionID)
   strASL_NiiRenamePattern = GetSettingValue(SettingName:="ASL Nii rename pattern", ProcessingStepID:=psi.ProcessingStepID, SessionID:=oSession.SessionID)
   
   Dim strAnatomicalFolderPath As String
   strAnatomicalFolderPath = oSession.SessionPath_ASL & "\" & strAnatomicalSubfolderName
   
   Dim fil As Scripting.File
   Dim fso As New Scripting.FileSystemObject
'   Dim AnatomicalImages_Count As Integer
'   Dim filAnatomicalImage As Scripting.File
'   'first confirm there is only one anatomical image
'   For Each fil In fso.GetFolder(oSession.SessionPath_Nii).Files
'      If modUtility.RegEx_Test(fil.Name, strAnatomicalImagePattern) Then
'         AnatomicalImages_Count = AnatomicalImages_Count + 1
'         Set filAnatomicalImage = fil
'      End If
'   Next
'
'   If AnatomicalImages_Count <> 1 Then
'      Err.Raise vbObjectError + 512, ModuleName & "." & MethodName, "Expected to find one anatomical Nii image, but found " & AnatomicalImages_Count & " image files."
'   Else

   Dim strAnatomicalImage As String
   Dim filAnatomicalImage As Scripting.File

   strAnatomicalImage = modBasicProcessing.DesignatedAnatomicalImageFilepath(oSession.SessionID)

   If strAnatomicalImage = "" Then
      Err.Raise vbObjectError + 512, "CopyAnatomicalImage", "Failed to find one designated MPRAGE anatomical image."
   Else
      Set filAnatomicalImage = fso.GetFile(strAnatomicalImage)
      Dim strImageFilename_Rename As String
      strImageFilename_Rename = modUtility.RegEx_Substitute(filAnatomicalImage.Name, strAnatomicalImagePattern, strAnatomicalImageRenamePattern)
      modUtility.CreatePath strAnatomicalFolderPath
      
      Dim strImageFilename_FileCompletePath As String
      strImageFilename_FileCompletePath = strAnatomicalFolderPath & "\" & strImageFilename_Rename
      fso.CopyFile filAnatomicalImage.Path, strImageFilename_FileCompletePath
      
      psi.StepOutput_Add "Anatomical", strImageFilename_FileCompletePath
   End If

   strFilesProduced = strImageFilename_Rename
   If Not (strmLogFile Is Nothing) Then strmLogFile.WriteLine "Copied """ & filAnatomicalImage.Path & """ to """ & strImageFilename_FileCompletePath & """"

   Dim ASL_Scans_Count As Integer
   Dim fldASL_ThisIteration As Scripting.Folder
   
   'copy each valid ASL Nii to separate subfolders
   Dim intStudyTypeID_ASL As Integer
   intStudyTypeID_ASL = CInt(DLookup("StudyTypeID", "StudyType", "StudyType='ASL'"))
   
   'scan first to find the ASL files and put them in a list that is sortable by the scan index number
   Dim dicASL_Files As New Scripting.Dictionary
   Dim intScanIndex As Integer, maxScanIndex As Integer
   maxScanIndex = -1
   For Each fil In fso.GetFolder(oSession.SessionPath_Nii).Files
      If modUtility.RegEx_Test(fil.Name, strASL_ImagePattern) Then
         intScanIndex = CInt(modUtility.RegEx_ExtractSubstrings(fil.Name, strASL_ImagePattern)(1))
         dicASL_Files.Add intScanIndex, fil.Path
         If (intScanIndex > maxScanIndex) Then maxScanIndex = intScanIndex
      End If
   Next
   
   'now access the dictionary items in ascending order of scan index
   Dim i As Integer
   For i = 1 To maxScanIndex  'look for scan numbers from 1 to the max scan number we saw when building the dictionary
      If dicASL_Files.Exists(i) Then
         Set fil = fso.GetFile(dicASL_Files(i))
         
         ASL_Scans_Count = ASL_Scans_Count + 1
         Dim strASL_SubfolderPath  As String
         strASL_SubfolderPath = oSession.SessionPath_ASL & "\" & strASL_SubfolderNamePattern
         strASL_SubfolderPath = Replace(strASL_SubfolderPath, "{Iteration}", CStr(ASL_Scans_Count))
         modUtility.CreatePath strASL_SubfolderPath
         Set fldASL_ThisIteration = fso.GetFolder(strASL_SubfolderPath)
         
         Dim strAsl_FileRenamed As String
         
         If fldASL_ThisIteration Is Nothing Then
            Err.Raise vbObjectError + 512, ModuleName & ":" & MethodName, "Failed to create ASL folder: " & strASL_SubfolderPath
         Else
            Dim strASL_FileCompletePath As String
            'first copy the original file
            strASL_FileCompletePath = fldASL_ThisIteration.Path & "\" & fil.Name
            fso.CopyFile fil.Path, strASL_FileCompletePath
         
'            'now copy the file and rename to desired format
'            strAsl_FileRenamed = modUtility.RegEx_Substitute(fil.Name, strASL_ImagePattern, strASL_NiiRenamePattern)
'            strASL_FileCompletePath = fldASL_ThisIteration.Path & "\" & strAsl_FileRenamed
'            fso.CopyFile fil.Path, strASL_FileCompletePath
            
            strFilesProduced = strFilesProduced & IIf(strFilesProduced <> "", "|", "") & strAsl_FileRenamed
            psi.StepOutput_Add "ASL", strASL_FileCompletePath, ASL_Scans_Count
            
            'also create a Study record
            Dim rs As New ADODB.Recordset
            Dim strSQL As String
            strSQL = "SELECT * FROM Study WHERE SessionID=" & oSession.SessionID & " AND StudyTypeID=" & intStudyTypeID_ASL & " AND Iteration=" & ASL_Scans_Count
            
            rs.Open strSQL, CurrentProject.Connection, adOpenStatic, adLockOptimistic
            If rs.EOF Then 'if failed to find a matching record, add one
               rs.AddNew
               rs![StudyTypeID] = intStudyTypeID_ASL
               rs![SessionID] = oSession.SessionID
               rs![Iteration] = ASL_Scans_Count
            End If
            
            rs![filepath] = fldASL_ThisIteration.Path
            rs.Update
            rs.Close
         End If
      End If
   Next

   If ASL_Scans_Count = 0 Then
      psi.ResultValue = ""
      psi.ResultComment = "Failed to find any ASL image NII files in folder:" & oSession.SessionPath_Nii
      psi.Save_NotCompleteNow
     ' Err.Raise vbObjectError + 512, ModuleName & ":" & MethodName, psi.ResultComment
   Else
      psi.ResultValue = strFilesProduced
      psi.ResultComment = "Copied anatomical image and " & ASL_Scans_Count & " ASL image files to subfolders"
      psi.Save_CompleteNow
   End If

End Sub

Private Function Extract_JSON_Info(json_filename As String, ParameterName As String) As String
   Dim fso As New Scripting.FileSystemObject
   Dim strParamValue As String
   
   If fso.FileExists(json_filename) Then
      Dim strFileContent As String
      Dim strm As Scripting.TextStream
      Dim strPattern As String
      
      Set strm = fso.OpenTextFile(json_filename, ForReading)
      strFileContent = strm.ReadAll
      strm.Close
      strPattern = "'" & ParameterName & "'\s*:\s*'(.*?)'"
      strPattern = Replace(strPattern, "'", """")
      strParamValue = modUtility.RegEx_ExtractSubstring(strFileContent, strPattern, True)
      
   End If
   
   Extract_JSON_Info = strParamValue
End Function


Private Sub Do_ExtractASL_ImageParams(oSession As clsSession, psi As clsProcessingStepInfo, strmLogFile As Scripting.TextStream, ShowLogWindows As Boolean)
   Const MethodName As String = "Do_ExtractASL_ImageParams"
   Debug.Print ModuleName & "." & MethodName & " for SessionID=" & oSession.SessionID
   
   psi.StartProcessing_Now

   Const Commandline_base As String = "CWRU_ASL_ExtractImageParams(['{filepath}']);"
   Dim strCommandLine As String
   Dim strMatlabResponse As String
   Dim fn As New clsFilename
   Dim strRegExPattern_Extraction As String
   
   Dim psi_ASLCopy As New clsProcessingStepInfo
   If Not psi_ASLCopy.LoadSessionProcessingStep(oSession.SessionID, "ASL quantitation", "Copy ASL and Anatomical Nii files") Then
      Err.Raise vbObjectError + 512, ModuleName & "." & MethodName, "Failed to find a completed processing step '" & psi_ASLCopy.ToString_GroupAndStep() & "'"
   Else
      If mobjMatlab Is Nothing Then
         Set mobjMatlab = New clsMatLab
      End If
      
      strMatlabResponse = mobjMatlab.Execute("cd '" & GetSettingValue("ASL Matlab code folder", ErrorIfNotFound:=True) & "'")
      
      psi.ResultValue = ""
      Dim pso As clsProcessingStepOuptut
      Dim strFilesProcessed As String
      Dim fso As New Scripting.FileSystemObject
      Dim json_filename As String
      Dim fi As New clsFilename
      Dim strAcquisitionTime As String
      
      For Each pso In psi_ASLCopy.StepOutputs
         fi.Filename = pso.OutputFilename
         'HACK: the filename we have stored for the anatomical image is the name we changed to when copying to the ASL mprage folder,
         '  but we need the original filename... which we don't have.  So just to a search for it
         If pso.OutputType = "Anatomical" Then
            Dim fld As Scripting.Folder
            Dim fil As Scripting.File
            Set fld = fso.GetFolder(oSession.SessionPath_Nii)
            
            For Each fil In fld.Files
               If fil.ShortName Like "*mprage*.json" Then
                  json_filename = fil.Path
                  Exit For
               End If
            Next
         Else
            json_filename = oSession.SessionPath_Nii & "\" & fi.Corename & ".json"
         End If
         strAcquisitionTime = Extract_JSON_Info(json_filename, "AcquisitionTime")
         
         Select Case pso.OutputType
            Case "Anatomical"
               psi.StepOutput_Add "AcquisitionTime", json_filename, Iteration:=pso.Iteration, OutputInformation:=strAcquisitionTime
               
            Case "ASL"
               psi.StepOutput_Add "AcquisitionTime", json_filename, Iteration:=pso.Iteration, OutputInformation:=strAcquisitionTime

               strCommandLine = Replace(Commandline_base, "{filepath}", pso.OutputFilename)
               strMatlabResponse = mobjMatlab.Execute(strCommandLine)
               
'Expect a response like:
'Params for NII file: C:\Users\WPAFB\Documents\MRI Processing\MRI Data\WPAFB HyperO2\CW005\ASL\asl_1\104_ASL_2D_tra_CURRENT_8mm_200mm.sat_ROOMAIR_9.nii
'  CountImages=91
'  Xdim=64
'  Ydim=64
'  Zdim=15
'------
               strRegExPattern_Extraction = "^Params for NII file: (.*)$[\r\n]+((\s{2}\w+=.+[\r\n]+){1,})------"
               
               If modUtility.RegEx_Test(strMatlabResponse, strRegExPattern_Extraction) Then
                  Dim mat As VBScript_RegExp_55.Match, mats As VBScript_RegExp_55.MatchCollection
                  Set mats = modUtility.RegEx_ExtractMatches(strMatlabResponse, strRegExPattern_Extraction)
                  strFilesProcessed = mats(0).SubMatches(0)
                  'mats(0).Submatches(1) contains the whole parameter list.  Break into lines to process
                  For Each mat In modUtility.RegEx_ExtractMatches(mats(0).SubMatches(1), "\s{2}(\w+)=(.+)[\r\n]+", MatchAll:=True)
                    
                     psi.StepOutput_Add mat.SubMatches(0), "", Iteration:=pso.Iteration, OutputInformation:=mat.SubMatches(1)
                  Next
                  
               Else
                  psi.ResultValue = "FAILED"
                  psi.ResultComment = strMatlabResponse
                  psi.ProcessingComplete = False
                  psi.ProcessingEndTime = Now
                  Exit For
               End If
         End Select
      Next
      
      If Not (psi.ResultValue = "FAILED") Then
         psi.ResultValue = Left(strFilesProcessed, 255)
         psi.ProcessingComplete = True
         psi.ProcessingEndTime = Now
      End If
   End If

   psi.Save
End Sub
   


'"C:\<a long path here>\matlab.exe" -nodisplay -nosplash -nodesktop -r "run('C:\<a long path here>\mfile.m');exit;"

Private Sub Do_ExtractM0andPASL_Nii(oSession As clsSession, psi As clsProcessingStepInfo, strmLogFile As Scripting.TextStream, ShowLogWindows As Boolean)
   
   Const MethodName As String = "Do_ExtractM0andPASL_Nii"
   Debug.Print ModuleName & "." & MethodName & " for SessionID=" & oSession.SessionID
   
   psi.StartProcessing_Now

   Const Commandline_base As String = "CWRU_ASL_Nii_ExtractM0(['{filepath}']);"
   Dim strCommandLine As String
   Dim strMatlabResponse As String
   Dim fn As New clsFilename
   Dim strRegExPattern_Success As String
   strRegExPattern_Success = "^Produced M0.nii and PASL.nii from input file: ""(.*)""$"
   
   Dim psi_ASLCopy As New clsProcessingStepInfo
   If Not psi_ASLCopy.LoadSessionProcessingStep(oSession.SessionID, "ASL quantitation", "Copy ASL and Anatomical Nii files") Then
      Err.Raise vbObjectError + 512, ModuleName & "." & MethodName, "Failed to find a completed processing step '" & psi_ASLCopy.ToString_GroupAndStep() & "'"
   Else
      If mobjMatlab Is Nothing Then
         Set mobjMatlab = New clsMatLab
      End If
      
      strMatlabResponse = mobjMatlab.Execute("cd '" & GetSettingValue("ASL Matlab code folder", ErrorIfNotFound:=True) & "'")
      
      psi.ResultValue = ""
      Dim pso As clsProcessingStepOuptut
      Dim strFilesProcessed As String
      Dim fso As New Scripting.FileSystemObject
      
      For Each pso In psi_ASLCopy.StepOutputs
         Select Case pso.OutputType
            Case "Anatomical"
               'if necessary, unzip the file; and rename to "s_mprage"
               Dim fil As Scripting.File
               fn.Filename = pso.OutputFilename
               fn.FinalSlashOnPath = True
               
               If fso.FileExists(fn.Path & "s_mprage.nii") Then fso.DeleteFile fn.Path & "s_mprage.nii"
               If LCase(fn.Extension) = ".gz" Then
                  strCommandLine = "gunzip('" & pso.OutputFilename & "');"
                  strMatlabResponse = mobjMatlab.Execute(strCommandLine)
                  Set fil = fso.GetFile(fn.Path & fn.Corename)
                  fil.Name = "s_mprage.nii"
               Else
                  fso.CopyFile pso.OutputFilename, fn.Path & "s_mprage.nii"
               End If
               psi.StepOutput_Add pso.OutputType, fn.Path & "s_mprage.nii"
               
            Case "ASL"
               strCommandLine = Replace(Commandline_base, "{filepath}", pso.OutputFilename)
               strMatlabResponse = mobjMatlab.Execute(strCommandLine)
               If modUtility.RegEx_Test(strMatlabResponse, strRegExPattern_Success) Then
                  fn.Filename = pso.OutputFilename
                  fn.FinalSlashOnPath = False
                  psi.StepOutput_Add "M0", fn.Path & "\M0.nii", pso.Iteration
                  psi.StepOutput_Add "PASL", fn.Path & "\PASL.nii", pso.Iteration
                  fn.Filename = modUtility.RegEx_ExtractSubstring(strMatlabResponse, strRegExPattern_Success)
                  strFilesProcessed = strFilesProcessed & IIf(strFilesProcessed = "", "", "|") & fn.FileTitle
               Else
                  psi.ResultValue = "FAILED"
                  psi.ResultComment = strMatlabResponse
                  psi.ProcessingComplete = False
                  psi.ProcessingEndTime = Now
                  Exit For
               End If
         End Select
      Next
      
      If Not (psi.ResultValue = "FAILED") Then
         psi.ResultValue = Left(strFilesProcessed, 255)
         psi.ProcessingComplete = True
         psi.ProcessingEndTime = Now
      End If
   End If

   psi.Save
End Sub

Private Sub Do_CBF_Preparation(oSession As clsSession, psi As clsProcessingStepInfo, strmLogFile As Scripting.TextStream, ShowLogWindows As Boolean)
   
   Const MethodName As String = "Do_CBF_Preparation"
   Debug.Print ModuleName & "." & MethodName & " for SessionID=" & oSession.SessionID
   
   psi.StartProcessing_Now
   
   Dim strLogFilenameMidSection  As String
   Dim strSpecificStepToRun As String

   Select Case psi.ProcessingStepName
      Case "CBF calc preparation"
         strLogFilenameMidSection = "Preparation"
         strSpecificStepToRun = GetSettingValue("CBF calc preparation command", psi.ProcessingStepID, oSession.SessionID, ValueIfNotFound:="Basic")
   
      Case "TPM computation"
         strLogFilenameMidSection = "TPM_Computation"
         strSpecificStepToRun = "TPM_Segment"
         
   End Select
      
   Const Commandline_base As String = "CWRU_ASL_Compute_CBF('{Data_Root}', ['{Study_Folders_ToProcess}'], '{Log_Filename}', [700 1800 53 17 0.90 1], '{SpecificStepToRun}', 0, 0, 0, {ImageOutlierFiler_MADThreshold} )"
   Dim strCommandLine As String
   Dim strMatlabResponse As String
   Dim fn As New clsFilename
   Dim strRegExPattern_Success As String
   Dim strSQL As String
   
   strRegExPattern_Success = "^.*: CWRU_ASL_Compute_CBF, processing complete\.$"
   
   Dim psi_ASLExtraction As New clsProcessingStepInfo
   If Not psi_ASLExtraction.LoadSessionProcessingStep(oSession.SessionID, "ASL quantitation", "Extract M0 and PASL Nii") Then
      Err.Raise vbObjectError + 512, ModuleName & "." & MethodName, "Failed to find a completed processing step '" & psi_ASLExtraction.ToString_GroupAndStep() & "'"
   Else
      If mobjMatlab Is Nothing Then
         Set mobjMatlab = New clsMatLab
      End If
      
      Dim strWorkingDirectory As String
      strWorkingDirectory = GetSettingValue("ASL Matlab code folder", ErrorIfNotFound:=True)
      strMatlabResponse = mobjMatlab.Execute("cd '" & strWorkingDirectory & "'")
      
      psi.ResultValue = ""
      Dim pso As clsProcessingStepOuptut
      Dim strFilesProcessed As String
      Dim strLogFilename As String
      Dim fso As New Scripting.FileSystemObject
      Dim strm As Scripting.TextStream
      
     
      strLogFilename = oSession.SessionPath_ASL & "\ASLAnalysis_" & strLogFilenameMidSection & "_" & Format(Now, "yyyymmdd_HHMMSS") & "_Log.txt"
             
      strCommandLine = Commandline_base
      strCommandLine = Replace(strCommandLine, "{SpecificStepToRun}", strSpecificStepToRun)
      
      strCommandLine = Replace(strCommandLine, "{Data_Root}", oSession.DataRootPath)
      strCommandLine = Replace(strCommandLine, "{Study_Folders_ToProcess}", oSession.RootFolder)
      strCommandLine = Replace(strCommandLine, "{Log_Filename}", strLogFilename)
      strCommandLine = Replace(strCommandLine, "{ImageOutlierFiler_MADThreshold}", GetSettingValue("ImageOutlierFiler_MADThreshold", ProcessingStepID:=psi.ProcessingStepID, SessionID:=oSession.SessionID, ValueIfNotFound:="6"))
       
      Set strm = fso.OpenTextFile(strLogFilename, ForWriting, True)
      strm.WriteLine "Start time: " & FormatDateTime(Now, vbGeneralDate)
      If strWorkingDirectory <> "" Then strm.WriteLine "Set working directory to: " & strWorkingDirectory
      strm.WriteLine "Matlab command line being executed:"
      strm.WriteLine strCommandLine
      strm.WriteLine "------------------"
      strm.Close
      If ShowLogWindows Then modMRI_Common.TailLogFile strLogFilename
      
      strMatlabResponse = mobjMatlab.Execute(strCommandLine)
      
      'assume failure
      psi.ResultValue = "FAILED"
      psi.ResultComment = strMatlabResponse
      psi.ProcessingComplete = False
      psi.ProcessingEndTime = Now
      
      Dim strLogFile As String
      strLogFile = fso.OpenTextFile(strLogFilename, ForReading).ReadAll
      
      If modUtility.RegEx_Test(strLogFile, strRegExPattern_Success) Then
         'I want to be a bit lazy... no real need to extract all this info.
         ' Let's just make sure there is no word "Error" and also contains the "CWRU_ASL_Compute_CBF, processing complete"
         Dim AllIsOK As Boolean
         AllIsOK = (modUtility.RegEx_Test(strLogFile, strRegExPattern_Success)) And (Not modUtility.RegEx_Test(strLogFile, "\berror\b"))
         
         If Not AllIsOK Then
            psi.ResultValue = "FAILED"
            psi.ResultComment = "Please check log file: " & strLogFilename
            psi.Save_NotCompleteNow
         Else 'all is good, so signal success
            psi.ResultValue = "Successfully processed ASL folders"
            psi.ResultComment = ""
            
            'pull out the filenames produced
            Dim strPattern As String, strSection As String
            Select Case psi.ProcessingStepName
               Case "CBF calc preparation"
                  'there should be five sections in this file, corresponding to: Motion Correction, Coregister MO, Coregister to Anatomical, Filtering, Smoothing
   '               Dim section_number As Integer
   '               Dim strSectionStartLine As String
   '               Dim str
   '               For section_number = 1 To 5
   '                  Select Case section_number
   '                     Case 1 'Motion Correction
   '
   '                     Case 2 'Coregister MO to meanPASL
   '                     Case 3 'Coregister all to Anatomical
   '                     Case 4 ' Filtering
   '                     Case 5 'Smoothing
   '
   '               Next
               
                  psi.Save_CompleteNow
   
               Case "TPM computation"
                  strPattern = "^\d+-\w{3}-\d{4}\s\d{2}:\d{2}:\d{2}:\sFor subject .* performing segmentation for structural image:\s(.*)$[\r\n]+^\d+-\w{3}-\d{4}\s\d{2}:\d{2}:\d{2}:\sFor subject .* completed segmentation, produced the class images for tissues (\d+)-(\d+)\s*$"
                  Dim strSourceFilename As String
                  Dim mat_strings() As String
                  mat_strings = modUtility.RegEx_ExtractSubstrings(strLogFile, strPattern)
                  If UBound(mat_strings) = 2 Then
                     psi.StepOutput_Add "Source Image", mat_strings(0)
                     Dim i As Integer
                     'the log file does not actually list the names of the TPM files produced; we just need to assume that the output
                     'TPMs have format like "cNbasename.nii", where the basename is the starting source file
                     Dim fi As clsFilename
                     Dim strTPM_Filename As String
                     Set fi = New clsFilename
                     
                     fi.Filename = mat_strings(0)
                     fi.FinalSlashOnPath = True
                     For i = CInt(mat_strings(1)) To CInt(mat_strings(2))
                        strTPM_Filename = fi.Path & "c" & CStr(i) & fi.FileTitle
                        psi.StepOutput_Add "TPM", strTPM_Filename, i
                     Next
                     psi.Save_CompleteNow
                  Else
                     psi.ResultValue = "FAILED"
                     psi.ResultComment = "Failed to find expected log file information. Please check log file: " & strLogFilename
                     psi.Save_NotCompleteNow
                  End If
   
            End Select
            
            
         End If
      End If

    
   End If
   
   psi.Save
End Sub


Private Sub Do_CBF_Compute(oSession As clsSession, psi As clsProcessingStepInfo, strmLogFile As Scripting.TextStream, ShowLogWindows As Boolean)
   
   Const MethodName As String = "Do_CBF_Compute"
   Debug.Print ModuleName & "." & MethodName & " for SessionID=" & oSession.SessionID
   
   psi.StartProcessing_Now
   
   Dim ProcessingStepID_ForSettings As Long
   Select Case psi.ProcessingStepName
      'if the step is  "CBF computation SIMPLE", then when using the GetSettingValue() function, pass the ProcessingStepID for "CBF computation"
      Case "CBF computation SIMPLE"
         ProcessingStepID_ForSettings = CLng(DLookup("ProcessingStepID", "ProcessingStep", "ProcessingStep=""CBF computation"""))
         
      Case "CBF computation" 'in this case, look at the Settings table to decide
         ProcessingStepID_ForSettings = psi.ProcessingStepID
   End Select
   
   
   Const Commandline_base As String = "CWRU_ASL_Compute_CBF('{Data_Root}', ['{Study_Folders_ToProcess}'], '{Log_Filename}', [{Labeltime_ms} {Delaytime_ms} {Slicetime_ms} {TE_ms} {Labeling_Efficiency} {SubtractionOrder}],'{SpecificStepToRun}', {OutlierMode}, {ASL_Type}, {PrecomputedCBF_Scaling}, 0 )"
   Dim strCommandLine As String
   Dim strMatlabResponse As String
   Dim fn As New clsFilename
   Dim strRegExPattern_Success As String
   Dim strSQL As String
   
   strRegExPattern_Success = "^.*: CWRU_ASL_Compute_CBF, processing complete\.$"
   
   Dim psi_ASLExtraction As New clsProcessingStepInfo
   If Not psi_ASLExtraction.LoadSessionProcessingStep(oSession.SessionID, "ASL quantitation", "Extract M0 and PASL Nii") Then
      Err.Raise vbObjectError + 512, ModuleName & "." & MethodName, "Failed to find a completed processing step '" & psi_ASLExtraction.ToString_GroupAndStep() & "'"
   Else
      Dim intASL_ConditionCount As Integer, lngStudyType_ASL As Long
      lngStudyType_ASL = DLookup("StudyTypeID", "StudyType", "StudyType='ASL'")
      intASL_ConditionCount = DMax("Iteration", "Study", "StudyTypeID=" & lngStudyType_ASL & " AND SessionID=" & oSession.SessionID)
   
      If mobjMatlab Is Nothing Then
         Set mobjMatlab = New clsMatLab
      End If
      
      Dim strWorkingDirectory As String
      strWorkingDirectory = GetSettingValue("ASL Matlab code folder", ErrorIfNotFound:=True)
      strMatlabResponse = mobjMatlab.Execute("cd '" & strWorkingDirectory & "'")
      
      psi.ResultValue = ""
      Dim pso As clsProcessingStepOuptut
      Dim strFilesProcessed As String
      Dim strLogFilename As String
      Dim fso As New Scripting.FileSystemObject
      Dim strm As Scripting.TextStream
      
     
      Dim strProcessingInformationIDs() As String, DeletePreviousResults As Boolean
      Dim strOutlierMode As String
      Dim ProcessingIndex_0 As Integer, ProcessingInformationID As Long
      DeletePreviousResults = CBool(GetSettingValue("Delete Previous Datum Results", ProcessingStepID:=ProcessingStepID_ForSettings, SessionID:=oSession.SessionID, ValueIfNotFound:="true"))
      
      'new feature: if the value of setting "Processing Information ID" is set to "ProcessUsingThis", then selects the records on
      ' ProcessingInformation that have ProcessUsingThis=true; otherwise, the "Processing Information ID" is expected to be a
      ' semicolon-delimited list of ProcessingInformationID values
      If (GetSettingValue("Processing Information ID", ProcessingStepID:=ProcessingStepID_ForSettings, SessionID:=oSession.SessionID, ValueIfNotFound:="ProcessUsingThis") = "ProcessUsingThis") Then
         strSQL = "SELECT ProcessingInformationID FROM ProcessingInformation WHERE ProcessUsingThis=true ORDER BY ProcessingInformationID"
         Dim rsPI As DAO.Recordset
         Set rsPI = CurrentDb.OpenRecordset(strSQL)
         If rsPI.EOF Then
            Err.Raise vbObjectError + 512, ModuleName & "." & MethodName, "You must select the methods to use for processing by setting the 'ProcessUsingThis' option on one or more rows on the ProcessingInformation table."
         Else
            rsPI.MoveLast
            rsPI.MoveFirst
            ReDim strProcessingInformationIDs(rsPI.RecordCount - 1)
            Dim pi_index As Integer
            Do
               strProcessingInformationIDs(pi_index) = rsPI![ProcessingInformationID]
               pi_index = pi_index + 1
               rsPI.MoveNext
            Loop Until rsPI.EOF
         End If
         rsPI.Close
      Else
         strProcessingInformationIDs = Split(GetSettingValue("Processing Information ID", ProcessingStepID:=ProcessingStepID_ForSettings, SessionID:=oSession.SessionID, ValueIfNotFound:="1"), ";")
      End If
      
      For ProcessingIndex_0 = 0 To UBound(strProcessingInformationIDs)
      
         If IsNumeric(strProcessingInformationIDs(ProcessingIndex_0)) Then
            ProcessingInformationID = CLng(strProcessingInformationIDs(ProcessingIndex_0))
            strOutlierMode = DLookup("ProcessingKey", "ProcessingInformation", "ProcessingInformationID=" & ProcessingInformationID)
         Else
            ProcessingInformationID = -1
            strOutlierMode = "1"
         End If
        
         strLogFilename = oSession.SessionPath_ASL & "\ASLAnalysis_OutlierMode_" & strOutlierMode & "_" & Format(Now, "yyyymmdd_HHMMSS") & "_Log.txt"
                
         strCommandLine = Commandline_base
   
         Dim SpecificStepToRun_Setting As String
         SpecificStepToRun_Setting = GetSettingValue("Specific Step To Run", ProcessingStepID:=ProcessingStepID_ForSettings, SessionID:=oSession.SessionID, ValueIfNotFound:="All")
         If SpecificStepToRun_Setting = "" Then SpecificStepToRun_Setting = "All"
         Dim DoSegmentedCBFCompute As Boolean
         DoSegmentedCBFCompute = CBool(GetSettingValue("Do Segmented CBF computation", ProcessingStepID:=ProcessingStepID_ForSettings, SessionID:=oSession.SessionID, ValueIfNotFound:="false"))
                        
         Select Case psi.ProcessingStepName
            
            Case "CBF computation SIMPLE"
            'if the step is  "CBF computation SIMPLE", then always use the "perf_subtract_simple" mode
               If (SpecificStepToRun_Setting = "All") Then
                  SpecificStepToRun_Setting = "perf_subtract_simple"
               End If
            
            Case "CBF computation" 'in this case, look at the Settings table to decide
               If (SpecificStepToRun_Setting = "All") Then
                  If DoSegmentedCBFCompute Then
                     SpecificStepToRun_Setting = "perf_subtract_segmented"
                  Else
                     SpecificStepToRun_Setting = "perf_subtract_simple"
                  End If
               End If
         End Select
         
         strCommandLine = Replace(strCommandLine, "{SpecificStepToRun}", SpecificStepToRun_Setting)
         
         strCommandLine = Replace(strCommandLine, "{Data_Root}", oSession.DataRootPath)
         strCommandLine = Replace(strCommandLine, "{Study_Folders_ToProcess}", oSession.RootFolder)
         strCommandLine = Replace(strCommandLine, "{Log_Filename}", strLogFilename)
       
         strCommandLine = Replace(strCommandLine, "{Labeltime_ms}", GetSettingValue("Labeltime_ms", ProcessingStepID:=ProcessingStepID_ForSettings, SessionID:=oSession.SessionID, ErrorIfNotFound:=True))
         strCommandLine = Replace(strCommandLine, "{Delaytime_ms}", GetSettingValue("Delaytime_ms", ProcessingStepID:=ProcessingStepID_ForSettings, SessionID:=oSession.SessionID, ErrorIfNotFound:=True))
         strCommandLine = Replace(strCommandLine, "{Slicetime_ms}", GetSettingValue("Slicetime_ms", ProcessingStepID:=ProcessingStepID_ForSettings, SessionID:=oSession.SessionID, ErrorIfNotFound:=True))
         strCommandLine = Replace(strCommandLine, "{TE_ms}", GetSettingValue("TE_ms", ProcessingStepID:=ProcessingStepID_ForSettings, SessionID:=oSession.SessionID, ErrorIfNotFound:=True))
         strCommandLine = Replace(strCommandLine, "{Labeling_Efficiency}", GetSettingValue("Labeling_Efficiency", ProcessingStepID:=ProcessingStepID_ForSettings, SessionID:=oSession.SessionID, ErrorIfNotFound:=True))
         strCommandLine = Replace(strCommandLine, "{SubtractionOrder}", GetSettingValue("SubtractionOrder", ProcessingStepID:=ProcessingStepID_ForSettings, SessionID:=oSession.SessionID, ErrorIfNotFound:=True))
         strCommandLine = Replace(strCommandLine, "{OutlierMode}", strOutlierMode)
         strCommandLine = Replace(strCommandLine, "{ASL_Type}", GetSettingValue("ASL Type", ProcessingStepID:=ProcessingStepID_ForSettings, SessionID:=oSession.SessionID, ValueIfNotFound:="0"))
         strCommandLine = Replace(strCommandLine, "{PrecomputedCBF_Scaling}", GetSettingValue("PrecomputedCBF_Scaling", ProcessingStepID:=ProcessingStepID_ForSettings, SessionID:=oSession.SessionID, ValueIfNotFound:="1"))
          
         Set strm = fso.OpenTextFile(strLogFilename, ForWriting, True)
         strm.WriteLine "Start time: " & FormatDateTime(Now, vbGeneralDate)
         If strWorkingDirectory <> "" Then strm.WriteLine "Set working directory to: " & strWorkingDirectory
         strm.WriteLine "Matlab command line being executed:"
         strm.WriteLine strCommandLine
         strm.WriteLine "------------------"
         strm.Close
         If ShowLogWindows Then modMRI_Common.TailLogFile strLogFilename
         
         strMatlabResponse = mobjMatlab.Execute(strCommandLine)
       '  Debug.Print strMatlabResponse
         
         'assume failure
         psi.ResultValue = "FAILED"
         psi.ResultComment = strMatlabResponse
         psi.ProcessingComplete = False
         psi.ProcessingEndTime = Now
         
         Dim strLogFile As String
         strLogFile = fso.OpenTextFile(strLogFilename, ForReading).ReadAll
         
         
         If modUtility.RegEx_Test(strLogFile, strRegExPattern_Success) Or _
            CBool(GetSettingValue("ProcessResults_EvenIfError", SessionID:=oSession.SessionID, ValueIfNotFound:="false")) Then
            'pull out the filenames produced
            
            'The primary thing we care about is the meanCBF_0_sASLflt_rPASL.nii files for each condition.  Find those first
            Dim strPattern As String, strSection As String
            strPattern = "^(\d+-\w{3}-\d{4}\s\d{2}:\d{2}:\d{2}:\sCalculate perfusion and CBF signals(?:, using TPMs, OutlierMode=\d+)?$\r?\n(^.*\r?\n)+)^\r?\n"
            'This pattern looks for the section that begins with a timestamp and "Calculate perfusion and CBF signals".  It selects all the lines
            ' until there is a line with nothing (basically, two end-of-line in a row)
            strSection = modUtility.RegEx_ExtractSubstring(strLogFile, strPattern, False, True, True)
            
            If strSection <> "" Then
                       
               strPattern = "^-- processing subject\/condition: #1\/(\d+)  \('[^']+'\/'(.+)'\)\r?\n(^.*\r?\n){17,34}.*Created summary data file:.*?\r?\n"
               'find the sections for each condition
               Dim mats As VBScript_RegExp_55.MatchCollection, mat As VBScript_RegExp_55.Match
               Set mats = modUtility.RegEx_ExtractMatches(strSection, strPattern, False, True, True)
               For Each mat In mats
                  Dim strConditionSection As String, strConditionName As String, intConditionIndex As Integer
                  strConditionSection = mat.value
                  strConditionName = mat.SubMatches(1)
                  intConditionIndex = CInt(mat.SubMatches(0))
                  psi.StepOutput_Add "perfusion map", modUtility.RegEx_ExtractSubstring(strConditionSection, "^\s+Created mean perfusion image file: (.*)$"), intConditionIndex
                  psi.StepOutput_Add "CBF map", modUtility.RegEx_ExtractSubstring(strConditionSection, "^\s+Created mean CBF image file: (.*)$"), intConditionIndex
                  psi.StepOutput_Add "perfusion cbf summary", modUtility.RegEx_ExtractSubstring(strConditionSection, "^\s+Created summary data file: (.*)$"), intConditionIndex
                              
                  'Extract the CBF data values from the text
                  Dim StudyID_This As Long
                  StudyID_This = oSession.StudyID_GetSpecific("ASL", intConditionIndex)
                  
                  If DeletePreviousResults Then
                     'First delete any values already present for this study

                     
                     strSQL = "DELETE Datum.* " & _
                              "FROM DataGroup INNER JOIN (DataType INNER JOIN Datum ON DataType.DataTypeID = Datum.DataTypeID) ON DataGroup.DataGroupID = DataType.DataGroupID " & _
                              "WHERE (((DataGroup.DataGroup)='ASL CBF') AND (Datum.StudyID)={StudyID})"
                     If ProcessingInformationID > 0 Then
                        strSQL = strSQL & " AND ProcessingInformationID=" & ProcessingInformationID
                     Else
                        strSQL = strSQL & " AND ProcessingInformationID IS NULL"
                     End If
                     strSQL = Replace(strSQL, "{StudyID}", CStr(StudyID_This))
                     CurrentDb.Execute strSQL
                  End If
                  
                  Dim strCBF_Vals() As String
                  Dim BrainRegionID As Long, BrainRegionTag As String
                  Const strPattern_CBFData As String = "For all data within mask,   mean CBF=([-\d\.]+|NaN); stdev=([\d\.]+|NaN);.*\n.*Using outlier-cleaned data, mean CBF=([-\d\.]+|NaN); stdev=([\d\.]+|NaN);"
                  strCBF_Vals = modUtility.RegEx_ExtractSubstrings(strConditionSection, strPattern_CBFData)
                  Dim DataTypeID_CBF_Mean_All As Long, DataTypeID_CBF_Mean_Cleaned As Long
                  DataTypeID_CBF_Mean_All = DLookup("DataTypeID", "lookup_DataType", "DataGroup='ASL CBF' AND DataTypeName='CBF_Mean (all)'")
                  DataTypeID_CBF_Mean_Cleaned = DLookup("DataTypeID", "lookup_DataType", "DataGroup='ASL CBF' AND DataTypeName='CBF_Mean (outlier cleaned)'")
                  Dim rs As DAO.Recordset, i As Integer
                  Set rs = CurrentDb.OpenRecordset("Datum", dbOpenDynaset, dbAppendOnly, dbOptimistic)
                  BrainRegionTag = "BRAIN"
                  BrainRegionID = Nz(DLookup("BrainRegionID", "BrainRegion", "Tag='" & BrainRegionTag & "'"), -1)
                  
                  For i = 1 To 2
                     With rs
                        .AddNew
                        ![StudyID] = StudyID_This
                        ![DataTypeID] = Choose(i, DataTypeID_CBF_Mean_All, DataTypeID_CBF_Mean_Cleaned)
                        If IsNumeric(strCBF_Vals((i - 1) * 2)) Then
                           ![Value_Numeric] = CDbl(strCBF_Vals((i - 1) * 2))
                        Else
                           ![Value_Text] = CStr(strCBF_Vals((i - 1) * 2))
                        End If
                        If IsNumeric(strCBF_Vals((i - 1) * 2 + 1)) Then ![Value_StDev] = CDbl(strCBF_Vals((i - 1) * 2 + 1))
                        ![BrainRegionID] = BrainRegionID
                        If (ProcessingInformationID > 0) Then ![ProcessingInformationID] = ProcessingInformationID
                        .Update
                     End With
                  Next
               
               
                  'look for tissue segmented results
                  Const strPattern_CBF_TissueSegmented As String = "^\s*Tissue segmented data, using mean CBF image \(.+? data\); Tissue name: ([^;]+); mean CBF=([-\d\.]+|NaN); stdev=([-\d\.]+|NaN); count voxels=([-\d\.]+)$"
                  Dim DataTypeID_CBF_Mean_Segmented As Long, DataTypeID_CBF_Segmented_CountVoxels As Long
                  'DataTypeName: CBF_Mean Segmented, CBF Segmented CountVoxels
                  DataTypeID_CBF_Mean_Segmented = DLookup("DataTypeID", "lookup_DataType", "DataGroup='ASL CBF' AND DataTypeName='CBF_Mean Segmented'")
                  DataTypeID_CBF_Segmented_CountVoxels = DLookup("DataTypeID", "lookup_DataType", "DataGroup='ASL CBF' AND DataTypeName='CBF Segmented CountVoxels'")
                  Dim mats_TPM As VBScript_RegExp_55.MatchCollection, mat_TPM As VBScript_RegExp_55.Match
                  Set mats_TPM = modUtility.RegEx_ExtractMatches(strConditionSection, strPattern_CBF_TissueSegmented, False, True, True)
                  
                  For Each mat_TPM In mats_TPM
                     Select Case mat_TPM.SubMatches(0)
                        Case "GM", "WM", "CSF"
                           BrainRegionTag = mat_TPM.SubMatches(0)
                        Case "Bone"
                           BrainRegionTag = "SKULL"
                        Case "Soft"
                           BrainRegionTag = "Soft"
                        Case "Air"
                           BrainRegionTag = "SPACE"
                        Case Else
                           Err.Raise vbObjectError, ModuleName & "." & MethodName, "Unrecognized tissue name: " & mat_TPM.SubMatches(0)
                     End Select
                     
                     BrainRegionID = Nz(DLookup("BrainRegionID", "BrainRegion", "Tag='" & BrainRegionTag & "'"), -1)
                     If BrainRegionID < 0 Then Err.Raise vbObjectError, ModuleName & "." & MethodName, "Unrecognized BrainRegionTag: " & BrainRegionTag
                     
                     Set rs = CurrentDb.OpenRecordset("Datum", dbOpenDynaset, dbAppendOnly, dbOptimistic)
                     For i = 1 To 2
                        With rs
                           .AddNew
                           ![StudyID] = StudyID_This
                           Select Case i
                              Case 1
                                 ![DataTypeID] = DataTypeID_CBF_Mean_Segmented
                                 If IsNumeric(mat_TPM.SubMatches(1)) Then
                                    ![Value_Numeric] = CDbl(mat_TPM.SubMatches(1))
                                 Else
                                    ![Value_Text] = CStr(mat_TPM.SubMatches(1))
                                 End If
                                 If IsNumeric(mat_TPM.SubMatches(2)) Then ![Value_StDev] = CDbl(mat_TPM.SubMatches(2))
                              Case 2
                                 ![DataTypeID] = DataTypeID_CBF_Segmented_CountVoxels
                                 ![Value_Numeric] = CDbl(mat_TPM.SubMatches(3))
                           End Select
                           ![BrainRegionID] = BrainRegionID
                           If (ProcessingInformationID > 0) Then ![ProcessingInformationID] = ProcessingInformationID
                           .Update
                        End With
                     Next
                     
                  Next
                  
                  rs.Close
               Next
               
               If intConditionIndex <> intASL_ConditionCount Then
                  psi.ResultComment = "Found " & intConditionIndex & " successfully processed ASL folders; expected to find " & intASL_ConditionCount
               Else 'all is good, so signal success
                  psi.ResultValue = "Successfully processed " & intConditionIndex & " ASL folders"
                  psi.ResultComment = ""
                  psi.ProcessingComplete = True
                  psi.ProcessingEndTime = Now
               End If
            End If
         End If
        
      Next
     
   End If
   
   psi.Save
End Sub

Private Sub Do_ASL_ROI_Summarization(oSession As clsSession, psi As clsProcessingStepInfo, strmLogFile As Scripting.TextStream, ShowLogWindows As Boolean)

   Const MethodName As String = "Do_ASL_ROI_Summarization"
   Const Commandline_base As String = "CWRU_ASL_SummarizeAll('{Data_Root}', ['{Study_Folders_ToProcess}'], '{LabelDescriptionMatLabFile}' ,'{Log_Filename}')"
   Debug.Print ModuleName & "." & MethodName & " for SessionID=" & oSession.SessionID

   psi.StartProcessing_Now
   
   Dim psiASL_Basic As New clsProcessingStepInfo
   With psiASL_Basic
      If Not .LoadSessionProcessingStep(oSession.SessionID, psi.ProcessingStepGroupName, "CBF computation") Then
         Err.Raise vbObjectError + 512, ModuleName & "." & MethodName, "Failed to find a completed processing step: " & .ToString_GroupAndStep()
      End If
   End With
      
   Dim psiSVReg As New clsProcessingStepInfo
   With psiSVReg
      If Not .LoadSessionProcessingStep(oSession.SessionID, "Cortical surface extraction", "Register and label brain") Then
         Err.Raise vbObjectError + 512, ModuleName & "." & MethodName, "Failed to find a completed processing step: " & .ToString_GroupAndStep()
      End If
   End With

   Dim pso As clsProcessingStepOuptut
   Set pso = psiSVReg.StepOutout_GetSpecific("label")
   If pso Is Nothing Then
      Err.Raise vbObjectError + 512, ModuleName & "." & MethodName, "Failed to find a processing output type 'label' for processing step info: " & psiSVReg.ToString_GroupAndStep()
   Else
      
      Dim intASL_ConditionCount As Integer, lngStudyType_ASL As Long
      lngStudyType_ASL = DLookup("StudyTypeID", "StudyType", "StudyType='ASL'")
      intASL_ConditionCount = DMax("Iteration", "Study", "StudyTypeID=" & lngStudyType_ASL & " AND SessionID=" & oSession.SessionID)
   
      If mobjMatlab Is Nothing Then
         Set mobjMatlab = New clsMatLab
      End If
      
      Dim strWorkingDirectory As String, strMatlabResponse As String, strCommandLine As String
      strWorkingDirectory = GetSettingValue("ASL Matlab code folder", ErrorIfNotFound:=True)
      strMatlabResponse = mobjMatlab.Execute("cd '" & strWorkingDirectory & "'")
      
      psi.ResultValue = ""
      Dim strFilesProcessed As String
      Dim strLogFilename As String
      strLogFilename = oSession.SessionPath_ASL & "\ASL_ROI_Summarization_Log.txt"
      
      strCommandLine = Commandline_base
      strCommandLine = Replace(strCommandLine, "{Data_Root}", oSession.DataRootPath)
      strCommandLine = Replace(strCommandLine, "{Study_Folders_ToProcess}", oSession.RootFolder)
      strCommandLine = Replace(strCommandLine, "{LabelDescriptionMatLabFile}", GetSettingValue("Label Description MatLab File", SessionID:=oSession.SessionID))
      strCommandLine = Replace(strCommandLine, "{Log_Filename}", strLogFilename)
      
      Dim fso As New Scripting.FileSystemObject
      Dim strm As Scripting.TextStream
      Set strm = fso.OpenTextFile(strLogFilename, ForWriting, True)
      strm.WriteLine "Start time: " & FormatDateTime(Now, vbGeneralDate)
      If strWorkingDirectory <> "" Then strm.WriteLine "Set working directory to: " & strWorkingDirectory
      strm.WriteLine "Matlab command line being executed:"
      strm.WriteLine strCommandLine
      strm.WriteLine "------------------"
      strm.Close
      
      If ShowLogWindows Then modMRI_Common.TailLogFile strLogFilename
      
      strMatlabResponse = mobjMatlab.Execute(strCommandLine)
      Debug.Print strMatlabResponse
      
      'assume failure
      psi.ResultValue = "FAILED"
      psi.ResultComment = strMatlabResponse
      psi.ProcessingComplete = False
      psi.ProcessingEndTime = Now
      
      Dim strLogFile As String
      strLogFile = fso.OpenTextFile(strLogFilename, ForReading).ReadAll
      
      Const strRegExPattern_Success As String = "^\d+-\w{3}-\d{4}\s\d{2}:\d{2}:\d{2}:\sCWRU_ASL_SummarizeAll, processing complete."
      Const strSummaryTextFiles_RegEx As String = "^For subject\/condition: #(\d+)\/(\d+), wrote summarization data to filename '([^']+\\(\w+_ROI_Summary)\.txt)'"
      'Given text file lines like this:
      'For subject/condition: #1/1, wrote summarization data to filename 'C:\Users\Tod\Documents\BioAutomatix\Clients\Decker\MRI Processing\Example data\Chronic Fatigue\WM\WM_post\ASL\asl_1\meanCBF_ROI_Summary.txt'
      'For subject/condition: #1/1, wrote summarization data to filename 'C:\Users\Tod\Documents\BioAutomatix\Clients\Decker\MRI Processing\Example data\Chronic Fatigue\WM\WM_post\ASL\asl_1\meanPERF_ROI_Summary.txt'
      'The regex sub-matches(0) is subject index; sub-matches(1) is condition index;
      '  sub-matches(2) is complete path; sub-matches(3) is something like 'meanCBF_ROI_Summary'
      'Multiple files come in groups of 4 submatches
      
      If modUtility.RegEx_Test(strLogFile, strRegExPattern_Success) Then
         'pull out the filenames produced
         Dim conditionindex As Integer, conditionindex_max As Integer
         conditionindex_max = -1
         Dim filenameparts() As String
         filenameparts = modUtility.RegEx_ExtractSubstrings(strLogFile, strSummaryTextFiles_RegEx, , True, True)
         
         Dim filecountproduced As Integer, fileindex As Integer
         filecountproduced = Int((UBound(filenameparts) + 1) / 4)
         For fileindex = 0 To filecountproduced - 1
            conditionindex = CInt(filenameparts(fileindex * 4 + 1))
            psi.StepOutput_Add filenameparts(fileindex * 4 + 3), filenameparts(fileindex * 4 + 2), conditionindex
            
            If conditionindex > conditionindex_max Then conditionindex_max = conditionindex
         Next

         If conditionindex_max <> intASL_ConditionCount Then
            psi.ResultComment = "Found " & conditionindex_max & " successfully processed ASL folders; expected to find " & intASL_ConditionCount
         Else 'all is good, so signal success
            psi.ResultValue = "Successfully processed " & conditionindex_max & " ASL folders"
            psi.ResultComment = ""
            psi.ProcessingComplete = True
            psi.ProcessingEndTime = Now
         End If
         
     End If
   End If
   
   psi.Save
End Sub

Private Function Do_ExtractASL_ROI_Data(oSession As clsSession, psi As clsProcessingStepInfo, strmLogFile As Scripting.TextStream, ShowLogWindows As Boolean)
   'This extracts the info from the mean????_ROI_Summary.txt file
   Const MethodName As String = "Do_ExtractASL_ROI_Data"
   Debug.Print ModuleName & "." & MethodName & " for SessionID=" & oSession.SessionID
   
   psi.StartProcessing_Now
   
   Dim intASL_ConditionCount As Integer, lngStudyType_ASL As Long
   lngStudyType_ASL = DLookup("StudyTypeID", "StudyType", "StudyType='ASL'")
   intASL_ConditionCount = DMax("Iteration", "Study", "StudyTypeID=" & lngStudyType_ASL & " AND SessionID=" & oSession.SessionID)
   
   Dim psiASL_ROI As New clsProcessingStepInfo
   With psiASL_ROI
      If Not .LoadSessionProcessingStep(oSession.SessionID, psi.ProcessingStepGroupName, "ASL ROI Summarization") Then
         Err.Raise vbObjectError + 512, ModuleName & "." & MethodName, "Failed to find a completed processing step: " & .ToString_GroupAndStep()
      End If
   End With
   
   
   Dim pso As clsProcessingStepOuptut
   Dim strROI_StatFilename As String
   Dim condition_index As Integer
   For condition_index = 1 To intASL_ConditionCount
      Set pso = psiASL_ROI.StepOutout_GetSpecific("meanCBF_ROI_Summary", condition_index)
      If pso Is Nothing Then
         Err.Raise vbObjectError + 512, ModuleName & "." & MethodName, "Failed to find a processing output type 'meanCBF_ROI_Summary' for processing step info: " & psiASL_ROI.ToString_GroupAndStep() & ", with Iteration=" & condition_index
      Else
         strROI_StatFilename = pso.OutputFilename
         
         Dim fso As New Scripting.FileSystemObject
         If Not fso.FileExists(strROI_StatFilename) Then
            psi.ResultValue = "FAILED"
            psi.ResultComment = "Failed to find expected stats file: " & strROI_StatFilename
            psi.Save_NotCompleteNow
         Else
         
            Dim lngDataGroupID_This As Long
            Dim strDataGroupName As String
            strDataGroupName = "ASL ROI Quantitation"
            lngDataGroupID_This = Nz(DLookup("DataGroupID", "DataGroup", "DataGroup='" & strDataGroupName & "'"), -1)
            If lngDataGroupID_This < 0 Then
               Err.Raise vbObjectError + 512, ModuleName & "." & MethodName, "Failed to find row on table DataGroup with DataGroup='" & strDataGroupName & "'"
            End If
         
            'check if there is already data of this type on the table
            Dim lngStudyID As Long
            Dim OK_ToProceed As Boolean
            OK_ToProceed = True
            
            lngStudyID = oSession.StudyID_GetSpecific("ASL", condition_index)
            Dim strSQL As String
   
            Dim rsExistingDataCount As ADODB.Recordset
            strSQL = "SELECT Count(Datum.DatumID) AS CountOfDatumID " & _
                     "FROM Study INNER JOIN (DataType INNER JOIN Datum ON DataType.DataTypeID = Datum.DataTypeID) ON Study.StudyID = Datum.StudyID " & _
                     "WHERE (((Study.StudyID)=" & lngStudyID & ") AND ((DataType.DataGroupID)=" & lngDataGroupID_This & "))"
            Set rsExistingDataCount = CurrentProject.Connection.Execute(strSQL)
            If rsExistingDataCount![CountOfDatumID] > 0 Then
               Dim strMessage As String
               strMessage = "There are already " & rsExistingDataCount![CountOfDatumID] & " existing records on the Datum table for this Study in the DataGroup='" & strDataGroupName & "'. " & vbCrLf & _
                  "Would you like to delete those existing records before importing this new data file '" & strROI_StatFilename & "'?" & vbCrLf & vbCrLf & _
                  "Answer 'Yes' to delete the existing records." & vbCrLf & _
                  "Answer 'No' to keep the existing records, and read in the data file as new records." & vbCrLf & _
                  "Answer 'Cancel' to cancel the current import of the new data file."
                  
               Dim response As VbMsgBoxResult
               'Decided to not ask this any more. TF 07 June 2018
             '  response = MsgBox(strMessage, vbYesNoCancel + vbQuestion, "Delete existing data of same type?")
               response = vbYes
               If response = vbYes Then
                  strSQL = "DELETE * FROM Datum " & _
                        "WHERE (((Datum.StudyID)=" & lngStudyID & ") AND ((Datum.DataTypeID) In (SELECT DataTypeID from DataType where DataGroupID=" & lngDataGroupID_This & ")))"
                  Dim lngRecordsDeleted As Long
                  CurrentProject.Connection.Execute strSQL, lngRecordsDeleted
             '     MsgBox "Deleted " & lngRecordsDeleted & " records from Datum table", vbOKOnly + vbInformation, "Records Deleted"
               ElseIf response = vbCancel Then
                  psi.ResultValue = "CANCELED"
                  psi.ResultComment = "User canceled import of stats file: " & strROI_StatFilename
                  psi.Save_NotCompleteNow
                  OK_ToProceed = False
               End If
            End If
            rsExistingDataCount.Close
             
            If OK_ToProceed Then
               Dim ColumnCount As Integer, i As Integer
               Dim column_data() As String
               Dim strm As Scripting.TextStream
               Set strm = fso.GetFile(strROI_StatFilename).OpenAsTextStream(ForReading)
               Dim strStatsLine As String
               Dim RowNumber_Processing As Long
               
               strStatsLine = strm.ReadLine
               RowNumber_Processing = RowNumber_Processing + 1
               column_data = Split(strStatsLine, vbTab)
               ColumnCount = UBound(column_data) + 1
               Dim column_DataTypeID() As Long, columnindex_StDev_ForThisColumn() As Integer
               ReDim column_DataTypeID(ColumnCount)
               ReDim columnindex_StDev_ForThisColumn(ColumnCount)
               
               'we expect the first column will be ROI_ID ... if not, do not proceed
               If column_data(0) <> "ROI_ID" Then
                  Err.Raise vbObjectError + 512, ModuleName & "." & MethodName, "On RowNumber=" & RowNumber_Processing & ", expected first column of ROI stat file to be 'ROI_ID', instead found '" & column_data(0) & "', in file: " & strROI_StatFilename
               End If
                           
               'get the DataTypeID for each column
               For i = 1 To ColumnCount - 1  'note, skip column 0 -- that is the ROI_ID
                  columnindex_StDev_ForThisColumn(i) = -1
                  Dim strDataTypeName As String
                  Dim posLastParen As Integer
                  Dim lngDataTypeID As Long
                  strDataTypeName = column_data(i)
                  
                  lngDataTypeID = Nz(DLookup("DataTypeID", "DataType", "DataGroupID=" & lngDataGroupID_This & " AND Import_ColumnName='" & strDataTypeName & "'"), -1)
                  If lngDataTypeID < 0 Then
                     ' Err.Raise vbObjectError + 512, ModuleName & "." & MethodName, "On RowNumber=" & RowNumber_Processing & ", the column name '" & column_data(i) & "' is not recognized as a valid DataTypeName; in file: " & strROI_StatFilename
                     column_DataTypeID(i) = -1  'ignore the column
                  Else
                     column_DataTypeID(i) = lngDataTypeID
                     Dim strColumnName_StDev_ForThis As String
                     strColumnName_StDev_ForThis = Nz(DLookup("Import_StDev_ColumnName", "DataType", "DataTypeID=" & lngDataTypeID & " AND Includes_StDev=True"), "")
                     If strColumnName_StDev_ForThis <> "" Then
                        Dim j As Integer
                        For j = 1 To ColumnCount - 1
                           If column_data(j) = strColumnName_StDev_ForThis Then
                              columnindex_StDev_ForThisColumn(i) = j
                              Exit For
                           End If
                        Next
                     End If
                  End If

               Next
                        
               Dim ROI_ID As Long, lngBrainRegionID As Long
               Dim rsData As DAO.Recordset   'use DAO recordset... faster than ADODB
               Set rsData = CurrentDb.OpenRecordset("Datum", dbOpenDynaset, dbAppendOnly)
   
               'now read through file, add all data to the table
               Do Until strm.AtEndOfStream
                  strStatsLine = strm.ReadLine
                  RowNumber_Processing = RowNumber_Processing + 1
                  column_data = Split(strStatsLine, vbTab)
                  ROI_ID = CLng(column_data(0))
                  lngBrainRegionID = Nz(DLookup("BrainRegionID", "BrainRegion", "ROI_ID=" & ROI_ID), -1)
                  If lngBrainRegionID < 0 Then
                     Err.Raise vbObjectError + 512, ModuleName & "." & MethodName, "On RowNumber=" & RowNumber_Processing & ", failed to find ROI_ID=" & ROI_ID & " on table 'BrainRegion'; in file: " & strROI_StatFilename
                  End If
                  
      
                  For i = 1 To ColumnCount - 1  'note, skip column 0 -- that is the ROI_ID
                     If column_DataTypeID(i) > 0 Then
                        rsData.AddNew
                        With rsData
                           ![StudyID] = lngStudyID
                           ![DataTypeID] = column_DataTypeID(i)
                           'Here I am assuming all the data is numeric... for this file it is fine.  Would be more correct to check the ValueType on the DataType table
                           On Error Resume Next
                           ![Value_Numeric] = CDbl(column_data(i))
                           If Err.Number <> 0 Then
                              ![Value_Text] = column_data(i)
                           End If
                           
                           If columnindex_StDev_ForThisColumn(i) >= 0 Then
                              ![Value_StDev] = CDbl(column_data(columnindex_StDev_ForThisColumn(i)))
                           End If
                           On Error GoTo 0
                           ![BrainRegionID] = lngBrainRegionID
                        End With
                        rsData.Update
                     End If
                  Next
               Loop
               strm.Close
               rsData.Close
               psi.ResultValue = "Imported stat file"
               psi.ResultComment = "Processed " & RowNumber_Processing & " rows from file: " & strROI_StatFilename
               psi.StepOutput_Add "stats", strROI_StatFilename, condition_index

               
            End If
         End If
      End If
   Next
   psi.Save_CompleteNow
   
End Function
----------- end of component
Component: clsProcessingStepOuptut; Class module
Option Compare Database
Option Explicit

Public OutputFilename As String
Public OutputType As String
Public Iteration As Integer

Public OutputInformation As String
Public Comment As String
----------- end of component
Component: clsMatLab; Class module
Option Compare Database
Option Explicit

#If MatLab_Installed = 1 Then
Private m_objMatLab As MLApp.MLApp
#Else
Private m_objMatLab As Object
#End If

Public Function Execute(CommandLine As String) As String
   If Not IsAlive Then
      'try to reinitialize
      Set m_objMatLab = Nothing
#If MatLab_Installed = 1 Then
      Set m_objMatLab = New MLApp.MLApp
#End If
      If Not IsAlive Then
         Err.Raise vbObjectError + 512, "clsMatLab.Execute", "MatLab interface is not responding.  The object must be re-initialized"
      End If
   End If
   Execute = m_objMatLab.Execute(CommandLine)
End Function

Private Function IsAlive()

   Dim matlab_ok As Boolean
   Dim strMatlabResponse As String
   
   If Not (m_objMatLab Is Nothing) Then
      On Error Resume Next
      strMatlabResponse = ""
      m_objMatLab.Execute ("wd=sprintf('%s\n', cd)") 'try a simple command to get the current directory, just to confirm that MatLab is alive
      strMatlabResponse = m_objMatLab.GetVariable("wd", "base")
      matlab_ok = (strMatlabResponse <> "")
      On Error GoTo 0
   End If

   IsAlive = matlab_ok
End Function

Public Property Get Visible() As Boolean
   Visible = m_objMatLab.Visible
End Property
Public Property Let Visible(value As Boolean)
   m_objMatLab.Visible = value
End Property

Private Sub Class_Initialize()
   Debug.Print "Initializing MatLab Automation Server object"
   
#If MatLab_Installed = 1 Then
   Set m_objMatLab = New MLApp.MLApp  'if this fails, try executing this line in a Matlab session:
         '                                      !matlab /regserver
         'see also: https://www.mathworks.com/matlabcentral/answers/98054-why-is-my-asp-application-unable-to-start-matlab-7-6-r2008a-as-a-com-automation-server
 '  m_objMatLab.Visible = False
#End If

End Sub

Private Sub Class_Terminate()
   On Error Resume Next
   If Not m_objMatLab Is Nothing Then
      m_objMatLab.Quit
   End If
   Set m_objMatLab = Nothing
End Sub
----------- end of component
Component: modProcessingControl; Standard module
Option Compare Database
Option Explicit

Public Sub ProcessGroup(Optional ForceProcessing_StepName As String = "")
   
   Dim SessionID As Long
   Dim rs As New ADODB.Recordset
   rs.Open "SELECT * FROM [Session] WHERE ProcessThisSession=True ORDER BY SessionID", CurrentProject.Connection, adOpenStatic, adLockReadOnly
   
   Do Until rs.EOF
     modBasicProcessing.Do_InitialRawProcessing rs![SessionID]
      modASL_Processing.DoASL_Processing rs![SessionID], , ForceProcessing_StepName
'     modCorticalSurfaceExtraction.DoCorticalSurfaceExtraction rs![SessionID]
'      modASL_Processing.DoASL_Processing rs![SessionID]
      rs.MoveNext
   Loop
   
   rs.Close

End Sub

Public Sub ProcessGroup_ASL_ComputeCBF()
   Dim SessionID As Long
   Dim rs As New ADODB.Recordset
   rs.Open "SELECT * FROM [Session] WHERE ProcessThisSession=True ORDER BY SessionID", CurrentProject.Connection, adOpenStatic, adLockReadOnly
   
   Dim ForceProcessing_StepName As String
   ForceProcessing_StepName = "CBF computation"
   
   Do Until rs.EOF
'     modBasicProcessing.Do_InitialRawProcessing rs![SessionID]
      modASL_Processing.DoASL_Processing rs![SessionID], , ForceProcessing_StepName
'      modCorticalSurfaceExtraction.DoCorticalSurfaceExtraction rs![SessionID]
'      modASL_Processing.DoASL_Processing rs![SessionID]
      rs.MoveNext
   Loop
   
   rs.Close
End Sub
----------- end of component
Component: Form_Project; Document Module
Option Compare Database
Option Explicit


Private blnHasBeenInited As Boolean

Private Sub Form_Current()
   If Not blnHasBeenInited Then
      lstSessionView.value = "Form View"
      lstSessionView_Click
      blnHasBeenInited = True
   End If
   
End Sub


Private Sub lstSessionView_Click()
   Select Case lstSessionView.value
      Case "Datasheet"
        Me.subSession.SetFocus
        Me.subSession.Form.SessionID.SetFocus
        DoCmd.RunCommand acCmdSubformDatasheet
        Me.subSession.Form.AllowAdditions = False

      Case "Form View"
         On Error Resume Next
        Me.subSession.SetFocus
        Me.subSession.Form.SessionID.SetFocus
        DoCmd.RunCommand acCmdSubformFormView
        Me.subSession.Form.AllowAdditions = True
      
   End Select
End Sub

----------- end of component
Component: Form_Session; Document Module
Option Compare Database
Option Explicit

Public Event CurrentChanged(PrimaryKey_Current As Long)
Private WithEvents m_Extensions As clsAccessFormExtensions
Private m_DeletingRecord As Boolean

Public Property Get Extensions() As clsAccessFormExtensions
   Set Extensions = m_Extensions
End Property


Private Sub chkAllowDeletions_Click()
   SetAllowDeletions
End Sub

Private Sub cmdDataSheetView_Click()
   DoCmd.OpenForm Me.Name, acFormDS, , , , , acFormDS
 
End Sub

Private Sub Form_Delete(Cancel As Integer)
   If MsgBox("Do you really want to delete this Session?" & vbCrLf & vbCrLf & _
            "All associated data will also be deleted.", vbOKCancel Or vbExclamation Or vbDefaultButton2, "Confirm Deletion") = vbCancel Then
      Cancel = 1
   Else
      m_DeletingRecord = True
   End If
End Sub

Private Sub SetAllowDeletions()
   Me.AllowDeletions = CBool(chkAllowDeletions.value)
   cmdDeleteSession.Enabled = Me.AllowDeletions
End Sub
Private Sub SetColumns()
   If Me.CurrentView = AcFormView.acFormDS Then
      Me.ProcessThisSession.ColumnOrder = 2
   End If
End Sub

Private Sub HideWhenSubform()
   Dim IsSubform As Boolean
   On Error Resume Next
   IsSubform = Not (Me.Parent Is Nothing)
   On Error GoTo 0
   If IsSubform Then
      Me.FormHeader.Visible = False
      Me.FormFooter.Visible = False
      cmdDeleteSession.Visible = False
   End If
End Sub

Private Sub Form_ViewChange(ByVal Reason As Long)
   SetColumns
End Sub

Private Sub m_Extensions_CurrentChanged(PrimaryKey_Current As Long)
   RaiseEvent CurrentChanged(PrimaryKey_Current)
End Sub

Private Sub Form_Load()
   Set m_Extensions = New clsAccessFormExtensions
   Set Me.Extensions.Form = Me
   Me.Extensions.PrimaryKey_FieldName = "SessionID"  'set the PK of your form's recordset
   
   HideWhenSubform
   
   SetColumns
   SetAllowDeletions
End Sub

Private Sub Form_Current()

   UpdateControls
   If Not Me.Extensions Is Nothing Then
      If m_DeletingRecord Then
         m_DeletingRecord = False
      '   Me.Recordset.Requery
      End If
      Me.Extensions.Form_Current
   End If
End Sub


Private Sub cmdNewSubject_Click()
   Dim frmNewSubject As Form_Subject_New
   
   DoCmd.OpenForm "Subject_New", acNormal, , , acFormAdd, acDialog
   
   Set frmNewSubject = Forms!Subject_New
   If frmNewSubject.DialogResult = vbOK Then
      If frmNewSubject.SubjectID_Added > 0 Then
         Me.SubjectID.Requery
         Me.SubjectID.value = frmNewSubject.SubjectID_Added
      End If
   End If
   
   DoCmd.Close acForm, "Subject_New"
   
End Sub

Private Sub UpdateControls()
   cmdNewSubject.Visible = (Me.NewRecord)
End Sub


----------- end of component
Component: Form_Subject_New; Document Module
Option Compare Database
Option Explicit

Private mbrUserAction As VbMsgBoxResult

Public Property Get SubjectID_Added() As Long
   SubjectID_Added = Nz(Me.SubjectID, 0)
End Property


Public Property Get DialogResult() As VbMsgBoxResult
   DialogResult = mbrUserAction
End Property

Private Sub cmdCancel_Click()
   mbrUserAction = vbCancel
   
   Me.Undo  'aborts the edit of the new record
   Me.Visible = False
End Sub

Private Sub cmdOK_Click()
   DoCmd.RunCommand acCmdSaveRecord
   mbrUserAction = vbOK
   Me.Visible = False
End Sub

----------- end of component
Component: Form_Processing Control; Document Module
Option Compare Database
Option Explicit


Private WithEvents frmProcessingGroupSelection As Form_ProcessingStepGroup_Selection
Private WithEvents frmProcessingStep As Form_dsProcessingStep
Private WithEvents frmSession As Form_dsSession


Private Sub DoProcessing()
   On Error GoTo DoProcessing_Err
   
   Dim SessionID As Long
   Dim strSessionDescription As String
   Dim rsSession As New ADODB.Recordset, rsProcessingGroup As New ADODB.Recordset
   rsSession.Open "SELECT * FROM [Session] WHERE ProcessThisSession=True ORDER BY SessionID", CurrentProject.Connection, adOpenStatic, adLockReadOnly
   
   rsProcessingGroup.Open "SELECT * FROM [ProcessingStepGroup] WHERE ProcessThisGroup=True ORDER BY ProcessingOrder", CurrentProject.Connection, adOpenStatic, adLockReadOnly
   
   Dim processing_status_this As eProcessingStatus, processing_status_overall As eProcessingStatus
   Dim strErrorMessage As String
   Dim strLogFilename As String
   Dim ShowLogWindows As Boolean
   Dim SomethingWasDone As Boolean
   Dim AbortProcessing_All As Boolean
   Dim AbortProcessing_ThisSession As Boolean

   ShowLogWindows = CBool(chkOpenLogFileWindows.value)
   
   If chkDefaultLogFilename.value Or txtLogFilename = "" Then
      strLogFilename = GetSettingValue("LogFileFolder_GeneralProcessing", SessionID:=Nz(rsSession![SessionID], 0), ValueIfNotFound:=Environ_SpecialFolder(MyDocuments))
      modUtility.CreatePath strLogFilename
      strLogFilename = strLogFilename & "\ProcessingLog_" & LogFileTimestamp("Filename") & ".txt"
      txtLogFilename = strLogFilename
   Else
      strLogFilename = txtLogFilename
   End If
   
   LogFile_AppendLine strLogFilename, LogFileTimestamp & ": Start of processing"
   
   'Dim fso As New Scripting.FileSystemObject
   'Dim strmLogFile As Scripting.TextStream
   'Set strmLogFile = fso.OpenTextFile(strLogFilename, ForAppending, True)
   
   'Dim objLogFileWindow As IWshRuntimeLibrary.WshExec
   If chkOpenLogFileWindows.value Then
      'Set objLogFileWindow = TailLogFile(strLogFilename)
      TailLogFile (strLogFilename)
   End If
   
   
   processing_status_overall = eProcessingStatus.Unknown
   rsSession.Close
   
   Do
      AbortProcessing_All = False
      processing_status_overall = eProcessingStatus.Completed
      
      'reopen the sessions recordset
      rsSession.Open "SELECT * FROM [Session] WHERE ProcessThisSession=True ORDER BY SessionID", CurrentProject.Connection, adOpenStatic, adLockReadOnly
      
      Do Until rsSession.EOF
         SessionID = rsSession![SessionID]
         strSessionDescription = DLookup("SessionDescription", "lookup_Session", "SessionID=" & SessionID) & ""
         
         
         AbortProcessing_ThisSession = False
         
         rsProcessingGroup.MoveFirst
         Do Until rsProcessingGroup.EOF
            LogFile_AppendLine strLogFilename, LogFileTimestamp & ": Start of processing for session '" & strSessionDescription & _
                "' (SessionID=" & SessionID & "), ProcessingStepGroup='" & rsProcessingGroup![ProcessingStepGroup] & "'"
         
            Select Case rsProcessingGroup![ProcessingStepGroup]
               Case "Initial raw data processing"
                  processing_status_this = modBasicProcessing.Do_InitialRawProcessing(rsSession![SessionID], ShowLogWindows:=ShowLogWindows, LogFilename:=strLogFilename)
               
               Case "Cortical surface extraction"
                  processing_status_this = modCorticalSurfaceExtraction.DoCorticalSurfaceExtraction(rsSession![SessionID], ShowLogWindows:=ShowLogWindows, LogFilename:=strLogFilename)
               
               Case "ASL quantitation"
                  processing_status_this = modASL_Processing.DoASL_Processing(rsSession![SessionID], ShowLogWindows:=ShowLogWindows, LogFilename:=strLogFilename)
               
               Case "DTI processing"
                 processing_status_this = modDTI_Processing.DoDTI_Processing(rsSession![SessionID], ShowLogWindows:=ShowLogWindows, LogFilename:=strLogFilename)
            End Select
   

            LogFile_AppendLine strLogFilename, LogFileTimestamp & ": End of processing for session '" & strSessionDescription & _
                "' (SessionID=" & SessionID & "), ProcessingStepGroup='" & rsProcessingGroup![ProcessingStepGroup] & "'; processing result: " & eProcessingStatus_ToString(processing_status_this)
   
            Select Case processing_status_this
               Case eProcessingStatus.Completed
                  SomethingWasDone = True
                  
               Case eProcessingStatus.ProcessingError
                  strErrorMessage = "Unknown error"
                  processing_status_overall = ProcessingError
                  AbortProcessing_All = True
                  
               Case eProcessingStatus.RequiresUserInteraction
                  processing_status_overall = RequiresUserInteraction
               
               Case eProcessingStatus.RequiresAdditionalProcessing
                  'do not set a status
                  
               Case eProcessingStatus.UnmetDependency
                   processing_status_overall = UnmetDependency
                   strErrorMessage = "Found an unmet dependency while processing '" & rsSession![SessionCode] & _
                              "', processing step group '" & rsProcessingGroup![ProcessingStepGroup] & "'." & vbCrLf & _
                                 "Please check log file for more information: " & strLogFilename
                  AbortProcessing_ThisSession = True
                  
               Case eProcessingStatus.NothingToDo
                  If (processing_status_overall = eProcessingStatus.Completed) And _
                     (Not SomethingWasDone) Then  'if we still haven't done something, then go to the NothgToDo status
                     processing_status_overall = eProcessingStatus.NothingToDo
                  End If
                  'in this case, continue processing.  If still has this status at the end, will exit loop
               
               Case Else
                  Err.Raise vbObjectError + 512, "DoProcessing", "Unrecognized value for processing_status_this=" & processing_status_this
            End Select
            
            If AbortProcessing_ThisSession Or AbortProcessing_All Then Exit Do
            
            rsProcessingGroup.MoveNext
         Loop
         
         If AbortProcessing_All Then Exit Do
         rsSession.MoveNext
      Loop
      
      rsSession.Close
      
      If processing_status_overall = RequiresUserInteraction Then
         processing_status_overall = AllowUserReview(processing_status_overall)
      End If
      
      Dim ExitLoop As Boolean
      ExitLoop = (processing_status_overall <> RequiresAdditionalProcessing)
      DoEvents
      
   Loop Until ExitLoop
   
DoProcessing_Complete:

   On Error Resume Next
   If rsProcessingGroup.State Then rsProcessingGroup.Close
   If rsSession.State Then rsSession.Close
   
   LogFile_AppendLine strLogFilename, LogFileTimestamp & ": Processing Stopped"
   
'   If processing_status_overall = RequiresUserInteraction Then
'      processing_status_overall = AllowUserReview(processing_status_overall)
'   End If
   
'   If Not objLogFileWindow Is Nothing Then
'      objLogFileWindow.Terminate
'   End If
   
   Me.SetFocus
   
   If (processing_status_overall = ProcessingError) Or (processing_status_overall = UnmetDependency) Then
      LogFile_AppendLine strLogFilename, LogFileTimestamp & ": " & strErrorMessage

      MsgBox "Error during processing: " & vbCrLf & strErrorMessage, vbExclamation, "Processing Error"
 
   Else
      Dim strMessage As String
      
      
      strMessage = "Processing complete, at " & LogFileTimestamp & "." & vbCrLf & vbCrLf & "Status: " & eProcessingStatus_ToString(IIf(processing_status_overall = NothingToDo, eProcessingStatus.Completed, processing_status_overall))
      MsgBox strMessage, vbOKOnly, "Processing Complete"

'      strMessage = "Would you like to open the ASL Data Crosstab view, to view the processing results?"
'      If MsgBox(strMessage, vbYesNo Or vbQuestion, "View Processing Results?") = vbYes Then
'         DoCmd.Close acQuery, "Datum_summary_ASL_CBF_xtab", acSaveNo
'         DoCmd.OpenQuery "Datum_summary_ASL_CBF_xtab", acViewNormal
'      End If
      
   End If
   
   Me.subSession.Form.Requery
   
Exit Sub

DoProcessing_Err:
   processing_status_overall = ProcessingError
   strErrorMessage = Err.Description
   strErrorMessage = strErrorMessage & vbCrLf & "Error encountered while processing session '" & strSessionDescription & _
                "' (SessionID=" & SessionID & ")"
   
   Resume DoProcessing_Complete
End Sub


Private Function AllowUserReview(processing_status As eProcessingStatus) As eProcessingStatus
   Dim strSQL As String
   Dim revised_processing_status As eProcessingStatus
   revised_processing_status = processing_status
   Dim AllRequiredReviewDone As Boolean
   AllRequiredReviewDone = True
   
   strSQL = "SELECT Session.SessionID, ProcessingStep.ProcessingStepID  " & _
         "FROM [Session] INNER JOIN ((ProcessingStepGroup INNER JOIN ProcessingStep ON ProcessingStepGroup.ProcessingStepGroupID = ProcessingStep.ProcessingStepGroupID) INNER JOIN Session_ProcessingStep ON ProcessingStep.ProcessingStepID = Session_ProcessingStep.ProcessingStepID) ON Session.SessionID = Session_ProcessingStep.SessionID " & _
         "WHERE (((Session_ProcessingStep.RequiresUserInteraction) = True) And ((ProcessingStep.EnableStep) = True) And ((ProcessingStepGroup.ProcessThisGroup) = True)) " & _
         " AND (Session.ProcessThisSession=True) " & _
         "ORDER BY Session.SessionID, ProcessingStepGroup.ProcessingOrder, ProcessingStep.ProcessingOrder"

   Dim rs As DAO.Recordset
   Set rs = CurrentDb.OpenRecordset(strSQL)
   
   Do Until rs.EOF
      Dim ThisReviewDone As Boolean
      ThisReviewDone = False
      
      Dim oSession As New clsSession
      oSession.SessionID = rs![SessionID]
      Dim psi As New clsProcessingStepInfo
      psi.SessionID = rs![SessionID]
      psi.ProcessingStepID = rs![ProcessingStepID]
      psi.GetStatus
      
      Dim strMessage As String, strCommandLine As String
      
      strMessage = "User review is required for step '" & psi.ProcessingStepName & "' for Session '" & oSession.SessionDescription & "'." & vbCrLf & _
                  vbCrLf & "Would you like to review that now?"
      If MsgBox(strMessage, vbInformation Or vbYesNo, "Do User Review?") = vbYes Then
         Select Case psi.ProcessingStepName
            Case "Review brain mask"
               Dim psiAnatomical As New clsProcessingStepInfo
               psiAnatomical.LoadSessionProcessingStep rs![SessionID], "Cortical surface extraction", "Copy anatomical Nii"
               Dim pso As clsProcessingStepOuptut
               Set pso = psiAnatomical.StepOutout_GetSpecific("Structural Image")
               If Not pso Is Nothing Then
                  strCommandLine = GetSettingValue("Brainsuite GUI filename") & " ""{AnatomicalFilename}"""
                  strCommandLine = Replace(strCommandLine, "{AnatomicalFilename}", oSession.SessionPath_Brainsuite & "\" & pso.OutputFilename)
                  Shell strCommandLine
                  
                  strMessage = "BrainSuite is being opened with the anatomical image." & vbCrLf & vbCrLf & _
                        "Please open the associated brain mask file, review/edit and save that brain mask, then come back here." & _
                         vbCrLf & vbCrLf & "When you have completed any requried editing of the brain mask, select a button to indicate if you want to mark the procssing complete for the '" & psi.ProcessingStepName & "':" & vbCrLf & _
                        "  Click 'Yes' to mark the review as complete. " & vbCrLf & _
                        "  Click 'No' to denote that the review is not yet complete. " & vbCrLf & _
                        "  Click 'Cancel' to abort the user review process for all sessions."
                                     
                  Dim response As VbMsgBoxResult
                  response = MsgBox(strMessage, vbYesNoCancel Or vbInformation, "Review Brain Mask file")
                  If response = vbYes Then
                     psi.Save_CompleteNow
                     ThisReviewDone = True
                  ElseIf response = vbNo Then
                     ThisReviewDone = False
                  
                  ElseIf response = vbCancel Then
                     ThisReviewDone = False
                     AllRequiredReviewDone = False
                     Exit Do
                  End If
               End If
            
            Case Else
               Err.Raise vbObjectError + 512, "AllowUserReview", "Unrecognized option for ProcessingStepName=" & psi.ProcessingStepName
         End Select
      End If
      
      Set oSession = Nothing
      
      AllRequiredReviewDone = AllRequiredReviewDone And ThisReviewDone
      
      rs.MoveNext
   Loop
   
   rs.Close
   
   If processing_status = RequiresUserInteraction Then
      If AllRequiredReviewDone Then
         revised_processing_status = Completed  'force another run through the loop
      Else
         revised_processing_status = UserReviewNotComplete
      End If
   End If
   
   AllowUserReview = revised_processing_status
End Function

Private Sub butShowLogFile_Click()
   If txtLogFilename <> "" Then
      Shell "start """ & txtLogFilename & """", vbNormalFocus
   End If
End Sub

Private Sub UpdateControls()
   txtLogFilename.Enabled = Not CBool(Nz(chkDefaultLogFilename.value, True))
   chkForceCBF_Recalculation.value = CBool(modMRI_Common.GetSettingValue("Force CBF Recalculation", ValueIfNotFound:="false"))
   
End Sub

Private Sub butStartProcessing_Click()
   DoProcessing
End Sub

Private Sub chkDefaultLogFilename_Click()
   UpdateControls
End Sub

Private Sub chkForceCBF_Recalculation_Click()
   modMRI_Common.UpdateSettingValue "Force CBF Recalculation", CStr(CBool(chkForceCBF_Recalculation.value)), True
End Sub

Private Sub chkSelectAll_Click()
   Dim strSQL As String
   strSQL = "UPDATE Session SET ProcessThisSession=" & IIf(chkSelectAll.value, "-1", "0")
   CurrentDb.Execute strSQL
   subSession.Form.Requery
End Sub

Private Sub cmdApplySelectedSubset_Click()
   If Not IsNull(lstProcessingStepSubset.value) Then
      Dim strSQL As String
      strSQL = "UPDATE ProcessingStep SET EnableStep=false"
      CurrentDb.Execute strSQL
      
      strSQL = "UPDATE ProcessingStep INNER JOIN ProcessingStepSubsetMember ON ProcessingStep.ProcessingStepID = ProcessingStepSubsetMember.ProcessingStepID " & _
               "SET ProcessingStep.EnableStep = True " & _
               "WHERE ProcessingStepSubsetMember.ProcessingStepSubsetID=" & lstProcessingStepSubset.value
      CurrentDb.Execute strSQL
       
      strSQL = "UPDATE ProcessingStepGroup SET ProcessThisGroup=false"
      CurrentDb.Execute strSQL
      strSQL = "UPDATE ProcessingStepGroup INNER JOIN (ProcessingStep INNER JOIN ProcessingStepSubsetMember ON ProcessingStep.ProcessingStepID = ProcessingStepSubsetMember.ProcessingStepID) ON ProcessingStepGroup.ProcessingStepGroupID = ProcessingStep.ProcessingStepGroupID " & _
               "SET ProcessingStepGroup.ProcessThisGroup = True " & _
               "WHERE ProcessingStepSubsetMember.ProcessingStepSubsetID=" & lstProcessingStepSubset.value
      CurrentDb.Execute strSQL
 
       
      Me.subProcessingStepGroup_Selection.Requery
      Me.subProcessingStep.Requery
      UpdateControls
      UpdateCounts
   End If
End Sub

Private Sub Form_Load()
   Set frmProcessingStep = Me.subProcessingStep.Form
   Set frmProcessingGroupSelection = Me.subProcessingStepGroup_Selection.Form
   Set frmSession = Me.subSession.Form
   
   UpdateControls
   UpdateCounts
End Sub

Private Sub Form_Open(Cancel As Integer)
   Dim strSessionID_Filter As String
   strSessionID_Filter = modUtility.RegEx_ExtractSubstring(Me.OpenArgs & "", "SessionID=(\d+)")
   If strSessionID_Filter <> "" Then
      Dim strSQL As String
      strSQL = "UPDATE Session SET  ProcessThisSession=false"
      CurrentDb.Execute strSQL
      strSQL = "UPDATE Session SET  ProcessThisSession=true WHERE SessionID=" & strSessionID_Filter
      CurrentDb.Execute strSQL
      MsgBox "The specified session has been selected for processing (" & Me.OpenArgs & ")"
   End If
End Sub

Private Sub frmProcessingGroupSelection_CurrentChanged(PrimaryKey_Current As Long)
   frmProcessingStep.Extensions.SetFilter ("ProcessingStepGroupID=" & PrimaryKey_Current)
   UpdateCounts
End Sub


Private Sub UpdateCounts()
   Dim strSQL As String
   strSQL = "SELECT ProcessingStep.ProcessingStep " & _
            "FROM ProcessingStepGroup INNER JOIN ProcessingStep ON ProcessingStepGroup.ProcessingStepGroupID = ProcessingStep.ProcessingStepGroupID " & _
            "WHERE (((ProcessingStepGroup.ProcessThisGroup)=True) AND ((ProcessingStep.EnableStep)=True))"
            
   Dim rs As DAO.Recordset
   Set rs = CurrentDb.OpenRecordset(strSQL)
   If rs.EOF Then
      txtCountSelectedProcessingSteps = 0
   Else
      rs.MoveLast
   txtCountSelectedProcessingSteps = rs.RecordCount
   End If
   rs.Close
   
   txtCountSelectedSessions = CStr(DCount("SessionID", "Session", "ProcessThisSession=true"))
   
End Sub

Private Sub frmProcessingStep_CurrentChanged(PrimaryKey_Current As Long)
   UpdateCounts
End Sub

Private Sub frmSession_CurrentChanged(PrimaryKey_Current As Long)
   UpdateCounts
End Sub

Private Sub subProcessingStep_Exit(Cancel As Integer)
   If Not frmProcessingStep Is Nothing Then frmProcessingStep.Extensions.CaptureSelectedRecords
End Sub


Private Sub subProcessingStepGroup_Selection_Exit(Cancel As Integer)
   If Not frmProcessingGroupSelection Is Nothing Then frmProcessingGroupSelection.Extensions.CaptureSelectedRecords
End Sub
   
Private Sub subSession_Exit(Cancel As Integer)
   If Not frmSession Is Nothing Then frmSession.Extensions.CaptureSelectedRecords
End Sub


----------- end of component
Component: clsAccessFormExtensions; Class module
Option Compare Database
Option Explicit


'To use this extension class in your form, do the following:

'If your form code is currently empty, put these lines into your form code and uncomment:
'(remember to change the value of "PrimaryKey_FieldName")

'---------------------------------

'Public Event CurrentChanged(PrimaryKey_Current As Long)
'Private WithEvents m_Extensions As clsAccessFormExtensions

'Public Property Get Extensions() As clsAccessFormExtensions
'   Set Extensions = m_Extensions
'End Property
'Private Sub m_Extensions_CurrentChanged(PrimaryKey_Current As Long)
'   RaiseEvent CurrentChanged(PrimaryKey_Current)
'End Sub

'Private Sub Form_Load()
'   Set m_Extensions = New clsAccessFormExtensions
'   Set Me.Extensions.Form = Me
'   Me.Extensions.PrimaryKey_FieldName = <<"TargetTranscriptID">>  'set the PK of your form's recordset
'End Sub
'
'Private Sub Form_Current()
'   Me.Extensions.Form_Current
'End Sub


'----------------------------\
'Put these lines in the master form containing your subform, and fix as necessary

'Private WithEvents frmExtendedSubform As Form_xxxxxxx 'fill in this with the name of your form class

'Private Sub subTheSubform_Exit(Cancel As Integer)
'   frmExtendedSubform.Extensions.CaptureSelectedRecords
'End Sub

'Private Sub frmExtendedSubform_CurrentChanged(PrimaryKey_Current As Long)
'   'do something
'End Sub

'Private Sub Form_Load()
'   Set frmExtendedSubform = Me.subTheSubform.Form
'End Sub









'----------------------------\
'Step-by-step instructions




'1. Put these lines in the declarations section at top of form class:

   'Public Event CurrentChanged(PrimaryKey_Current As Long)
   'Private WithEvents m_Extensions As clsAccessFormExtensions

   'Public Property Get Extensions() As clsAccessFormExtensions
   '   Set Extensions = m_Extensions
   'End Property
   'Private Sub m_Extensions_CurrentChanged(PrimaryKey_Current As Long)
   '   RaiseEvent CurrentChanged(PrimaryKey_Current)
   'End Sub

'2. In the Form_Load event, place these two line:
   'Set m_Extensions = New clsAccessFormExtensions
   'Set Me.Extensions.Form = Me
   'Me.Extensions.PrimaryKey_FieldName = "TargetTranscriptID"  'set the PK of your form's recordset

'3. In the Form_Current event, place this line (as the first line)
   'Me.Extensions.Form_Current

'4. In the master form (the form in which your form is a child subform) place code similar to this in the
'        declarations section (choose any names you like) ("WithEvents" is optoinal)
   'Private WithEvents subCloneSourceGraphic As Form_TargetTranscript_Graphic_subform

'5. Optional: add this event handler for the subform object that contains your child form
'        This is necessary only if you want to get the array of selected records in the child form
   'Private Sub CloneSource_Graphic_subform_Exit(Cancel As Integer)
   '   subCloneSourceGraphic.Extensions.CaptureSelectedRecords
   'End Sub

'6. Optional: add an event handler for the child forms CurrentChanged event.
   'Private Sub subCloneSourceGraphic_CurrentChanged(PrimaryKey_Current As Long)
   '   'do something
   'End Sub


'7. and add a line into the Form_Load to set a reference to your child form
   'Private Sub Form_Load()
   '   Set subCloneSourceSimple = Me.CloneSource_Simple_subform.Form



Private Const ThisClassName As String = "clsAccessFormExtensions"
Private Const ThisClassErrorNumberBase As Long = vbObjectError + 512

Private m_PrimaryKey_FieldName As String

Private m_AdditionalKey_FieldName As String

Public Event CurrentChanged(PrimaryKey_Current As Long)
Private Const errCode_NoCurrentRecord = 3021
Private Const errCode_RecordWasDeleted = 3167
Private m_HostForm As Access.Form
Private arrPrimaryKey_Selected() As Long
Private arrAdditionalKey_Selected() As Long

Private m_UsingPositionToPK As Boolean  'set this to True in the Form_Load to indicate that the
      'host form will be using the PositionToPK_Value function to control the displayed record instead of standard Access subform linking
      'This is important to make things work correctly when a linking record is not found.
Private m_PositionToPK_Valid As Boolean

Public Property Set Form(f As Access.Form)
   Set m_HostForm = f
End Property
Public Property Get Form() As Access.Form
   Set Form = m_HostForm
End Property

Public Property Let UsingPositionToPK(b As Boolean)
   m_UsingPositionToPK = b
End Property
Public Property Get UsingPositionToPK() As Boolean
   UsingPositionToPK = m_UsingPositionToPK
End Property

Public Property Let PrimaryKey_FieldName(s As String)
   m_PrimaryKey_FieldName = s
End Property
Public Property Get PrimaryKey_FieldName() As String
   PrimaryKey_FieldName = m_PrimaryKey_FieldName
End Property

Public Property Let AdditionalKey_FieldName(s As String)
   'by default, when user request the captured records, the values returned are from the PrimaryKey field.
   'However, if this value is set, a different field can be returned.  Note that it must be a LongInt field
   m_AdditionalKey_FieldName = s
End Property
Public Property Get AdditionalKey_FieldName() As String
   AdditionalKey_FieldName = m_AdditionalKey_FieldName
End Property


Public Sub SetPrimaryKey_FieldName(PrimaryKeyName As String)


'The original idea of this procedure was to dynamically look at the recordsource of the parent form and determine the primary key
'However, that is rather a pain in the ass, doesn't really work in practice.
'So instead use this proc to change the PrimaryKey_FieldName.  Turns out that when using late binding access to this class, Access VBA
' can *read* the property PrimaryKey_FieldName, but it cannot write the property.  So instead use this as a normal subroutine

   m_PrimaryKey_FieldName = PrimaryKeyName

'   If Not (m_HostForm Is Nothing) Then
'      Dim rs As DAO.Recordset
'      Set rs = Me.Form.Recordset
'      If rs.Type = dbOpenTable Then
'         Dim indx As index
'         Set indx = CurrentDb.TableDefs(rs.Name).Indexes(rs.index)
'         Me.PrimaryKey_FieldName = indx.fields(0).Name
'      Else
'         Err.Raise ThisClassErrorNumberBase, ThisClassName & ":" & "SetPrimaryKey_FieldName", "SetPrimaryKey_FieldName can only be used on Table-type recordsets."
'      End If
'   Else
'      Err.Raise ThisClassErrorNumberBase, ThisClassName & ":" & "SetPrimaryKey_FieldName", "Must set the Form property."
'   End If
End Sub
Private Function rsMe() As DAO.Recordset
   Dim frm As Access.Form
   Set frm = Me.Form
   Set rsMe = frm.Recordset

End Function

Private Function HasCurrentRecord() As Boolean
   Dim rs As DAO.Recordset
   Dim A_Value As String
   Dim ValidCurrentRecord As Boolean
   
   Set rs = rsMe

   On Error Resume Next
   'do test for a current record ... for some reason the test "Not (rsMe.EOF Or rsMe.BOF)" does not work...
   Err.Clear
   A_Value = rs.Fields(0)
   If (rs.EOF Or rs.BOF) Or _
      (((Err.Number = errCode_NoCurrentRecord) Or (Err.Number = errCode_RecordWasDeleted))) Then
      ValidCurrentRecord = False
   Else
      ValidCurrentRecord = True
   End If
   On Error GoTo 0

   HasCurrentRecord = ValidCurrentRecord
End Function

Private Sub EnsureRecordsetCurrent()
   'this is to overcome a weird problem with subforms.  When the parent changes, and the records in the subform
   ' are filtered, the Me.Recordset ends up with BOF=False, EOF=False, but not current record!  This is true even though
   ' the form clearly displays a current record pointed on a data grid, and you can get the value of the fields directly
   ' from the form bound controls!

   'The problem is even worse if the filtered recordset has only one record.  In that case, the user cannot even force a current record
   ' by selecting a different record.
   
   Dim lngPK_Current_FromControl As Long
   Dim rs As DAO.Recordset
   Dim frm As Access.Form
      
   Set rs = rsMe
   Set frm = Me.Form

   If rs.RecordCount > 0 Then
      If Not HasCurrentRecord Then
         lngPK_Current_FromControl = -1
         On Error Resume Next
         lngPK_Current_FromControl = CLng(CStr(frm.Controls(m_PrimaryKey_FieldName)))
         On Error GoTo 0
         
         If lngPK_Current_FromControl > 0 Then
            rs.MoveFirst
            If rs.Fields(m_PrimaryKey_FieldName) > 0 Then  'HACK!!!
                'This next line can fail after doing a Delete of record.  For now, disable this.   TF 11 June 2018
               ' Debug.Assert (lngPK_Current_FromControl = rs.Fields(m_PrimaryKey_FieldName))
            End If
         End If
      End If
   End If
End Sub


Public Function RequeryAndPosition(PKValue As Long) As Boolean
   Dim rs As DAO.Recordset
   Dim frm As Access.Form
      
   Set rs = rsMe
   Set frm = Me.Form
      
   frm.Requery

   RequeryAndPosition = Me.PositionTo(PKValue)
End Function

Public Function PositionTo(PKValue As Long) As Boolean
   Dim found_record As Boolean, changed_position As Boolean
   Dim rs As DAO.Recordset, rsClone As DAO.Recordset
   Set rs = rsMe
   

   If rs.RecordCount > 0 Then

      If (PKValue > 0) And (Me.PrimaryKey_Current = PKValue) Then
         found_record = True
         changed_position = False
      Else

         Set rsClone = rs.clone

         rsClone.MoveFirst
      
         If rsClone.Fields(m_PrimaryKey_FieldName) = PKValue Then
            found_record = True
         Else
            rsClone.FindFirst m_PrimaryKey_FieldName & "=" & PKValue
            found_record = Not rsClone.NoMatch
         End If

         If found_record Then
            rs.Bookmark = rsClone.Bookmark 'move to the found record
         Else
            rs.MoveFirst
            If Not rs.BOF Then rs.MovePrevious  'move before the first record
         End If

         changed_position = True
         rsClone.Close
      End If
   End If

   m_PositionToPK_Valid = found_record


   'this concept is not yet correctly implemented in this class.  For an example of its use,
   ' see the form 'Form_TargetTranscriptFeatureAlignmentGraphicFrame_subform'

   If m_UsingPositionToPK Then
'      If changed_position Then
'         FormSpecific_OnCurrent
'      End If
      Me.Form.Visible = m_PositionToPK_Valid
   End If
   DoEvents


   PositionTo = found_record
End Function

Public Property Get PrimaryKey_Current() As Long
PrimaryKey_Current = AnyKey_Current(m_PrimaryKey_FieldName)
End Property

Public Property Get AnyKey_Current(FieldName As String) As Long
   'returns a value from any LongInt field in the current record
   
   Dim lngKeyValue As Long, NoCurrentRecord As Boolean
   Dim rs As DAO.Recordset
   Dim strKeyValue As String
   Dim frm As Access.Form

   If HasCurrentRecord Then
  
      Set rs = rsMe
      On Error Resume Next
      lngKeyValue = -1

      'Why do we need to test the Application.Version ?
      'The problem is that during a record position change (for example, while processing the Form_Current event ), in
      ' Access 2000 (ver 9.0) the form's recordset is not yet re-positioned!  The *controls* of the form will report the
      ' new values, but the Form.Recordset will still report values from the previous record, before the change!

      'Therefore in older versions, use the value from the controls of the form.
      'Why not just do this in all cases (in later versions)... I don't know, just seems sloppy.

      If modAccessUtilities.Application_Version >= 10 Then
         lngKeyValue = Nz(rs.Fields(FieldName), -1)
      Else
         Set frm = Me.Form
         strKeyValue = CStr(frm.Controls(FieldName))
         If IsNumeric(strKeyValue) Then
            lngKeyValue = CLng(strKeyValue)
         'Else
         '   lngKeyValue = -1
         End If
      End If

      On Error GoTo 0
   Else
      lngKeyValue = -1
   End If

   AnyKey_Current = lngKeyValue
End Property

Public Sub CaptureSelectedRecords()
   'user of this subform should execute this procudere in the OnExit event for the subform
   BuildSelectedRecordsArray
   
End Sub
Public Property Get SelectedRecordsCount() As Long
   SelectedRecordsCount = UBound(arrPrimaryKey_Selected) + 1
End Property
Public Property Get SelectedRecords_PrimaryKey() As Long()
   SelectedRecords_PrimaryKey = arrPrimaryKey_Selected
End Property

Public Property Get SelectedRecords_PrimaryKey_String() As String
   SelectedRecords_PrimaryKey_String = ArrayToString(arrPrimaryKey_Selected)
End Property

Public Property Get SelectedRecords_AdditionalKey() As Long()
   SelectedRecords_AdditionalKey = arrAdditionalKey_Selected
End Property

Public Property Get SelectedRecords_AdditionalKey_String() As String
   SelectedRecords_AdditionalKey_String = ArrayToString(arrAdditionalKey_Selected)
End Property


Public Property Get AllRecords_PrimaryKey_String() As String
   AllRecords_PrimaryKey_String = ArrayToString(Me.AllRecords_PrimaryKey)
End Property

Private Function ArrayToString(arr() As Long) As String
   Dim strSelectedRecords As String
   Dim i As Long, lb As Long, ub As Long
   lb = 0
   ub = -1
   On Error Resume Next
   lb = LBound(arr)
   ub = UBound(arr)
   On Error GoTo 0
   For i = lb To ub
      strSelectedRecords = strSelectedRecords & "," & CStr(arr(i))
   Next i
   If strSelectedRecords <> "" Then
      ArrayToString = Mid(strSelectedRecords, 2) 'omit the leading ','
   Else
      ArrayToString = ""
   End If
End Function

Public Property Get AllRecords_PrimaryKey() As Long()
   Dim arrRecs() As Long
   Dim rs As DAO.Recordset

   Set rs = rsMe.clone
   rs.Filter = rsMe.Filter 'copy the filter, not done by default

   If rs.RecordCount > 0 Then
      With rs
         Dim i As Long
         ReDim arrRecs(.RecordCount - 1)
         .MoveFirst
         i = 0
         Do Until .EOF
            arrRecs(i) = .Fields(m_PrimaryKey_FieldName)
            .MoveNext
            i = i + 1
         Loop
      End With
   Else
   End If

   AllRecords_PrimaryKey = arrRecs
End Property

Private Sub BuildSelectedRecordsArray()
   BuildSelectedRecordsArray_KeyName m_PrimaryKey_FieldName
   
   Dim fld As DAO.Field
   If m_AdditionalKey_FieldName <> "" Then
      On Error Resume Next
      Set fld = Nothing
      Set fld = rsMe.Fields(m_AdditionalKey_FieldName)
      On Error GoTo 0
      
      If Not (fld Is Nothing) Then
         BuildSelectedRecordsArray_KeyName m_AdditionalKey_FieldName
      Else
         Erase arrAdditionalKey_Selected
      End If
   End If

End Sub

Private Sub BuildSelectedRecordsArray_KeyName(KeyName As String)
   
   Dim i As Long
   Dim rs As DAO.Recordset
   Dim NoCurrentRecord As Boolean

   Dim frm As Access.Form
   Dim fldName As String
   Dim BuildPKArray As Boolean
   Dim arr() As Long, lb As Long, ub As Long
   
   fldName = KeyName
   BuildPKArray = (KeyName = m_PrimaryKey_FieldName)
   If BuildPKArray Then
      Erase arrPrimaryKey_Selected
   Else
      Erase arrAdditionalKey_Selected
   End If
   
   Set rs = rsMe
   Set frm = Me.Form

   NoCurrentRecord = Not HasCurrentRecord

   If rs.RecordCount = 0 Or (NoCurrentRecord And rs.RecordCount > 1) Then
      'no records, or no current record in a record set that has more than one; so clear array
      'Erase arrPrimaryKey_Selected
   ElseIf (rs.RecordCount = 1) Then
      'in the case of a single record, strange things happen ... sometimes
      'looks as if there is no current record.  But in fact the single record should always
      'be the selected record
      
      ReDim arr(0)
      With rs.clone
         .MoveFirst
         arr(0) = CLng(Nz(.Fields(fldName), -1))
      End With

   Else
      If (frm.SelHeight = 0) Then
         'if no record seems to be selected, just report that the current record is selected
         ReDim arr(0)
         arr(0) = Me.AnyKey_Current(fldName)      'Me.PrimaryKey_Current  'rs.fields(m_PrimaryKey_FieldName)
      Else
         'A silly thing happens if you select an entire column, on a datasheet that is enabled for record addition
         'The last row, the blank row for the new record, is counted in the SelHeight !
         'The problem occurs when trying to access the value of that row ... throws an error.
         'To avoid, limit the SelHeight to the number of records.
         Dim SelectionHeight_Limited As Long
         SelectionHeight_Limited = Min(frm.SelHeight, rs.RecordCount)

         ReDim arr(SelectionHeight_Limited - 1)
      
         With rs.clone
            .MoveFirst
            .Move frm.SelTop - 1
            
            For i = 0 To UBound(arr)
               arr(i) = CLng(Nz(.Fields(fldName), -1))
               .MoveNext
            Next i
         End With
      End If
   End If


   'transfer to the PK or Additional array
   On Error Resume Next
   lb = 0
   ub = -1
   lb = LBound(arr)
   ub = UBound(arr)
   If BuildPKArray Then
      ReDim arrPrimaryKey_Selected(ub)
   Else
      ReDim arrAdditionalKey_Selected(ub)
   End If
   
   For i = lb To ub
      If BuildPKArray Then
         arrPrimaryKey_Selected(i) = arr(i)
      Else
         arrAdditionalKey_Selected(i) = arr(i)
      End If
   Next i
   

End Sub


Friend Sub Form_Current()

   If Not m_UsingPositionToPK Then
      'if using the PositionToPK_Value to select the current record, do not call this routine ... it will be called by PositionToPK_Value
      EnsureRecordsetCurrent
   End If
   BuildSelectedRecordsArray
   RaiseEvent CurrentChanged(Me.PrimaryKey_Current)
End Sub


Private Sub Form_LostFocus()
   DoEvents
End Sub


Public Sub SetFilter(strFilter As String)
   If strFilter <> "" Then
      If Me.Form.Filter <> strFilter Then
         Me.Form.Filter = strFilter
      End If
      Me.Form.FilterOn = True
   Else
      Me.Form.FilterOn = False
   End If
End Sub

----------- end of component
Component: Form_ProcessingStepGroup_Selection; Document Module
Option Compare Database
Option Explicit

Public Event CurrentChanged(PrimaryKey_Current As Long)
Private WithEvents m_Extensions As clsAccessFormExtensions

Public Property Get Extensions() As clsAccessFormExtensions
   Set Extensions = m_Extensions
End Property
Private Sub m_Extensions_CurrentChanged(PrimaryKey_Current As Long)
   RaiseEvent CurrentChanged(PrimaryKey_Current)
End Sub

Private Sub Form_Load()
   Set m_Extensions = New clsAccessFormExtensions
   Set Me.Extensions.Form = Me
   Me.Extensions.PrimaryKey_FieldName = "ProcessingStepGroupID"  'set the PK of your form's recordset
End Sub

Private Sub Form_Current()
   If Not Me.Extensions Is Nothing Then Me.Extensions.Form_Current
End Sub

----------- end of component
Component: Form_dsProcessingStep; Document Module
Option Compare Database
Option Explicit

Public Event CurrentChanged(PrimaryKey_Current As Long)
Private WithEvents m_Extensions As clsAccessFormExtensions

Public Property Get Extensions() As clsAccessFormExtensions
   Set Extensions = m_Extensions
End Property
Private Sub m_Extensions_CurrentChanged(PrimaryKey_Current As Long)
   RaiseEvent CurrentChanged(PrimaryKey_Current)
End Sub

Private Sub Form_Load()
   Set m_Extensions = New clsAccessFormExtensions
   Set Me.Extensions.Form = Me
   Me.Extensions.PrimaryKey_FieldName = "ProcessingStepID"  'set the PK of your form's recordset
End Sub

Private Sub Form_Current()
   If Not Me.Extensions Is Nothing Then Me.Extensions.Form_Current
End Sub
----------- end of component
Component: Form_Import New MRI Data; Document Module
Option Compare Database
Option Explicit


Private Sub butBrowseDataFolder_Click()
   Dim dlg As FileDialog
   Set dlg = Application.FileDialog(msoFileDialogFolderPicker)
   With dlg
      .InitialFileName = GetSettingValue("RawDataImport_LastUsedFolder", ValueIfNotFound:="C:\")
      .ButtonName = "Select Folder"
      .Title = "Select folder containing the MRI DICOM Image files"
      If .Show Then
         txtRawDataFolder = .SelectedItems(1)
         UpdateSettingValue "RawDataImport_LastUsedFolder", .SelectedItems(1), True
         
         'try to get date modified of one of the files
         Dim strFirstIMA_Filename As String
         strFirstIMA_Filename = Dir(.SelectedItems(1) & "\" & "*.IMA")
         If strFirstIMA_Filename <> "" Then
            Dim fso As New Scripting.FileSystemObject
            Dim fil As Scripting.File
            Set fil = fso.GetFile(.SelectedItems(1) & "\" & strFirstIMA_Filename)
            If Not fil Is Nothing Then
               txtSessionDate = DateValue(fil.DateLastModified)
            End If
         End If
         
         SetSuggestedNames
      End If
   End With
End Sub

Private Function SessionFolder_Default(ProjectID As Long, SessionCode As String) As String
   Dim strDataRootPath  As String
   Dim oSession As New clsSession
  
   strDataRootPath = oSession.GetDataRootPath(ProjectID)

   If SessionCode <> "" Then
      strDataRootPath = strDataRootPath & "\" & SessionCode
   End If
   SessionFolder_Default = strDataRootPath
End Function

Private Sub butSessionFolder_Select_Click()
   Dim dlg As FileDialog
   
   Set dlg = Application.FileDialog(msoFileDialogFolderPicker)
   With dlg

      .InitialFileName = SessionFolder_Default(cboProject.value, "")
      .ButtonName = "Select Folder"
      .Title = "Specify the folder for the Session data"
      If .Show Then
         txtSessionFolder = .SelectedItems(1)
      End If
      
      
   End With
End Sub

Private Sub cboProject_Change()
   PopulateSubjectTypes
   PopulateSubjects
   PopulateSubjectCode_PerPrefix_temp
   SetSuggestedNames
End Sub

Private Sub cboSubjectCode_AfterUpdate()
   SetSuggestedNames True
End Sub

Private Sub cboSubjectCode_Change()
   SetDefaultSessionFolder
End Sub

Private Sub cboSubjectType_Change()
   PopulateSubjects
   SetSuggestedNames
End Sub

Private Sub chkShowAllSubjectTypes_Click()
   PopulateSubjectTypes
End Sub


Private Sub cmdImportData_Click()
   'create subject, if necessary
   Dim SubjectID As Long, SessionID As Long
   Dim CreatedSubject As Boolean
   Dim rs As DAO.Recordset
   
Try:
   On Error GoTo Catch
   UpdateSettingValue "MoveOrCopyFiles", cboRawImportOption.value, _
         True, DLookup("ProcessingStepID", "ProcessingStep", "ProcessingStep=""Move raw files into subfolder""")
         
   SubjectID = Nz(DLookup("SubjectID", "Subject", "SubjectIdentifier=""" & cboSubjectCode & """"), 0)
   If SubjectID = 0 Then
      Set rs = CurrentDb.OpenRecordset("Subject", dbOpenDynaset)
      With rs
         .AddNew
         ![SubjectTypeID] = cboSubjectType.value
         ![SubjectIdentifier] = cboSubjectCode
         ![Age] = txtAge
         ![Sex] = cboSex
         ![Description] = txtDescription_Subject
         .Update
         CreatedSubject = True
         .Bookmark = .LastModified
         SubjectID = ![SubjectID]
      End With
      rs.Close
   End If
   
   
   'create session
   'Also check if similar session already exists
   Dim OK_ToCreateSession As Boolean
   Set rs = CurrentDb.OpenRecordset("SELECT * FROM Session WHERE SessionCode='" & txtSessionIdentifier & "' AND SubjectID=" & CStr(SubjectID), dbOpenDynaset)
   If rs.EOF Then
      OK_ToCreateSession = True
   Else 'if we found a record like ths already, make sure user wants to import into that record
      Dim strMsg As String
      strMsg = "For Subject '" & cboSubjectCode & "', a session record already exists with SessionCode='" & txtSessionIdentifier & "'." & vbCrLf & _
      "Do you really want to import data for that session that was previously created?" & vbCrLf & "If not, please Cancel and change the SessionCode to a unique value not previously defined."
      If MsgBox(strMsg, vbOKCancel Or vbExclamation, "Import into previous Session?") = vbOK Then
         SessionID = rs![SessionID]
         OK_ToCreateSession = False
      Else
         SessionID = -1
         OK_ToCreateSession = False
      End If
   End If
   
   If OK_ToCreateSession Then
   With rs
         .AddNew
         ![ProjectID] = cboProject.value
         ![SessionCode] = txtSessionIdentifier
         ![SessionDate] = txtSessionDate
         ![SubjectID] = SubjectID
         ![Description] = txtDescription_Session
         Dim strSessionFolder As String, strProjectRootFolder As String
         strProjectRootFolder = SessionFolder_Default(cboProject.value, "")
         strSessionFolder = txtSessionFolder
         If Left(strSessionFolder, Len(strProjectRootFolder)) = strProjectRootFolder Then
            strSessionFolder = Mid(strSessionFolder, Len(strProjectRootFolder) + 2)
         End If
         ![RootFolder] = strSessionFolder
         ![ProcessThisSession] = True
         ![OriginalImportFolder] = txtRawDataFolder
         .Update
         .Bookmark = .LastModified
         SessionID = ![SessionID]
      End With
   End If
   rs.Close
   
   If SessionID > 0 Then
  '    MsgBox "Created " & IIf(CreatedSubject, "new Subject and ", "") & "Session records.  Will now proceed to import the MRI images.", vbInformation
      
      Screen.MousePointer = 11 'hourglass
      
      modUtility.CreatePath txtSessionFolder
      modBasicProcessing.Do_InitialRawProcessing SessionID, DoDicomToNifti:=False, ShowLogWindows:=True
         
      Dim CountSuccessfulSteps As Integer
      Dim strSQL As String
      
      strSQL = "SELECT Session_ProcessingStep.Session_ProcessingStepID " & _
               "FROM ProcessingStepGroup INNER JOIN (ProcessingStep INNER JOIN Session_ProcessingStep ON ProcessingStep.ProcessingStepID = Session_ProcessingStep.ProcessingStepID) ON ProcessingStepGroup.ProcessingStepGroupID = ProcessingStep.ProcessingStepGroupID " & _
               "WHERE (ProcessingStepGroup.ProcessingStepGroup=""Initial raw data processing"") AND (Session_ProcessingStep.SessionID={SessionID}) AND (Session_ProcessingStep.Complete=True)"
      strSQL = Replace(strSQL, "{SessionID}", CStr(SessionID))
   
      Set rs = CurrentDb.OpenRecordset(strSQL)
      rs.MoveLast
      CountSuccessfulSteps = rs.RecordCount
      rs.Close
      
      Screen.MousePointer = 0 'default
      
      If CountSuccessfulSteps = 2 Then
         If MsgBox("The import of the data was completed." & vbCrLf & vbCrLf & "Would you like to open the Processing Control form to initiate data processing?", vbInformation Or vbYesNo, "Import Successful") = vbYes Then
            DoCmd.OpenForm "Processing Control", acNormal, , , acFormEdit, acWindowNormal, "SessionID=" & SessionID
            DoCmd.Close acForm, "ImportNewMRI_Data"
         End If
      Else
         DoCmd.OpenForm "dsSession_ProcessingStep", acFormDS, , "SessionID=" & SessionID, acFormEdit, acWindowNormal
         MsgBox "It seems that import of the data files did not complete correctly.  Please review the information in the 'Completed Processing Steps' view, and try to correct the problem.", vbExclamation
      End If
      
      PopulateSubjects
   End If
   
   GoTo Finally
   
Catch:
   MsgBox "Import Error: " & Err.Number & vbCrLf & vbCrLf & Err.Description, vbCritical, "Import Error"
   
Finally:
   PopulateSubjectCode_PerPrefix_temp
   Screen.MousePointer = 0 'default
End Sub

Private Sub Form_Load()
   cboRawImportOption.value = GetSettingValue("MoveOrCopyFiles", _
            ProcessingStepID:=DLookup("ProcessingStepID", "ProcessingStep", "ProcessingStep=""Move raw files into subfolder"""), _
            ValueIfNotFound:="Copy")
            
   PopulateSubjects
   SetSuggestedNames
   SetSessionControls
End Sub

Private Sub PopulateSubjectTypes()
   Dim ProjectID_Current As Long
   ProjectID_Current = Nz(cboProject.value, -1)
   
   Dim SomeProjectSpecificSubjectTypes As Boolean
   SomeProjectSpecificSubjectTypes = (DCount("SubjectTypeID", "lookup_SubjectType", "ProjectID_Specific=" & CStr(ProjectID_Current)) > 0)
   
   If SomeProjectSpecificSubjectTypes And (Not Nz(chkShowAllSubjectTypes.value, 0)) Then
      cboSubjectType.RowSource = "select * from lookup_SubjectType where ProjectID_Specific=" & CStr(ProjectID_Current)
   Else
      If Nz(chkShowAllSubjectTypes.value, 0) Then
         cboSubjectType.RowSource = "select * from lookup_SubjectType"
      Else
         cboSubjectType.RowSource = "select * from lookup_SubjectType where ProjectID_Specific IS NULL"
      End If
   End If
   cboSubjectType.Requery
   
End Sub

Private Sub PopulateSubjects()
   Dim strSQL As String
   Dim rs As DAO.Recordset
   
   If Nz(Me.cboProject.value, 0) > 0 Then
      strSQL = "SELECT Subject.SubjectIdentifier FROM Subject INNER JOIN [Session] ON Subject.SubjectID = Session.SubjectID " & _
               "WHERE Session.ProjectID = " & Me.cboProject.value & " "
      If Nz(cboSubjectType.value, 0) > 0 Then
         strSQL = strSQL & "AND Subject.SubjectTypeID=" & cboSubjectType.value & " "
      End If
      
      strSQL = strSQL & "GROUP BY Subject.SubjectIdentifier ORDER BY Subject.SubjectIdentifier"
   Else
      strSQL = "SELECT SubjectIdentifier FROM Subject WHERE SubjectIdentifier<>"""" "
      If Nz(cboSubjectType.value, 0) > 0 Then
         strSQL = strSQL & "AND Subject.SubjectTypeID=" & cboSubjectType.value & " "
      End If
   End If
   
   Set rs = CurrentDb.OpenRecordset(strSQL)
   
   Dim strList As String
   Do Until rs.EOF
      strList = strList & IIf(strList = "", "", ";") & rs![SubjectIdentifier]
      rs.MoveNext
   Loop
   rs.Close
   cboSubjectCode.RowSource = strList
   
End Sub

Private Sub PopulateSubjectCode_PerPrefix_temp()
   'build up the little local table 'SubjectCode_PerPrefix_temp' to contain the current max SubjectCode for each prefix currently in use for the selected ProjectID
   Dim cn As ADODB.Connection
   Set cn = CurrentProject.Connection
   
   cn.Execute "DELETE * FROM SubjectCode_PerPrefix_temp"
   
   Dim ProjectID_Current As Long
   ProjectID_Current = Nz(cboProject.value, -1)
   Dim rsSubjects As New ADODB.Recordset
   If ProjectID_Current > 0 Then
      rsSubjects.Open "SELECT [Subject].[SubjectIdentifier] FROM [Subject] INNER JOIN [Session] ON ([Subject].SubjectID = [Session].SubjectID) WHERE ([Session].ProjectID=" & ProjectID_Current & ")", cn, adOpenDynamic, adLockReadOnly
   Else
      rsSubjects.Open "SELECT Subject.SubjectIdentifier FROM Subject ", cn, adOpenStatic, adLockReadOnly
   End If
   
   Dim dicSubjectCodes As New Scripting.Dictionary
   Dim strPrefix As String, strSubjectCode As String
   Do Until rsSubjects.EOF
      strSubjectCode = rsSubjects![SubjectIdentifier]
      strPrefix = modUtility.RegEx_ExtractSubstring(strSubjectCode, "^([^\d\-]+)\-?\d+$")
      If strPrefix <> "" Then
         If Not dicSubjectCodes.Exists(strPrefix) Then
            dicSubjectCodes.Add strPrefix, strSubjectCode
         End If
         
         If StrComp(strSubjectCode, dicSubjectCodes(strPrefix), vbBinaryCompare) = 1 Then 'returns 1 if string1 is greater than string2
            dicSubjectCodes(strPrefix) = strSubjectCode
         End If
         
      End If
      rsSubjects.MoveNext
   Loop

   rsSubjects.Close
   
   'now add items to the table
   Dim varPrefix As Variant
   rsSubjects.Open "SELECT Prefix,Max_SubjectCode FROM SubjectCode_PerPrefix_temp", cn, adOpenStatic, adLockOptimistic
   For Each varPrefix In dicSubjectCodes.Keys
      Debug.Print varPrefix, dicSubjectCodes(varPrefix)
      rsSubjects.AddNew
      rsSubjects![Prefix] = CStr(varPrefix)
      rsSubjects![Max_SubjectCode] = CStr(dicSubjectCodes(varPrefix))
      rsSubjects.Update
   Next

   rsSubjects.Close
   
   subSubjectCode_PerPrefix_temp.Form.Requery
End Sub


Private Sub SetSuggestedNames(Optional OnlySession As Boolean = False)
'   Dim strSQL As String
'   Dim which As Integer
'   Dim strPrefix As String, strPrefix_Selected As String
'   Dim txt As TextBox
'   Dim CodeNumber_PerSubjectType As Boolean
'   Dim MaxUsedCodeNumber As Integer
   
   'I have changed my philosophy.  In the past this code would look at existing Subject codes, and suggest a new name based on incrementing above the max used code.
   'For example, if the max used code was something like "WP023", it would suggest "WP024".
   'This was nice, but too cumbersome for general use... was pretty hard-coded for the first project where we used 'CW' and 'WP' as prefixes.
   
   'So, don't do that any more.
   
'
'   CodeNumber_PerSubjectType = CBool(GetSettingValue("SubjectNumbering_PerSubjectType", ValueIfNotFound:="false"))
'
'
'   strPrefix_Selected = Nz(DLookup("Prefix", "SubjectType", "SubjectTypeID=" & Nz(cboSubjectType.value, 0)), "")
'   If Nz(DLookup("Subject_Prefix", "Project", "ProjectID=" & Nz(cboProject.value, 0)), "") <> "" Then
'      strPrefix_Selected = Nz(DLookup("Subject_Prefix", "Project", "ProjectID=" & Nz(cboProject.value, 0)), "")
'   End If
'
'   For which = 1 To 3
'      Select Case which
'         Case 1
'            strPrefix = "CW"
'            Set txt = Me.txtMaxSessionCode_CW
'         Case 2
'            strPrefix = "WP"
'            Set txt = Me.txtMaxSessionCode_WP
'         Case 3
'            strPrefix = strPrefix_Selected
'            Set txt = Nothing
'      End Select
'      strSQL = "SELECT SubjectIdentifier FROM Subject Where SubjectIdentifier  Like """ & strPrefix & "*"" ORDER BY SubjectIdentifier DESC"
'      Set rs = CurrentDb.OpenRecordset(strSQL)
'      'rs.Open strSQL, CurrentProject.Connection, adOpenStatic, adLockReadOnly
'      If Not (txt Is Nothing) Then
'         If rs.EOF Then
'            txt = ""
'         Else
'            txt = rs![SubjectIdentifier]
'         End If
'      End If
'
'      If (Not CodeNumber_PerSubjectType) Or (strPrefix = strPrefix_Selected) Then
'         'get the code number
'         Dim thisvalue As Integer
'         If rs.EOF Then
'            thisvalue = 0
'         Else
'            On Error Resume Next
'            thisvalue = CInt(Mid(rs![SubjectIdentifier], Len(strPrefix) + 1))
'            On Error GoTo 0
'         End If
'         If thisvalue > MaxUsedCodeNumber Then
'            MaxUsedCodeNumber = thisvalue
'         End If
'      End If
'      rs.Close
'   Next



   'Instead, look at the path of the incoming data; if it includes a code with a prefix that is recognized for the selected project, suggest that code.
   'If not, don't suggest anything.
   
   
   Dim ProjectID_Current As Long, strPrefix As String
   Dim strNewProposedCode As String
   Dim strPrefixes As String
   
   If txtRawDataFolder <> "" Then
      ProjectID_Current = Nz(cboProject.value, -1)
      
      If ProjectID_Current > 0 Then
         strPrefix = Nz(DLookup("Subject_Prefix", "Project", "ProjectID=" & ProjectID_Current), "")
         If strPrefix <> "" Then strPrefixes = strPrefix
         
         Dim rs As New ADODB.Recordset
         rs.Open "SELECT Prefix FROM SubjectType WHERE Prefix<>'' AND ProjectID_Specific=" & ProjectID_Current, CurrentProject.Connection, adOpenStatic, adLockReadOnly
         Do Until rs.EOF
            strPrefixes = strPrefixes & IIf(strPrefixes <> "", "|", "") & rs![Prefix]
            rs.MoveNext
         Loop
      End If
      
      If strPrefixes = "" Then
         strPrefixes = "[A-Z]+" 'if no prefixes defined, look for any number of alphabetic chars
      End If
   
      'look in the raw data path for the code
      strNewProposedCode = modUtility.RegEx_ExtractSubstring(txtRawDataFolder, "\\((" & strPrefixes & ")\d+)\\?", True)
   End If
   
   
   If (strNewProposedCode <> "") Then
      If (Not OnlySession) Then
         cboSubjectCode.value = strNewProposedCode
      End If
   
      'if the suggested session name already exists, append a suffix
      Dim CountAlreadyPresentLikeThis  As Integer
      CountAlreadyPresentLikeThis = DCount("SessionID", "Session", "SessionCode Like """ & strNewProposedCode & "*""")
      If CountAlreadyPresentLikeThis > 0 Then
         txtSessionIdentifier.value = strNewProposedCode & "_" & Format(CountAlreadyPresentLikeThis + 1, "00")
      Else
         txtSessionIdentifier.value = strNewProposedCode
      End If
   End If
   SetSessionControls

   
End Sub

Private Sub SetDefaultSessionFolder()
   txtSessionFolder = SessionFolder_Default(cboProject.value, Nz(txtSessionIdentifier, ""))
   
End Sub
Private Sub SetSessionControls()
   txtSessionFolder.Enabled = (fraSessionInfo.value = 2)
   butSessionFolder_Select.Enabled = (fraSessionInfo.value = 2)
   If (fraSessionInfo.value = 1) Then
      SetDefaultSessionFolder
   End If
      
End Sub

Private Sub fraSessionInfo_AfterUpdate()
   SetSessionControls
End Sub


Private Sub txtRawDataFolder_Change()
   SetSuggestedNames
End Sub

Private Sub txtSessionIdentifier_Change()
   SetSessionControls
End Sub

----------- end of component
Component: Form_Data Output Configuration; Document Module
Option Compare Database
Option Explicit

Private Sub cmdASL_XTab_Click()
   DoCmd.OpenQuery "Datum_summary_ASL_CBF_xtab", acViewNormal
End Sub
----------- end of component
Component: Form_dsSession; Document Module
Option Compare Database
Option Explicit

Public Event CurrentChanged(PrimaryKey_Current As Long)
Private WithEvents m_Extensions As clsAccessFormExtensions

Public Property Get Extensions() As clsAccessFormExtensions
   Set Extensions = m_Extensions
End Property


Private Sub chkAllowDeletions_Click()
   SetAllowDeletions
End Sub

Private Sub cmdDataSheetView_Click()
   DoCmd.OpenForm Me.Name, acFormDS, , , , , acFormDS
 
End Sub

Private Sub Form_Delete(Cancel As Integer)
   If MsgBox("Do you really want to delete this Session?" & vbCrLf & vbCrLf & _
            "All associated data will also be deleted.", vbOKCancel Or vbExclamation Or vbDefaultButton2, "Confirm Deletion") = vbCancel Then
      Cancel = 1
   End If
End Sub

Private Sub SetAllowDeletions()
   Me.AllowDeletions = CBool(chkAllowDeletions.value)
   cmdDeleteSession.Enabled = Me.AllowDeletions
End Sub
Private Sub SetColumns()
   If Me.CurrentView = AcFormView.acFormDS Then
      Me.ProcessThisSession.ColumnOrder = 2
   End If
End Sub

Private Sub HideWhenSubform()
   Dim IsSubform As Boolean
   On Error Resume Next
   IsSubform = Not (Me.Parent Is Nothing)
   On Error GoTo 0
   If IsSubform Then
      Me.FormHeader.Visible = False
      Me.FormFooter.Visible = False
      cmdDeleteSession.Visible = False
   End If
End Sub

Private Sub Form_ViewChange(ByVal Reason As Long)
   SetColumns
End Sub

Private Sub m_Extensions_CurrentChanged(PrimaryKey_Current As Long)
   RaiseEvent CurrentChanged(PrimaryKey_Current)
End Sub

Private Sub Form_Load()
   Set m_Extensions = New clsAccessFormExtensions
   Set Me.Extensions.Form = Me
   Me.Extensions.PrimaryKey_FieldName = "SessionID"  'set the PK of your form's recordset
   
   HideWhenSubform
   
   SetColumns
   SetAllowDeletions
End Sub

Private Sub Form_Current()
   UpdateControls
   If Not Me.Extensions Is Nothing Then Me.Extensions.Form_Current
End Sub


Private Sub cmdNewSubject_Click()
   Dim frmNewSubject As Form_Subject_New
   
   DoCmd.OpenForm "Subject_New", acNormal, , , acFormAdd, acDialog
   
   Set frmNewSubject = Forms!Subject_New
   If frmNewSubject.DialogResult = vbOK Then
      If frmNewSubject.SubjectID_Added > 0 Then
         Me.SubjectID.Requery
         Me.SubjectID.value = frmNewSubject.SubjectID_Added
      End If
   End If
   
   DoCmd.Close acForm, "Subject_New"
   
End Sub

Private Sub UpdateControls()
   cmdNewSubject.Visible = (Me.NewRecord)
End Sub


----------- end of component
Component: modDTI_Processing; Standard module
Option Compare Database
Option Explicit

Const ModuleName As String = "modDTI_Processing"


'return value indicates if processing completed.  Return value is False if there was some error in processing, or if we hit a Pause Processing step
Public Function DoDTI_Processing(SessionID As Long, Optional ShowLogWindows As Boolean = False, _
                                 Optional LogFilename As String = "") As eProcessingStatus
                                 
   Const MethodName As String = "DoDTI_Processing"
   Const StudyTypeName As String = "DTI"
   Const ThisProcessingStepGroupName As String = "DTI processing"
   
   Dim return_value As eProcessingStatus
   Dim strBrainsuiteProgramFolder As String
   Dim DidSomeProcessing As Boolean
   Dim oSession As New clsSession
   Dim psi As New clsProcessingStepInfo
   Dim rsProcessingSteps As New ADODB.Recordset
   Dim strSQL As String
   Dim strmLogFile As Scripting.TextStream
   
   return_value = Unknown
   
   On Error GoTo DoDTI_Processing_Err
   
   If LogFilename <> "" Then
      Dim fso As New FileSystemObject
      Set strmLogFile = fso.OpenTextFile(LogFilename, ForAppending, True)
   End If
   
   oSession.SessionID = SessionID
   
   strBrainsuiteProgramFolder = GetSettingValue(SettingName:="Brainsuite program folder", SessionID:=SessionID)
   
   psi.SessionID = oSession.SessionID
   psi.ProcessingStepGroupName = ThisProcessingStepGroupName
   
   strSQL = "SELECT * FROM ProcessingStep WHERE EnableStep=True AND ProcessingStepGroupID=" & psi.ProcessingStepGroupID & " ORDER BY ProcessingOrder ASC"
   rsProcessingSteps.Open strSQL, CurrentProject.Connection, adOpenStatic, adLockReadOnly
   
   
   'If it doesn't exist, create a Study record
   
   If oSession.StudyID_GetSpecific(StudyTypeName) <= 0 Then
      Dim intStudyTypeID As Integer
      intStudyTypeID = CInt(DLookup("StudyTypeID", "StudyType", "StudyType='" & StudyTypeName & "'"))
      Dim rs As New ADODB.Recordset
      rs.Open "SELECT * FROM Study WHERE SessionID=" & oSession.SessionID & " AND StudyTypeID=" & intStudyTypeID, CurrentProject.Connection, adOpenStatic, adLockOptimistic
      If rs.EOF Then 'if failed to find a matching record, add one
         rs.AddNew
         rs![StudyTypeID] = intStudyTypeID
         rs![SessionID] = oSession.SessionID
         rs![Iteration] = Null
         rs![filepath] = oSession.SessionPath_DTI
         rs.Update
      End If
      rs.Close
   End If
   
   Dim strMessage As String
   
   Do Until rsProcessingSteps.EOF
      psi.ProcessingStepName = rsProcessingSteps![ProcessingStep]
      If Not psi.GetStatus Then
         If Not psi.DependenciesMet Then
            return_value = UnmetDependency
            If Not (strmLogFile Is Nothing) Then
               strmLogFile.WriteLine "Interrupting processing of SessionID=" & SessionID & ", ProcessingStep='" & rsProcessingSteps![ProcessingStep] & "'; this step requires previous completion of step '" & psi.ProcessingStepName_Dependency & "'."
            End If
            Exit Do  'assume that if we have an unmet dependency, we cannot proceed to the next step
         Else
            If Not (strmLogFile Is Nothing) Then
               strmLogFile.WriteLine "Beginning processing for SessionID=" & SessionID & "; ProcessingStep='" & rsProcessingSteps![ProcessingStep] & "'"
            End If
            
            DidSomeProcessing = True
            
            Select Case rsProcessingSteps![ProcessingStep]
               Case "Copy required files"
                  Do_CopyRequiredFiles oSession, psi, strmLogFile, ShowLogWindows
                  
               Case "Run BDP"
                  Do_RunBDP oSession, psi, strmLogFile, ShowLogWindows
               
               
               Case "Compute Tractography"
                  Do_ComputeTractography oSession, psi, strmLogFile, ShowLogWindows
               
               Case Else
                  return_value = False
                  Err.Raise vbObjectError + 512, MethodName, _
                  "Unrecognized value for ProcessingStep: '" & rsProcessingSteps![ProcessingStep] & _
                  "' (ProcessingStepID=" & rsProcessingSteps![ProcessingStepID] & ")"
            End Select
            
            If Not (strmLogFile Is Nothing) Then
               strmLogFile.WriteLine "Completed processing for SessionID=" & SessionID & "; Processing Group=" & psi.ProcessingStepGroupName & "; ProcessingStep='" & rsProcessingSteps![ProcessingStep] & "'"
            End If
            
            If Not psi.ProcessingComplete Then  'if the step we just tried to execute did not complete, exit the loop
               return_value = ProcessingError
               Exit Do
            End If
         End If
      End If
      rsProcessingSteps.MoveNext
   Loop
   
   If return_value = Unknown Then
      return_value = IIf(DidSomeProcessing, eProcessingStatus.Completed, eProcessingStatus.NothingToDo)
   End If
   
   rsProcessingSteps.Close

DoDTI_Processing_Exit:
   If Not (strmLogFile Is Nothing) Then
      strmLogFile.Close
   End If
   DoDTI_Processing = return_value
Exit Function

DoDTI_Processing_Err:
   If Not (strmLogFile Is Nothing) Then
      strmLogFile.Close
   End If
   Dim strErrorMessage As String
   strErrorMessage = "Processing error: " & Err.Description
   If Not (rsProcessingSteps Is Nothing) Then
      If rsProcessingSteps.State = 1 Then
         If Not (rsProcessingSteps.EOF Or rsProcessingSteps.BOF) Then
            strErrorMessage = "Error while processing for ProcessingStep '" & rsProcessingSteps![ProcessingStep] & _
                  "' (ProcessingStepID=" & rsProcessingSteps![ProcessingStepID] & ")" & vbCrLf & _
                  strErrorMessage
         End If
         rsProcessingSteps.Close
      End If
   End If
   
   Err.Raise vbObjectError + 512, "DoDTI_Processing", strErrorMessage
    
End Function

Private Sub Do_CopyRequiredFiles(oSession As clsSession, psi As clsProcessingStepInfo, strmLogFile As Scripting.TextStream, ShowLogWindows As Boolean)
   Const MethodName As String = "Do_CopyRequiredFiles"
   psi.StartProcessing_Now

   Dim strDTIImagePattern As String
   strDTIImagePattern = GetSettingValue(SettingName:="DTI Scan Filename pattern", SessionID:=oSession.SessionID)
   Dim regex As New VBScript_RegExp_55.RegExp
   regex.Pattern = strDTIImagePattern
   
   Dim fil As Scripting.File
   Dim fso As New Scripting.FileSystemObject
   Dim DTIImages_Count As Integer
   Dim filDTIImage As Scripting.File
   Dim fiImageFilename As New clsFilename
   Dim bsc As New clsBrainSuiteCommander
   
   'first confirm there is only one DTI image
   DTIImages_Count = 0
   For Each fil In fso.GetFolder(oSession.SessionPath_Nii).Files
      If regex.test(fil.Name) Then
         DTIImages_Count = DTIImages_Count + 1
         Set filDTIImage = fil
      End If
   Next
   
   If DTIImages_Count <> 1 Then
      Err.Raise vbObjectError + 512, MethodName, "In folder " & fso.GetFolder(oSession.SessionPath_Nii) & " expected to find one DTI Nii image, but found " & DTIImages_Count & " image files."
   Else
   '   strImageFilename_Rename = regex.Replace(filDTIImage.Name, strDTIImageRenamePattern)
      fiImageFilename.Filename = filDTIImage.Path
      fiImageFilename.FinalSlashOnPath = False
   End If

   'also confirm that we have the required BFC file
   If Not psi.DependenciesMet Then
      Err.Raise vbObjectError + 512, ModuleName & "." & MethodName, "Failed to find a completed pre-requisite processing step '" & psi.ProcessingStepName_Dependency & "'"
   End If


   psi.ResultValue = fiImageFilename.Filename
  
   'copy the DTI imagem, bvec and bval files, and also the BFC image.
   Dim i As Integer
   Dim CountFilesCopied As Integer, DoFileCopy As Boolean
   Dim output_type As String
   For i = 1 To 4
      Dim strExtension As String
      Dim strSourceFilePathName As String, strDestinationFilePathName As String
      DoFileCopy = True
      
      Select Case i
         Case 1
            strExtension = ".nii"
            output_type = "DTI Image"
            
         Case 2
            strExtension = ".bvec"
            output_type = "Bvec"
         
         Case 3
            strExtension = ".bval"
            output_type = "Bval"
         
         Case 4
            strExtension = ""  'not used
            DoFileCopy = False  'We don't actually have to copy the file... it is already where it needs to be.  We will still make a
                           'output record
            output_type = "bfc"
            Dim fi As New clsFilename, strBFC_Filename As String
            strBFC_Filename = bsc.GetStepOutput(oSession, "Non-uniformity correction", "Cortical surface extraction", "bfc").OutputFilename
            fi.Filename = strBFC_Filename
            If InStr(strBFC_Filename, "\") = 0 Then  'if the stored filename did not contain a path, set the path to the SessionPath_Brainsuite
               fi.Path = oSession.SessionPath_Brainsuite
            End If
            strDestinationFilePathName = fi.Filename
      End Select
      
      If strExtension <> "" Then
         strSourceFilePathName = fiImageFilename.Path & "\" & fiImageFilename.Corename & strExtension
         strDestinationFilePathName = oSession.SessionPath_Brainsuite & "\" & fiImageFilename.Corename & strExtension
      End If
      
      If DoFileCopy Then
         fso.CopyFile strSourceFilePathName, strDestinationFilePathName
         CountFilesCopied = CountFilesCopied + 1
      End If
      
      psi.StepOutput_Add output_type, strDestinationFilePathName
   Next

   psi.ResultComment = "Copied " & CountFilesCopied & " files to """ & oSession.SessionPath_Brainsuite
   psi.Save_CompleteNow
   If Not (strmLogFile Is Nothing) Then strmLogFile.WriteLine psi.ResultComment
   
End Sub


Private Sub Do_RunBDP(oSession As clsSession, psi As clsProcessingStepInfo, strmLogFile As Scripting.TextStream, ShowLogWindows As Boolean)
'  Command-Line Usage
'  bfc: BDP is a command-line tool that takes diffusion images and a bias-field corrected MPRAGE image (fileprefix.bfc.nii.gz file generated by BrainSuite) as input, performs distortion correction and co-registration, and writes out the estimated diffusion tensors and ODFs and various other output files.
'  usage: bdp.exe <BFC File> [Optional Flags] --nii <4D DWI NIfTI> -g <Gradient File> -b <B-Value File>
'  example: "c:\Program Files\BrainSuite16a1\bdp\bdp.exe" s_mprage.bfc.nii.gz --FRT --FRACT --nii DTI_11.nii -g DTI_11.bvec -b DTI_11.bval
'
' For complete command description, see  http://brainsuite.org/processing/diffusion/pipeline/   and    http://brainsuite.org/processing/diffusion/flags/

   Dim MethodName As String
   Dim CommandDescription As String
   Dim ExecutableName As String, CommandOptions As String, ExecutableSubfolder As String
   Dim TakeInputFromStepName As String, OutputFilename_Suffix As String, TakeInputFromStep_OutputType As String
   Dim WorkingDir As String
   Dim OutputFile_ExtractFromLog_RegEx As String
   Dim dicReplaceableParams As New Scripting.Dictionary
   Dim ExpectedOutputFilename As String, OutputType As String
   Dim m_BSC As New clsBrainSuiteCommander
   
   MethodName = "Do_RunBDP"
   CommandDescription = "Compute DTI FRACT"
   ExecutableName = "bdp.exe"
   ExecutableSubfolder = "bdp"
   CommandOptions = "{input_filename} --output-subdir DTI --threads=6 --FRACT --nii {DTI_file} -g {BVec_file} -b {BVal_file}"
   
   Dim psiCopyFiles As New clsProcessingStepInfo

   With psiCopyFiles
      If Not .LoadSessionProcessingStep(oSession.SessionID, psi.ProcessingStepGroupName, "Copy required files") Then
         Err.Raise vbObjectError + 512, ModuleName & "." & MethodName, "Failed to find a completed processing step: " & .ToString_GroupAndStep()
      End If
   End With
   
   TakeInputFromStepName = "Copy required files"  'the main input file is the bias-field corrected image
   TakeInputFromStep_OutputType = "bfc"
   
   Dim fi As New clsFilename
   
   fi.Filename = psiCopyFiles.StepOutout_GetSpecific("DTI Image").OutputFilename
   dicReplaceableParams.Add "{DTI_file}", fi.FileTitle
   
   fi.Filename = psiCopyFiles.StepOutout_GetSpecific("Bvec").OutputFilename
   dicReplaceableParams.Add "{BVec_file}", fi.FileTitle
   
   fi.Filename = psiCopyFiles.StepOutout_GetSpecific("Bval").OutputFilename
   dicReplaceableParams.Add "{BVal_file}", fi.FileTitle
   
   
   'determine what we expect the output file to be ... we will look for the "odf" file in the FRACT subfolder.
   fi.Filename = psiCopyFiles.StepOutout_GetSpecific("bfc").OutputFilename
   Dim nii As New clsNiiFilename
   nii.Filename_Original = fi.FileTitle
   nii.FileTitle_SuffixNew = ".bfc.dwi.RAS.correct.SH.FRACT.T1_coord"
   nii.Extension = ".odf"
   ExpectedOutputFilename = oSession.SessionPath_DTI & "\FRACT\" & nii.Filename_New
   
   OutputFile_ExtractFromLog_RegEx = "^(Estimated ODFs written to disk).$"
   OutputFilename_Suffix = ""
   OutputType = "odf"
   
   Call m_BSC.Do_BrainsuiteCommandlineProcess(oSession, psi, strmLogFile, ShowLogWindows, _
                                    MethodName, CommandDescription, ExecutableName, CommandOptions, _
                                    TakeInputFromStepName, TakeInputFromStep_OutputType, OutputFilename_Suffix, OutputFile_ExtractFromLog_RegEx, _
                                    dicReplaceableParams, _
                                    OutputFile_Extracted_Expected:=ExpectedOutputFilename, _
                                    OutputFilename_AssumeExpected_IfMatch:=True, _
                                    OutputType:=OutputType, ExecutableSubfolder:=ExecutableSubfolder)



   
   'also check the log file to see if a BST file was produced... should be
   Dim bst_filename As String
   bst_filename = modUtility.RegEx_ExtractSubstring(modUtility.TextFile_ReadAll(m_BSC.LogFile_LastCommand), _
                        "^BDP saved following BST files:$\s*(.*\.bst)$")
   If bst_filename <> "" Then
      psi.StepOutput_Add "bst", oSession.SessionPath_Brainsuite & "\" & bst_filename
   End If

   psi.Save_CompleteNow
   
   If Not (strmLogFile Is Nothing) Then strmLogFile.WriteLine Nz(psi.ResultComment, "")

   
End Sub


'
Private Sub Do_ComputeTractography(oSession As clsSession, psi As clsProcessingStepInfo, strmLogFile As Scripting.TextStream, ShowLogWindows As Boolean)
'For SVReg, it seems to be necessary to GZip a few files.

   Dim MethodName As String
   Dim CommandDescription As String
   Dim ExecutableName As String, CommandOptions As String
   Dim TakeInputFromStepName As String, TakeInputFromOutputType As String
   Dim SourceFilename As String
   Dim fso As New FileSystemObject
   Dim AllSuccessful As Boolean
   
   MethodName = "Do_ComputeTractography"
   CommandDescription = "Compute Tractography"
   TakeInputFromStepName = "Run BDP"
   TakeInputFromOutputType = "bst"
   
   'created a command line such as this:
   ' "C:\Program Files (x86)\AutoIt3\Beta\AutoIt3.exe" "D:\MRI Processing\MRI Processing Software\Tools\ComputeTractography.au3" "c:\Program Files\BrainSuite18a\bin\BrainSuite18a.exe"   "D:\MRI Processing\MRI Data\WPAFB HyperO2\CW002\Brainsuite" "101_b_mprage_2.FRACT.T1_coord.bst"

   Dim strCommandLine As String
   Dim strTrackFilterLenthg_mm As String
   Dim ExpectedOutputFilename As String
   strCommandLine = "cmd /c  ''{AutoItPath}' '{AutoItScript}' '{BrainSuiteExePath}' '{WorkingDir}' '{BST_File_RelPath}' {FilteringLength_mm}'"
   psi.StartProcessing_Now
   

   Dim psiInputStep As clsProcessingStepInfo
   Set psiInputStep = New clsProcessingStepInfo
   If Not psiInputStep.LoadSessionProcessingStep(oSession.SessionID, psi.ProcessingStepGroupName, TakeInputFromStepName) Then
      Err.Raise vbObjectError + 512, ModuleName & "." & MethodName, "Failed to find a completed processing step: " & TakeInputFromStepName
   End If
   
   Dim step_output As clsProcessingStepOuptut
   Set step_output = psiInputStep.StepOutout_GetSpecific(TakeInputFromOutputType)
   Dim fi As New clsFilename
   
   If step_output Is Nothing Then
      Err.Raise vbObjectError + 512, ModuleName & "." & MethodName, "For step of type '" & psiInputStep.ToString_GroupAndStep() & "', failed to find output file of type '" & TakeInputFromOutputType & "'"
   Else
      strCommandLine = Replace(strCommandLine, "'", """")
      strCommandLine = Replace(strCommandLine, "{AutoItPath}", GetSettingValue("AutoIt executable path", ErrorIfNotFound:=True))
      strCommandLine = Replace(strCommandLine, "{AutoItScript}", GetSettingValue("ComputeTractography script", psi.ProcessingStepID, ErrorIfNotFound:=True))
      strCommandLine = Replace(strCommandLine, "{BrainSuiteExePath}", GetSettingValue("Brainsuite GUI filename", ErrorIfNotFound:=True))
      strCommandLine = Replace(strCommandLine, "{WorkingDir}", oSession.SessionPath_DTI)
      strCommandLine = Replace(strCommandLine, "{BST_File_RelPath}", step_output.OutputFilename)
      strTrackFilterLenthg_mm = GetSettingValue("FilteringLength_mm", psi.ProcessingStepID, ErrorIfNotFound:=True)
      strCommandLine = Replace(strCommandLine, "{FilteringLength_mm}", strTrackFilterLenthg_mm)

      modMRI_Common.RunCommandLine strCommandLine, WorkingDirectory:=oSession.SessionPath_Brainsuite
          
      ExpectedOutputFilename = oSession.SessionPath_DTI & "\fibertracks_filtered_" & strTrackFilterLenthg_mm & "mm.dft"
      If fso.FileExists(ExpectedOutputFilename) Then
         psi.StepOutput_Add "tracks", ExpectedOutputFilename, Comment:="fiber track file produced, with length filter=" & strTrackFilterLenthg_mm & " mm"
         psi.ResultComment = "Created tractography file"
         AllSuccessful = True
      Else
         psi.ResultComment = "Failed to produce tractography file; commandline attempted was: " & strCommandLine
         AllSuccessful = False
      End If
    End If

   
   If AllSuccessful Then
      psi.Save_CompleteNow
   Else
      psi.Save_NotCompleteNow
   End If
End Sub
----------- end of component
Component: Form_Import Brainsuite Results; Document Module
Option Compare Database
Option Explicit

Private Sub cmdImportBS_Results_Click()
   On Error GoTo cmdImportBS_Results_Click_Err
   
   Dim fso As New Scripting.FileSystemObject
   Dim fil As Scripting.File, fld As Scripting.Folder
   Set fld = fso.GetFolder(txtBrainsuiteResultsFolder)
   
   Screen.MousePointer = 11  'Hourglass
   
   
   Dim session As New clsSession
   session.SessionID = cboSession.value
   
   modCorticalSurfaceExtraction.CreateStudy session
   
   'copy all files
   fld.Copy session.SessionPath_Brainsuite
   
   Set fld = fso.GetFolder(session.SessionPath_Brainsuite)

   'now go find the important files
   Dim Filename As String, file_searchpattern As String
   Dim psi As New clsProcessingStepInfo
   psi.SessionID = session.SessionID
   psi.ProcessingStepGroupName = "Cortical surface extraction"
   
   Dim arrPSN As Variant, arrFSP As Variant, arrOT As Variant
   arrPSN = Array("Skull Stripping Mask (BSE)", "Create Brain mask", "Non-uniformity correction", "Register and label brain", "Extract SVREG ROI Data")
   arrOT = Array("mask", "bfc", "label", "stats")
   arrFSP = Array("*.bse.nii*", "*.bfc.nii*", "*.svreg.label.nii*", "*.roiwise.stats.txt")
   
   Dim i As Integer
   Dim strmLog As Scripting.TextStream
   
   For i = 0 To UBound(arrPSN)
      With psi
         .ProcessingStepName = arrPSN(i)
         .GetStatus
         
         If .ProcessingStepName = "Extract SVREG ROI Data" Then
            'handle this step specially.  Just call the code that normally does the file processing
            .Save_NotCompleteNow
            modCorticalSurfaceExtraction.Do_ExtractSVREG_ROI_Data session, psi, strmLog, False
         Else
            file_searchpattern = arrFSP(i)
            Filename = Dir(session.SessionPath_Brainsuite & "\" & file_searchpattern)
            If Filename = "" Then
               Err.Raise vbObjectError + 512, "Import Brainsuite Results", "For Processing Step '" & .ProcessingStepName & "', failed to find file matching pattern: " & file_searchpattern
            Else
            '   .StepOutput_Clear
               .StepOutput_Add CStr(arrOT(i)), session.SessionPath_Brainsuite & "\" & Filename
            End If
            .Save_CompleteNow
         End If
         
      End With
   Next
    
   'mark all steps as complete
   Dim strSQL As String
   Dim rsProcessingSteps As New ADODB.Recordset
   strSQL = "SELECT * FROM ProcessingStep WHERE ProcessingStepGroupID=" & psi.ProcessingStepGroupID & " ORDER BY ProcessingOrder ASC"
   rsProcessingSteps.Open strSQL, CurrentProject.Connection, adOpenStatic, adLockReadOnly
     
   Do Until rsProcessingSteps.EOF
      psi.ProcessingStepName = rsProcessingSteps![ProcessingStep]
      If Not psi.GetStatus Then
         psi.ResultComment = "Virtual completion set by form 'Import Brainsuite Results'"
         psi.Save_CompleteNow
      End If
      rsProcessingSteps.MoveNext
   Loop
   rsProcessingSteps.Close

   
   cboSession.SetFocus
   MsgBox "Import of Brainsuite results is complete for Session '" & cboSession.Text & "' (Session ID=" & cboSession.value & ")"

cmdImportBS_Results_Click_Exit:
   Screen.MousePointer = 0 'default
Exit Sub

cmdImportBS_Results_Click_Err:
   MsgBox "Error during import process: " & Err.Description, vbCritical, "Import Error"
   Resume cmdImportBS_Results_Click_Exit
End Sub


Private Sub cmdSelectBS_Folder_Click()

   Dim dlg As FileDialog
   Set dlg = Application.FileDialog(msoFileDialogFolderPicker)
   With dlg
      If .Show Then
         txtBrainsuiteResultsFolder = .SelectedItems(1)
      End If
   End With
End Sub
----------- end of component
Component: clsBrainSuiteCommander; Class module
Option Compare Database
Option Explicit

Const ModuleName As String = "clsBrainSuiteCommander"

Private m_LogFile_LastCommand As String

Public Property Get LogFile_LastCommand() As String
   LogFile_LastCommand = m_LogFile_LastCommand
End Property

Public Sub Do_BrainsuiteCommandlineProcess(oSession As clsSession, psi As clsProcessingStepInfo, strmLogFile As Scripting.TextStream, _
                                             ShowLogWindows As Boolean, _
                                           MethodName As String, CommandDescription As String, _
                                           ExecutableName As String, CommandOptions As String, _
                                           TakeInputFromStepName As String, TakeInputFromStep_OutputType As String, _
                                           OutputFilename_Suffix As String, _
                                           OutputFile_ExtractFromLog_RegEx As String, _
                                           dicReplaceableParams As Scripting.Dictionary, _
                                           Optional OutputFile_Extracted_Expected As String = "{output_filename}", _
                                           Optional OutputFilename_Extension As String = "", _
                                           Optional OutputFilename_AssumeExpected_IfMatch As Boolean = False, _
                                           Optional OutputType As String = "", _
                                           Optional ExecutableSubfolder As String = "bin", _
                                           Optional WorkingDirectory As String = "")
                                           
   
   Dim strLogFilename As String
   Dim strCommandLine As String
   Dim strOutput_Filename() As String
   Dim suffixes() As String, suffix_idx As Integer
   Dim strOutput_Filename_Expected As String
 '  Dim psiInputStep As clsProcessingStepInfo
   Dim psoInput As clsProcessingStepOuptut

   Dim intInputStep_ResultValueIndex As Integer
   Dim niif As clsNiiFilename
'   Dim ProduceGZippedOutput As Boolean
'
'   ProduceGZippedOutput = CBool(GetSettingValue("Brainsuite Produce Gzipped Files", ValueIfNotFound:="true"))

   Dim Commandline_base As String
   Commandline_base = "cmd /c ''{BrainsuiteFolder}\{ExecutableSubfolder}\{ExecutableName}' {CommandOptions} >> '{logfilename}''"

   psi.StartProcessing_Now
   
   strCommandLine = Commandline_base
   strCommandLine = Replace(strCommandLine, "{ExecutableName}", ExecutableName)
   strCommandLine = Replace(strCommandLine, "{ExecutableSubfolder}", ExecutableSubfolder)
   strCommandLine = Replace(strCommandLine, "{CommandOptions}", CommandOptions)
   
   If WorkingDirectory = "" Then WorkingDirectory = oSession.SessionPath_Brainsuite
   
   strOutput_Filename_Expected = OutputFile_Extracted_Expected
  
   strLogFilename = Replace(CommandDescription, " ", "") & "_log.txt"
   
   If TakeInputFromStepName <> "" Then
      Set psoInput = Me.GetStepOutput(oSession, TakeInputFromStepName, psi.ProcessingStepGroupName, TakeInputFromStep_OutputType)
      If psoInput Is Nothing Then
         Err.Raise vbObjectError + 512, ModuleName & "." & MethodName, "Failed to find a processing step output with ProcessingStepName='" & TakeInputFromStepName & _
                        "' and OutputType='" & TakeInputFromStep_OutputType & "'."
      End If
      
      Set niif = New clsNiiFilename
      niif.Filename_Original = psoInput.OutputFilename
      niif.IncludeOriginalSuffix = False
      If OutputFilename_Extension <> "" Then niif.Extension = OutputFilename_Extension
      
      If OutputFilename_Suffix <> "" Then
         suffixes = Split(OutputFilename_Suffix, "|")
         For suffix_idx = 0 To UBound(suffixes)
            ReDim Preserve strOutput_Filename(suffix_idx)
            niif.FileTitle_SuffixNew = suffixes(suffix_idx)
            strOutput_Filename(suffix_idx) = niif.Filename_New
         Next
      End If
   End If
   
   'replace the replaceable params, in command line and also in strOutput_Filename_Expected
   Dim strTarget As String, loopidx As Integer
   For loopidx = 1 To 2
      Select Case loopidx
         Case 1: strTarget = strCommandLine
         Case 2: strTarget = strOutput_Filename_Expected
      End Select
      
      strTarget = Replace(strTarget, "{BrainsuiteFolder}", GetSettingValue(SettingName:="Brainsuite program folder", SessionID:=oSession.SessionID, ErrorIfNotFound:=True))
      If Not (psoInput Is Nothing) Then
         strTarget = Replace(strTarget, "{input_filename}", niif.Filename_Original)
         If OutputFilename_Suffix <> "" Then
            For suffix_idx = 0 To UBound(suffixes)
               If suffix_idx = 0 Then 'do a replace attempt without iteration index
                  strTarget = Replace(strTarget, "{output_filename}", strOutput_Filename(suffix_idx))
               End If
               'also do an attempt with the iteration index
               strTarget = Replace(strTarget, "{output_filename" & CStr(suffix_idx + 1) & "}", strOutput_Filename(suffix_idx))
            Next
         End If
      End If
      strTarget = Replace(strTarget, "{logfilename}", strLogFilename)
      
      Dim i As Integer
      For i = 0 To dicReplaceableParams.Count - 1
         strTarget = Replace(strTarget, CStr(dicReplaceableParams.Keys(i)), CStr(dicReplaceableParams.items(i)))
      Next
      
      strTarget = Replace(strTarget, "'", """")
      
      Select Case loopidx
         Case 1: strCommandLine = strTarget
         Case 2: strOutput_Filename_Expected = strTarget
      End Select
   Next

   m_LogFile_LastCommand = WorkingDirectory & "\" & strLogFilename
   
   If RunCommandLine(strCommandLine, MethodName, WorkingDirectory, _
                     Me.LogFile_LastCommand, ShowLogWindows, _
                     strmLogFile, DisplayOutputToDebugWindow) = IWshRuntimeLibrary.WshFinished Then
      
      Dim strOutput_Filename_Produced As String
      If OutputFile_ExtractFromLog_RegEx <> "" Then
      
         strOutput_Filename_Produced = Trim(modUtility.RegEx_Concatenate(modUtility.TextFile_ReadAll(Me.LogFile_LastCommand), _
            OutputFile_ExtractFromLog_RegEx, SubMatchDelimiter:="|", Multiline:=True))
               
         If OutputFilename_AssumeExpected_IfMatch Then
            'this setting means that, as long as the RegEx actually matched something, set the value 'strOutput_Filename_Produced' to
            ' be the expected output filename.  This option is useful in situation in which the command output does not actually list the
            ' file produced; but the command output does contain some text that indicates the process completed normally, so we can
            ' assume that it produced the requested file.  For example, this is used for the Pial surface generation command 'pialmesh'
            If strOutput_Filename_Produced <> "" Then
               strOutput_Filename_Produced = strOutput_Filename_Expected
            End If
         End If
      End If
      
      psi.ResultComment = ""
      psi.ResultValue = strOutput_Filename_Produced
      If (strOutput_Filename_Produced = strOutput_Filename_Expected) Then
         
         'Save the output files into the ProcessingStepOutputs
         'This is a little sloppy, since I added it after I had already completed the code
         Dim strOutputFilenames() As String
         Dim strOutputTypes() As String
         strOutputFilenames = Split(strOutput_Filename_Produced, "|")
         Dim intCountOutputs As Integer
         intCountOutputs = UBound(strOutputFilenames) + 1
         
         If OutputType <> "" Then
            strOutputTypes = Split(OutputType, "|")
            ReDim Preserve strOutputTypes(intCountOutputs - 1)
         Else
            ReDim strOutputTypes(intCountOutputs - 1)
         End If
      
         For i = 0 To intCountOutputs - 1
            psi.StepOutput_Add IIf(strOutputTypes(i) = "", "file", strOutputTypes(i)), strOutputFilenames(i)
         Next
         
         psi.ProcessingComplete = True
      Else
         psi.ResultValue = strOutput_Filename_Produced
         psi.ProcessingComplete = False
         If (OutputFile_Extracted_Expected <> "") And (strOutput_Filename_Produced = "") Then
            psi.ResultComment = "WARNING: Failed to extract the name of the output file produced.  Please check the output log file: " & Me.LogFile_LastCommand
         Else
            psi.ResultComment = "WARNING: the name of the output file(s) produced does not match the name(s) that were specified"
         End If
      End If
      
      
      psi.ProcessingEndTime = Now
      psi.Save
   Else
      psi.ResultComment = "Command execution failed!  Please check log file: " & Me.LogFile_LastCommand
      psi.Save_NotCompleteNow
   End If
   
   
End Sub


Public Function GetStepOutput(oSession As clsSession, ProcessingStepName As String, Optional ProcessingStepGroupName As String = "", _
                        Optional OutputTypeName As String = "", Optional OutputTypeIteration As Integer = -1) As clsProcessingStepOuptut
   Const MethodName As String = "GetStepOutput"
   
   Dim psiSourceStep As New clsProcessingStepInfo
   If Not psiSourceStep.LoadSessionProcessingStep(oSession.SessionID, ProcessingStepGroupName, ProcessingStepName) Then
      Err.Raise vbObjectError + 512, ModuleName & "." & MethodName, "Failed to find a completed processing step: " & psiSourceStep.ToString_GroupAndStep()
   End If
      
   Set GetStepOutput = psiSourceStep.StepOutout_GetSpecific(OutputTypeName, OutputTypeIteration)
   
End Function


----------- end of component
Component: Form_UserListChoice; Document Module
Option Compare Database
Option Explicit

Private m_UserOK As Boolean, m_UserCancel As Boolean
Private m_ShowAsButtons  As Boolean
Private m_OptionChosen As Integer
Private m_AllowMultiSelect As Boolean

Private Const MaxButtons As Integer = 4

Public Property Let TitleText(s As String)
   lblTitle.Caption = s
End Property

Public Property Let AllowMultiSelect(b As Boolean)
   m_AllowMultiSelect = b
  ' lstItems.MultiSelect = IIf(b, 2, 0)   ' 2=Extended.  CAN ONLY SET IN DESIGN MODE!
   Me.lblMultiSelectPermitted.Visible = b
End Property



Public Property Let ShowAsButtons(b As Boolean)
   'if user sets this to true, then does not display a list box but instead a option group, with
   ' up to 4 buttons  (this could be expanded by creating them dynamically, but seems like a hassle.

   'Caller should set this property before setting the ListRowSource
   'In this case, caller MUST pass a value list to ListRowSource

   m_ShowAsButtons = b

   cmdCancel.SetFocus 'avoid problems when setting controls to not visisble

   fraOptionButtons.Visible = m_ShowAsButtons
   lstItems.Visible = Not m_ShowAsButtons
      

   'Also, removes the "OK" button ... but the m_UserOK is set when a user click a button
   Me.cmdOK.Visible = Not m_ShowAsButtons
End Property

Public Property Let ListRowSource(s As String)
   'should be a SQL statement or value list;
   'if starts with the word SELECT, or if it contains no semicolons, then assumes it is a table/query

   'By default, if a Table/Query, assumes that there are 2 columns, with the first one being a hidden key column
   'typically the bound column is Column 1

   If Not m_ShowAsButtons Then
      If (LCase(Left(Trim(s), 6)) = "select") Or (InStr(1, s, ";") = 0) Then
'#If DB_IsDAO Then
'         lstItems.RowSourceType = "Table/Query"
'#Else
'         lstItems.RowSourceType = "Table/View/StoredProc"
'#End If
         lstItems.RowSourceType = "Table/Query"
         lstItems.ColumnCount = 2
         lstItems.ColumnWidths = "0"
      Else
         lstItems.RowSourceType = "Value List"
         lstItems.ColumnCount = 1
         lstItems.ColumnWidths = ""
      End If
      
      lstItems.RowSource = s
      lstItems.Requery
   Else
      Dim items() As String
      Dim i As Integer
      Dim tog As ToggleButton
      

      cmdCancel.SetFocus 'avoid problems when setting controls to not visisble

      items = Split(s, ";")
      If UBound(items) > 3 Then
         Err.Raise vbObjectError + 512, "Form_UserListChoice:ListRowSource", "When using buttons, may only pass a maximum of 4 choices.  Supplied value list was: " & s
      End If
      
      For i = 1 To MaxButtons
         Set tog = Me.Controls("togOption" & CStr(i))
         Debug.Assert Not (tog Is Nothing)
         If (i - 1) <= UBound(items) Then
            tog.Visible = True
            tog.Caption = items(i - 1)
         Else
            tog.Visible = False
         End If
      Next
   End If
End Property

Public Property Let ListColumnCount(i As Integer)
   lstItems.ColumnCount = i
End Property
Public Property Let ListColumnWidths(s As String)
   lstItems.ColumnWidths = s
End Property

Public Property Get ListValue() As Variant
   'if using in AllowMultiSelect mode, always returns the first selected item
   If m_ShowAsButtons Then
      ListValue = m_OptionChosen
   
   Else
'      If lstItems.ColumnCount > 1 Then
'         ListValue = lstItems.Value
'      Else
'         ListValue = lstItems.ListIndex + 1
'      End If

      If lstItems.ItemsSelected.Count > 0 Then
         If lstItems.ColumnCount > 1 Then  'if more than one column, assume the first column is the hidden value column
            ListValue = lstItems.Column(0, lstItems.ItemsSelected.Item(0))
         Else
            ListValue = lstItems.ItemsSelected.Item(0) + 1  'otherwise, return the index of the selection
         End If
      Else
      End If
   End If
End Property
Public Property Let ListValue(v As Variant)
   Dim i As Long
   For i = 0 To lstItems.ListCount - 1
      If lstItems.ItemData(i) = v Then
         lstItems.Selected(i) = True
      End If
   Next i

   If lstItems.ItemsSelected.Count > 0 Then
      cmdOK.Enabled = True
   End If

'   On Error Resume Next
'   lstItems.Value = v
'   On Error GoTo 0
'
'   'if caller specifies a default selected value, enable the OK button
'   If Not IsNull(lstItems.Value) Then
'      If lstItems.Value = v Then
'         cmdOK.Enabled = True
'      End If
'   End If

End Property

Public Property Get SelectedValues() As Long()
   Dim arrSelectedValues() As Long
   Dim varItm As Variant, i As Integer

   If m_AllowMultiSelect Then
      If lstItems.ItemsSelected.Count > 0 Then
         ReDim arrSelectedValues(lstItems.ItemsSelected.Count - 1)
         i = 0
         For Each varItm In lstItems.ItemsSelected
            arrSelectedValues(i) = lstItems.ItemData(Nz(varItm, 0))
            i = i + 1
         Next varItm
      End If
   Else
      ReDim arrSelectedValues(0)
      arrSelectedValues(0) = Nz(Me.ListValue, 0)
   End If
   SelectedValues = arrSelectedValues
End Property

Public Property Get UserOK() As Boolean
   UserOK = m_UserOK
End Property
Public Property Get UserCancel() As Boolean
   UserCancel = m_UserCancel
End Property

Private Sub cmdCancel_Click()
   m_UserCancel = True
End Sub

Private Sub cmdOK_Click()
   m_UserOK = True
End Sub


Private Sub Form_Load()
   DoCmd.Restore
End Sub

Private Sub fraOptionButtons_Click()
   m_OptionChosen = fraOptionButtons.value
   m_UserOK = True
End Sub

Private Sub lstItems_Click()
   Static PreviousSelectedItemIndex As Long

   cmdOK.Enabled = (lstItems.ItemsSelected.Count > 0)

   If Not m_AllowMultiSelect Then
      'since the list box is set to allow MultiSelect in the design mode, we must unselect the previous items
      If lstItems.ItemsSelected.Count > 1 Then 'if there are now two selected items, un-select the previous selection
         lstItems.Selected(PreviousSelectedItemIndex) = False
         PreviousSelectedItemIndex = lstItems.ItemsSelected.Item(0)  'now there should be only one item selected (the one the user has just chosen)
      End If

      If lstItems.ItemsSelected.Count > 0 Then
         PreviousSelectedItemIndex = lstItems.ItemsSelected.Item(0)
      End If
   End If
End Sub
----------- end of component
